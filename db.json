{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/apple-touch-icon.png","path":"img/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/clipboard-use.js","path":"js/clipboard-use.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/lazyload.js","path":"js/lazyload.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/main.js","path":"js/main.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"b58f79bc13500baacb5d50af9e7ac4c3c72b4354","modified":1582606505551},{"_id":"themes/hexo-theme-fluid/.gitignore","hash":"bd095eee271360a38772ee1a42d4f000fb722e5f","modified":1588211222084},{"_id":"themes/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1588211222083},{"_id":"themes/hexo-theme-fluid/.eslintrc","hash":"0a59eec340b771758cf736290272c549d81ef88c","modified":1588211222083},{"_id":"themes/hexo-theme-fluid/LICENSE","hash":"5b919c12e4f5f5cdebb7c17ded4f10f1ebe64811","modified":1588211222085},{"_id":"themes/hexo-theme-fluid/README.md","hash":"7ae79ceedecc81feda7cf8f56c93cb330eb1145c","modified":1588211222085},{"_id":"themes/hexo-theme-fluid/README_en.md","hash":"cc9b7e5c3918e6b3064c8ec4b0abfd0ba66ea7fc","modified":1588211222085},{"_id":"themes/hexo-theme-fluid/_config.yml","hash":"eaf0151767bb4ad7d9854c431b4c0f9355cd5807","modified":1588211222085},{"_id":"themes/hexo-theme-fluid/_static_prefix.yml","hash":"48ee71329c4a5b9a5c7b53447061fbd61334e3db","modified":1588211222085},{"_id":"themes/hexo-theme-fluid/gulpfile.js","hash":"dc82b6be72c786721a2f5e2acc10a2a94995c540","modified":1588211222085},{"_id":"themes/hexo-theme-fluid/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1588211222092},{"_id":"themes/hexo-theme-fluid/package.json","hash":"a875d19e7bdfbbc60c8c45a6f281f192a3069641","modified":1588211222092},{"_id":"source/_posts/.DS_Store","hash":"f46f6d0a2677057a3b1169f2954f46c1b541c201","modified":1582606520556},{"_id":"source/_posts/FastJson笔记.md","hash":"f516f1190d4ae3ceb5c9c616600cd4039d9cbf3d","modified":1577688013312},{"_id":"source/_posts/Redis底层数据笔记.md","hash":"00cfbe4cfec339ddce2b3364a0ba7c2f4e4aa3b1","modified":1577688013312},{"_id":"source/_posts/JVM垃圾回收笔记.md","hash":"3738273da980b8a7ffc680b4396632fe998782be","modified":1577688013312},{"_id":"source/_posts/SQL笔记.md","hash":"50ffafe95ec9837b5d6049a79549252afaea7660","modified":1577688013312},{"_id":"source/_posts/SecureFX中文乱码.md","hash":"4652081f9eaf882efd8113de706910e2b6b3dd1b","modified":1577688013312},{"_id":"source/_posts/SpringBoot与Vue的整合及部署.md","hash":"635ee29fcdabb4041892349440717ca5905e6c80","modified":1577688013313},{"_id":"source/_posts/Entity，Bo，Vo，Po,Dto,Pojo的理解和区分.md","hash":"6470a9f58e28336a49784e7e4ef38b38f772ecd4","modified":1586239979033},{"_id":"source/_posts/Tomcat开放远程链接权限.md","hash":"2216f889824c5629824aa49eeb25a58581fabe65","modified":1577688013313},{"_id":"source/_posts/Spring单元测试编写.md","hash":"def1db8b25fbfc7fe1a0a9c956ec389e5d46a00a","modified":1586239779976},{"_id":"source/_posts/Vuex语法集合.md","hash":"b35dc1ebe5159f3ed88e00b759b93410958ccb97","modified":1577688013313},{"_id":"source/_posts/springMVC项目使用AOP日志记录.md","hash":"3130c3df785a39d0b3f80844a2d74ce271097f23","modified":1577688013314},{"_id":"source/_posts/hello-world.md","hash":"107f68e8ae209420f5ec0f4885805325eb3cd20b","modified":1577688013313},{"_id":"source/_posts/云服务器Tomcat启动加速.md","hash":"ef2e3b1df88b9c5c6b0a627499c6265c29dc8003","modified":1577688013314},{"_id":"source/_posts/Tomcat进程守护脚本.md","hash":"6f218df30db917c77321a67f3e5feab6ef614412","modified":1586238834817},{"_id":"source/_posts/关闭MAC系统下AnyDesk开机自启.md","hash":"94837f25050162da0fe18fc62dc681b3596f5c51","modified":1577688013314},{"_id":"source/_posts/存储过程.md","hash":"3bb2911dc47c0a8f088213d051c45ff8f60741ad","modified":1577688013315},{"_id":"source/_posts/利用脚本统一管理网络代理.md","hash":"a80bb2b3f69906dd4264e23b109e303816912aed","modified":1577688013314},{"_id":"source/about/index.md","hash":"f7aba9cb66919b009d21de28bf321beeaa45adfe","modified":1577688013315},{"_id":"source/data/fluid_config.yml","hash":"eaf0151767bb4ad7d9854c431b4c0f9355cd5807","modified":1588212027327},{"_id":"themes/hexo-theme-fluid/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1588211222078},{"_id":"themes/hexo-theme-fluid/.git/config","hash":"99a605d29f216fc79891d08948f7961c18891f59","modified":1588211222080},{"_id":"themes/hexo-theme-fluid/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1588211108175},{"_id":"themes/hexo-theme-fluid/.git/packed-refs","hash":"dcbf95eab0c73e161e7d050faf9062e4e8f40024","modified":1588211222076},{"_id":"themes/hexo-theme-fluid/.git/index","hash":"ecb8fc765871a301e828690b4a81e55bec2afa76","modified":1588211424742},{"_id":"themes/hexo-theme-fluid/languages/ja.yml","hash":"3bf2824d4f32415ef228d92e08aa5c76f04e475b","modified":1588211222086},{"_id":"themes/hexo-theme-fluid/languages/en.yml","hash":"370b61742ea947934c72331ad29a2f1ec10db70f","modified":1588211222086},{"_id":"themes/hexo-theme-fluid/languages/zh-CN.yml","hash":"ccc2ec0c56c5de49ca3b39da7f4d23edab59a942","modified":1588211222086},{"_id":"themes/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":1588211222086},{"_id":"themes/hexo-theme-fluid/layout/about.ejs","hash":"1b966bd7c1c2627112bbbc8c9765b44e37bbda5b","modified":1588211222091},{"_id":"themes/hexo-theme-fluid/layout/archive.ejs","hash":"783ce7efe83bd72e3c767fd5a190ad38113ff34f","modified":1588211222091},{"_id":"themes/hexo-theme-fluid/layout/categories.ejs","hash":"7e0cf48bf6f35ce44b4207058d41b99019161d6f","modified":1588211222091},{"_id":"themes/hexo-theme-fluid/layout/category.ejs","hash":"cf7260650f77336c20ee8f9c4898f336d3a98ee2","modified":1588211222091},{"_id":"themes/hexo-theme-fluid/layout/index.ejs","hash":"31c62687deb7d224c9b7f4e6d0d5f43406dd3fce","modified":1588211222091},{"_id":"themes/hexo-theme-fluid/layout/links.ejs","hash":"0bb8360ad6a2433fdeddf01fbd39b4f2db67b08f","modified":1588211222092},{"_id":"themes/hexo-theme-fluid/layout/layout.ejs","hash":"58ad7b6a88c1f86f58b6a18100206c074e0e91d3","modified":1588211222091},{"_id":"themes/hexo-theme-fluid/layout/page.ejs","hash":"8cab50ead4cdb992d35710147a9a5308fb5df290","modified":1588211222092},{"_id":"themes/hexo-theme-fluid/layout/post.ejs","hash":"8aeb4546f0188284f8d5b919649831ea7566a7a4","modified":1588211222092},{"_id":"themes/hexo-theme-fluid/layout/tag.ejs","hash":"8c9dd4ba1cc259972c257826419bacdcab26f47a","modified":1588211222092},{"_id":"themes/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1588211222092},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/blank.md","hash":"b6a895c5094a95b22132ac02c05b635bc51241a2","modified":1588211222083},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"549e67fc53c3063dda86d4bb4a981c55cf626400","modified":1588211222083},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/blank_zh.md","hash":"9701cbd36c90d3a0f8ca71dea9d8a1c30f89c394","modified":1588211222083},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"296c23b30ca21e176f04f0bb12ec77abf4836a95","modified":1588211222084},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"6e9b964665a70ef49f4b08a9bb0aa7f1d4f07741","modified":1588211222084},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"3ca580473d337f011052678fbc2a276d09769f0d","modified":1588211222084},{"_id":"themes/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1588211222084},{"_id":"themes/hexo-theme-fluid/.github/workflows/lint.yaml","hash":"0c02cc7e5a1318c481a6f523747407b29da58645","modified":1588211222084},{"_id":"themes/hexo-theme-fluid/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1588211108177},{"_id":"themes/hexo-theme-fluid/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1588211108175},{"_id":"themes/hexo-theme-fluid/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1588211108177},{"_id":"themes/hexo-theme-fluid/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1588211108178},{"_id":"themes/hexo-theme-fluid/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1588211108178},{"_id":"themes/hexo-theme-fluid/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1588211108179},{"_id":"themes/hexo-theme-fluid/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1588211108176},{"_id":"themes/hexo-theme-fluid/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1588211108176},{"_id":"themes/hexo-theme-fluid/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1588211108177},{"_id":"themes/hexo-theme-fluid/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1588211108178},{"_id":"themes/hexo-theme-fluid/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1588211108179},{"_id":"themes/hexo-theme-fluid/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1588211108174},{"_id":"themes/hexo-theme-fluid/.git/logs/HEAD","hash":"d0c9e053a0919d4b9ebe71a33a139ca114888748","modified":1588211222079},{"_id":"themes/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"049d6088b2a02dbbedcd761166b236aa5bf0588e","modified":1588211222086},{"_id":"themes/hexo-theme-fluid/layout/_partial/busuanzi.ejs","hash":"cec5a8c84131039eb1f2c3df9310433421f87fb8","modified":1588211222086},{"_id":"themes/hexo-theme-fluid/layout/_partial/css.ejs","hash":"57564f32640702cb5a742feb5d62489da84a3f49","modified":1588211222088},{"_id":"themes/hexo-theme-fluid/layout/_partial/head.ejs","hash":"ea023654308f1225316b613f5a74cf5ea1e1677e","modified":1588211222088},{"_id":"themes/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"244d73e47da3359ce30147e495d22fadf3c8e086","modified":1588211222088},{"_id":"themes/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"7b91aa45bcd77914ee5d2182e97cdb42f19c76a4","modified":1588211222088},{"_id":"themes/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"783eee847562ce14db8f723b4ae742fb69aaf620","modified":1588211222088},{"_id":"themes/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1588211222090},{"_id":"themes/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"43db23662e22fef3635a92cba3b260423cbebbd0","modified":1588211222090},{"_id":"themes/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3cf1d9b9032919d6b936e1f2410911df3b325670","modified":1588211222090},{"_id":"themes/hexo-theme-fluid/scripts/events/index.js","hash":"3b19adcf3d624bea40ebc2db8cf9dbd268a1f689","modified":1588211222092},{"_id":"themes/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6665f19fa30cbbe0853d8140a0832f8638538f89","modified":1588211222093},{"_id":"themes/hexo-theme-fluid/scripts/helpers/page.js","hash":"d45dce23532c17367c7eb86b94afa8c9e40d16c6","modified":1588211222094},{"_id":"themes/hexo-theme-fluid/scripts/helpers/url.js","hash":"3dd2f3dc50228ac4c67d7267b2c695641b75653c","modified":1588211222094},{"_id":"themes/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":1588211222094},{"_id":"themes/hexo-theme-fluid/scripts/generators/local-search.js","hash":"bb90a128a999b276c10a822c44851fa27d6d64ae","modified":1588211222094},{"_id":"themes/hexo-theme-fluid/scripts/generators/pages.js","hash":"f64d2121d99225e9f6d12ce646af618232f5f366","modified":1588211222094},{"_id":"themes/hexo-theme-fluid/scripts/tags/button.js","hash":"ccd013b5e69333b21ebad3b8a58c5d7d81962b89","modified":1588211222095},{"_id":"themes/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"baee0ae1704a1a63b7b27d7744d101f479bc685e","modified":1588211222095},{"_id":"themes/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1588211222095},{"_id":"themes/hexo-theme-fluid/scripts/tags/label.js","hash":"b8b3688012033a2ee406661626420b1aee78e650","modified":1588211222095},{"_id":"themes/hexo-theme-fluid/scripts/tags/note.js","hash":"f4a6cfe0d87aa936b78f09f02276a4c89c7f6964","modified":1588211222095},{"_id":"themes/hexo-theme-fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":1588211222095},{"_id":"themes/hexo-theme-fluid/scripts/utils/object.js","hash":"61e9555f99edcb23d55361c7154e23af33153ecb","modified":1588211222096},{"_id":"themes/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":1588211222099},{"_id":"themes/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1588211222100},{"_id":"themes/hexo-theme-fluid/source/img/apple-touch-icon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1588211222099},{"_id":"themes/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1588211222100},{"_id":"themes/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1588211222101},{"_id":"themes/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1588211222101},{"_id":"themes/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1588211222101},{"_id":"themes/hexo-theme-fluid/source/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":1588211222102},{"_id":"themes/hexo-theme-fluid/source/js/lazyload.js","hash":"1762c7e317422c0438775beef1307139fccaecb0","modified":1588211222102},{"_id":"themes/hexo-theme-fluid/source/js/local-search.js","hash":"5e36b80ad9594246f78da743a742527382b7cd50","modified":1588211222102},{"_id":"themes/hexo-theme-fluid/source/js/main.js","hash":"903de57695ff8161d3a3f6fd450125a77cec8130","modified":1588211222102},{"_id":"themes/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588211222096},{"_id":"themes/hexo-theme-fluid/.git/refs/heads/master","hash":"8ea7885a69792dee1f6961e4202063887637e23a","modified":1588211222079},{"_id":"themes/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"71410cabde9641497f845346df93ef4739ba3318","modified":1588211222087},{"_id":"themes/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"8c5a209258746db8842ae64a9da69980ff2247d3","modified":1588211222087},{"_id":"themes/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"89ccda4c47f8502b77c8787061f1b3f8cd7df96e","modified":1588211222087},{"_id":"themes/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"01406b8bdfece518a30325cef9f2581ffcc9cb5e","modified":1588211222087},{"_id":"themes/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"cf8f5703344c6966d756c5bdaa0be70637a4f0e4","modified":1588211222087},{"_id":"themes/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"ae41aecf3f3ec8c0ff1d3e0c74f86f0f10ecc73d","modified":1588211222087},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/anchor.ejs","hash":"40032ca6af619716fa3479eeb9a5f47924d95126","modified":1588211222089},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"db103077a6957c9d4786e98fd8144d6a5b03c495","modified":1588211222088},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/aplayer.ejs","hash":"e843cdbe64af3dee9385eb1d763539d3ac10ed72","modified":1588211222089},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/daovoice.ejs","hash":"cfc684ba48608abd25afd155ee373d9936bbe84e","modified":1588211222089},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/fancybox.ejs","hash":"c447e35c93c61a70c1c2dfc34948615832989660","modified":1588211222089},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/local-search.ejs","hash":"03b024c7bab51b64e5187c9dbfac039d020f1e97","modified":1588211222089},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":1588211222089},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":1588211222089},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/mouse-click.ejs","hash":"eb19991199c201ceb103a6ef025e4dfd1e7dbfb7","modified":1588211222090},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/tocjs.ejs","hash":"889b233437b31be6c22a473cf477a051cecf29d7","modified":1588211222090},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"2ee91a9782ffca316b12ab45a96a9bbafe57e5af","modified":1588211222090},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"da4c281a8b2d2ed813da1236950c9dff87334adc","modified":1588211222093},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"66d0540f42c50aae07167ae5d36da11f7a2e6f80","modified":1588211222093},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"ee7dfef805af96195c11223cca53983deace8bda","modified":1588211222093},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"24431dc03e8bdaa011713a4a14d3ac485aca5a6e","modified":1588211222093},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/version.js","hash":"eb2df4547a446b390ddc7af291bbdb4a5018fbd4","modified":1588211222093},{"_id":"themes/hexo-theme-fluid/source/css/_functions/base.styl","hash":"37cdcd3c43cc89c6dc929f90bf342c6d33af0622","modified":1588211222096},{"_id":"themes/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1588211222099},{"_id":"themes/hexo-theme-fluid/source/css/_variables/base.styl","hash":"9941bf94cbb20d9e45e63957638c258b5c7de18d","modified":1588211222099},{"_id":"themes/hexo-theme-fluid/.git/objects/pack/pack-40f163508f8e05f3cec4f7863a0f88e98f187765.idx","hash":"3f2b9e8993d68e20203e51d504d2a92dc2aa040c","modified":1588211222057},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588211222097},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588211222099},{"_id":"themes/hexo-theme-fluid/.git/logs/refs/heads/master","hash":"d0c9e053a0919d4b9ebe71a33a139ca114888748","modified":1588211222079},{"_id":"themes/hexo-theme-fluid/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1588211222078},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":1588211222096},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"7e07e44fa0e77ddbdd3aa0c0abdb3be6822df2e0","modified":1588211222096},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"5b4c376f1d407ee14ae8194a7b8be849b7edf677","modified":1588211222097},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"c34979b9b8e5c9cb54dcdd73a1fe877bcb943548","modified":1588211222097},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"53cc57b8dbbb4062953f8f981fa7a1f5481d6c91","modified":1588211222097},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"156029204344c724b5d469f05ff8d26c5e141bce","modified":1588211222097},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"9ce4d5d708047520345a85bbfc101b3e67dbf7b8","modified":1588211222098},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"c5a771c10c31479e9744d7bb0e2a8ae58fd80ceb","modified":1588211222098},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"47fa0538e3e3f0363c3e23c09fc2c6b4c750801d","modified":1588211222098},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"37043762d345f33dc1817c18e4ac6c47551f6d42","modified":1588211222098},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"934a6ae74b29a6903d2309498653910c19a77c8b","modified":1588211222099},{"_id":"themes/hexo-theme-fluid/.git/logs/refs/remotes/origin/HEAD","hash":"d0c9e053a0919d4b9ebe71a33a139ca114888748","modified":1588211222078},{"_id":"themes/hexo-theme-fluid/.git/objects/pack/pack-40f163508f8e05f3cec4f7863a0f88e98f187765.pack","hash":"8311ffb02a1f101f2f6ab2803f2046dcdb42f812","modified":1588211222055},{"_id":"public/data/fluid_config.json","hash":"e48178da611ce7a4ccce6d56ac7b91dc392574c1","modified":1588212769144},{"_id":"public/search.xml","hash":"3de3cb776aa0f7409538245143ae588bd8dabc07","modified":1588212769145},{"_id":"public/local-search.xml","hash":"8c317e7f215cd2a6840d4407c46b3e90313575af","modified":1588212769551},{"_id":"public/about/index.html","hash":"c062890a45a46a76919cdc6846a1b1381f48a381","modified":1588212769642},{"_id":"public/2020/02/24/Entity，Bo，Vo，Po,Dto,Pojo的理解和区分/index.html","hash":"9ac3855fdb30eff917dbd4c470bca48c354b22d2","modified":1588212769642},{"_id":"public/2020/02/24/Tomcat进程守护脚本/index.html","hash":"06ac4ef7636af187772b1a92dca3caed76f3cc8e","modified":1588212769642},{"_id":"public/2019/12/30/hello-world/index.html","hash":"ab9453efe3ca88a0423fed187387009f78a5a074","modified":1588212769642},{"_id":"public/2019/07/30/springMVC项目使用AOP日志记录/index.html","hash":"3a5e3401de0ce90c106aa40be2ed9cd552d68bd7","modified":1588212769642},{"_id":"public/2019/06/29/SecureFX中文乱码/index.html","hash":"dcc7ff6e7bea39e3e46f3e97d5485ce49e0f0a2b","modified":1588212769643},{"_id":"public/2019/06/29/关闭MAC系统下AnyDesk开机自启/index.html","hash":"67c44b7fbe0e59714fde8fb1b1fb3e9b2a46bef7","modified":1588212769643},{"_id":"public/2019/05/29/SQL笔记/index.html","hash":"fba6e936c39f979a6097d9f52a08a20fb3e9d3e2","modified":1588212769643},{"_id":"public/2019/05/28/云服务器Tomcat启动加速/index.html","hash":"f863f75673daa4222c0fdd4f11fdfb4fbb98eb51","modified":1588212769643},{"_id":"public/2019/05/28/FastJson笔记/index.html","hash":"aa48e9fdbea6621f0a04d853d508d892413d9da1","modified":1588212769643},{"_id":"public/2019/05/12/Tomcat开放远程链接权限/index.html","hash":"6d050a73ce230a285b098dd7c9b75dc3fb1be0d1","modified":1588212769643},{"_id":"public/2019/05/12/Vuex语法集合/index.html","hash":"05fc491ee1a807a2049323286636020f01562028","modified":1588212769643},{"_id":"public/page/2/index.html","hash":"3495b2d384404c45a6c7ccc24e5693a099b730c8","modified":1588212769643},{"_id":"public/categories/Code/index.html","hash":"747d465e159ff0b81a7d36d26eee53b5ee7612c7","modified":1588212769643},{"_id":"public/archives/index.html","hash":"ce861052b85e0124e5cee5ffd29a078870d45ca7","modified":1588212769643},{"_id":"public/archives/page/2/index.html","hash":"37841d5dba37d04ebac865612eeb4898c6f9dce4","modified":1588212769643},{"_id":"public/archives/2019/index.html","hash":"d8a86e691222787b56ad5d0b3c4b3024770e9a10","modified":1588212769643},{"_id":"public/archives/2019/page/2/index.html","hash":"b017e945e38954000e032961fc961b366927f592","modified":1588212769644},{"_id":"public/archives/2019/05/index.html","hash":"043c17a723bf953aacfb50952971228427a9d1fa","modified":1588212769644},{"_id":"public/archives/2019/06/index.html","hash":"f161ce1797903c851bc5b13160d39afcfce75930","modified":1588212769644},{"_id":"public/archives/2019/07/index.html","hash":"e56bf8d47631efccce2a881a23739a9815af0759","modified":1588212769644},{"_id":"public/archives/2019/08/index.html","hash":"da856a4a4f39873a1280d1a346ef7a6961af7c37","modified":1588212769644},{"_id":"public/archives/2019/12/index.html","hash":"96d5db5702744d8efc36944c92fa7b10573d8f73","modified":1588212769644},{"_id":"public/archives/2020/index.html","hash":"5387848d28edc564ad6e6eeee1ae3914b6f671f3","modified":1588212769644},{"_id":"public/archives/2020/01/index.html","hash":"09589c31975305e82f4d4187ad108853ec1ed456","modified":1588212769644},{"_id":"public/archives/2020/02/index.html","hash":"3ff24bdb3f44893de6b8b5a3e7be01964113ed21","modified":1588212769644},{"_id":"public/tags/JSON/index.html","hash":"95623d5b0da1108842855beffda539ba0e27badc","modified":1588212769645},{"_id":"public/tags/SpringBoot/index.html","hash":"5542d7bb2c832779f3f6498ae259265aedbf0070","modified":1588212769645},{"_id":"public/tags/JVM/index.html","hash":"9405ec21c4c1a0cfb785cc01dcd0332692213e9b","modified":1588212769645},{"_id":"public/tags/JAVA/index.html","hash":"3553ef33263d58cc506aaa669b759635ed494333","modified":1588212769645},{"_id":"public/tags/后端/index.html","hash":"5ce344bcb516986bd9aca7820fbe9019f3d137b7","modified":1588212769645},{"_id":"public/tags/SQL/index.html","hash":"48be7a1f0e072b9f7d244942efc3e731bba21394","modified":1588212769645},{"_id":"public/tags/数据库/index.html","hash":"c9f7bedc63e26261ca3ebec2a0c721ac14641f1c","modified":1588212769645},{"_id":"public/tags/MAC系统/index.html","hash":"d00a2b8f909f38b0e1135ed9c0669b8f957ed4f0","modified":1588212769645},{"_id":"public/tags/软件/index.html","hash":"48ce0ea479f014ad3d56f8a8570ca2f22f537d68","modified":1588212769646},{"_id":"public/tags/Vue/index.html","hash":"36cf04ed1b60c6abdfdc24a70547a9e7d148497a","modified":1588212769646},{"_id":"public/tags/单元测试/index.html","hash":"1c3765d99d0433e7df677938cd2a6b7ab7492abd","modified":1588212769646},{"_id":"public/tags/运维/index.html","hash":"ea0cbac5d03e9ddfc2568852ea44c2e234f136cf","modified":1588212769646},{"_id":"public/tags/Tomcat/index.html","hash":"9e759106ab4c408b3b4d683d68a1401472a743ac","modified":1588212769646},{"_id":"public/tags/SpringMVC/index.html","hash":"e544d24f48e787edf6415145c71281107e5b8264","modified":1588212769646},{"_id":"public/tags/AOP/index.html","hash":"7c59545c557a5a8b6089c75752d8435e759e80bc","modified":1588212769646},{"_id":"public/tags/日志处理/index.html","hash":"4213bb0954c75a184c6084b0797d7a0112e6555c","modified":1588212769646},{"_id":"public/tags/前端/index.html","hash":"e787d5601ba90369a00373437dcfb06b14e42c02","modified":1588212769646},{"_id":"public/tags/云服务器/index.html","hash":"dce8b2f38b62209ba4db9d5f2801686252d3a659","modified":1588212769646},{"_id":"public/tags/TOMCAT/index.html","hash":"38d28a74052b7972460b7baff47e5f5fde1acdf1","modified":1588212769646},{"_id":"public/tags/SHELL/index.html","hash":"7ba06141d85e37672afbfe1b00872e0aee4b05a1","modified":1588212769646},{"_id":"public/tags/ORACLE/index.html","hash":"dadd081d9dfd7ecabec70fef4f3e526cd222b613","modified":1588212769646},{"_id":"public/tags/存储过程/index.html","hash":"c642486e621170f0a5f021f05c986b5f778b47fe","modified":1588212769646},{"_id":"public/tags/脚本/index.html","hash":"ac3fd9e7c652eb5b22a508814b45f08915c0aebf","modified":1588212769647},{"_id":"public/tags/Redis/index.html","hash":"4acc65e2900331b6643c627028942f3fd4bb9b68","modified":1588212769647},{"_id":"public/404.html","hash":"56e89373218ff83cdcc658abc2139b6f14a30edf","modified":1588212769647},{"_id":"public/tags/index.html","hash":"99828478e106ca1fc41ad4db06bf082bad9ab937","modified":1588212769647},{"_id":"public/categories/index.html","hash":"c59fa50ba2af282b6d224ee4cfa07cdfa13144f5","modified":1588212769647},{"_id":"public/links/index.html","hash":"0db66514d2aa1e93b67c7d1c47b98d729ae2eea4","modified":1588212769647},{"_id":"public/2020/01/22/Spring单元测试编写/index.html","hash":"83fa93630730789d74ce47ba01594c20859865c5","modified":1588212769647},{"_id":"public/2019/08/05/存储过程/index.html","hash":"73b7fe8f187631c62b612b37608e5b2b5d2d02fd","modified":1588212769647},{"_id":"public/2019/07/02/Redis底层数据笔记/index.html","hash":"4a83c8945936aa7c8eca352f5339b753b73d5957","modified":1588212769647},{"_id":"public/2019/06/12/JVM垃圾回收笔记/index.html","hash":"14fd05640e19536b2fe053ea9da796ec7b8eaef8","modified":1588212769647},{"_id":"public/2019/06/01/利用脚本统一管理网络代理/index.html","hash":"cd6835aabdad8525276522dc59bd491e60e7be6d","modified":1588212769647},{"_id":"public/2019/05/12/SpringBoot与Vue的整合及部署/index.html","hash":"d28dff932a156377db1c364f5ca4f93eba9e8320","modified":1588212769647},{"_id":"public/index.html","hash":"830da83f14076f93eb6725863a782626e4e9074e","modified":1588212769647},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1588212769652},{"_id":"public/img/apple-touch-icon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1588212769652},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1588212769652},{"_id":"public/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1588212769652},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1588212769652},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1588212769652},{"_id":"public/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":1588212770018},{"_id":"public/js/lazyload.js","hash":"1762c7e317422c0438775beef1307139fccaecb0","modified":1588212770019},{"_id":"public/js/local-search.js","hash":"5e36b80ad9594246f78da743a742527382b7cd50","modified":1588212770019},{"_id":"public/js/main.js","hash":"903de57695ff8161d3a3f6fd450125a77cec8130","modified":1588212770019},{"_id":"public/css/main.css","hash":"e4ed17d7fadcfb2924a803f3997bbc001270c435","modified":1588212770019},{"_id":"themes/hexo-theme-icarus/.gitignore","hash":"36084c0851a22bfd393933abb8e262562ffc6802","modified":1588215023227},{"_id":"themes/hexo-theme-icarus/.eslintignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1588215023226},{"_id":"themes/hexo-theme-icarus/.eslintrc.json","hash":"43c7740158c8690242720b4ff7fa11426fc20c79","modified":1588215023226},{"_id":"themes/hexo-theme-icarus/.travis.yml","hash":"0a96b9f82de11bd524a74a3de9a32fd6cd6a6b47","modified":1588215023227},{"_id":"themes/hexo-theme-icarus/CONTRIBUTING.md","hash":"0a78b3eb68d41c22735df35447c392c0f3332ea5","modified":1588215023227},{"_id":"themes/hexo-theme-icarus/README.md","hash":"c948b354de7161e51f4f87e33393295051d7a7c3","modified":1588215023228},{"_id":"themes/hexo-theme-icarus/_config.yml","hash":"6d0da801b9b9f3f16244cbc3e98a87fe34a44196","modified":1588216431614},{"_id":"themes/hexo-theme-icarus/LICENSE","hash":"41f72cd544612bc4589c924c776422b800a4eff7","modified":1588215023228},{"_id":"themes/hexo-theme-icarus/package.json","hash":"9080de9f1223fe9906312a3f3b1096fe0eb82e38","modified":1588215023248},{"_id":"themes/hexo-theme-icarus/.github/stale.yml","hash":"4771f82196ff95de48f9db4696ce316790f21865","modified":1588215023227},{"_id":"themes/hexo-theme-icarus/include/config.js","hash":"13feb2c1ac64f5598f335985fb1ee4bc5e9389f1","modified":1588215023228},{"_id":"themes/hexo-theme-icarus/include/dependency.js","hash":"3f84538fa2f528634a1f8254c49ab4c5ebfb19e7","modified":1588215023228},{"_id":"themes/hexo-theme-icarus/include/register.js","hash":"90c55de6c114018e2ac517a2d469e2ea4cd193c5","modified":1588215023229},{"_id":"themes/hexo-theme-icarus/languages/es.yml","hash":"2e59e579d393c881dcbb885516d93eeaf469cec2","modified":1588215023240},{"_id":"themes/hexo-theme-icarus/languages/de.yml","hash":"79d769768780b9a72eb256ab61f217b8bdebf85b","modified":1588215023239},{"_id":"themes/hexo-theme-icarus/languages/id.yml","hash":"92d2d19a62a17b6e99f82a014309bbf6c13c9ae8","modified":1588215023240},{"_id":"themes/hexo-theme-icarus/languages/en.yml","hash":"792bc85571b0c16f591bb5455819793a02373017","modified":1588215023239},{"_id":"themes/hexo-theme-icarus/languages/fr.yml","hash":"0017f93a5d491a9c0e55911cdc35316762c5a94e","modified":1588215023240},{"_id":"themes/hexo-theme-icarus/languages/ja.yml","hash":"6eed7771de2353d71b720c6e605cceb3f230b12e","modified":1588215023240},{"_id":"themes/hexo-theme-icarus/languages/ko.yml","hash":"e7ac736b604429adedd67f3ca6043201eff7b23b","modified":1588215023240},{"_id":"themes/hexo-theme-icarus/languages/pt-BR.yml","hash":"bcf5bc81ca855d26bbc3b3bfabc7d84429e74b85","modified":1588215023241},{"_id":"themes/hexo-theme-icarus/languages/pl.yml","hash":"43f5447c38c9be2e1f5ce6181a0f97eeb437b059","modified":1588215023241},{"_id":"themes/hexo-theme-icarus/languages/tr.yml","hash":"eff1c0b3d5c4b328f6dd74a195ff378c898f4d29","modified":1588215023241},{"_id":"themes/hexo-theme-icarus/languages/ru.yml","hash":"ba8b4f7d77eb1d1e28aa1f9107bd0bbbdc4cba99","modified":1588215023241},{"_id":"themes/hexo-theme-icarus/languages/zh-TW.yml","hash":"9172121b0ec3d78861fa6ccdd6396cef90fabdc7","modified":1588215023242},{"_id":"themes/hexo-theme-icarus/languages/vn.yml","hash":"6d9f4fabca711a6cb0a0efd72aa75c3641beb4a6","modified":1588215023242},{"_id":"themes/hexo-theme-icarus/languages/zh-CN.yml","hash":"2f21370cb9aaa7bbe4f362618df450d7bc571a63","modified":1588215023242},{"_id":"themes/hexo-theme-icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1588215023243},{"_id":"themes/hexo-theme-icarus/layout/archive.jsx","hash":"09c58b8e431445f1b40f2b19bc03ebc1a07a2a43","modified":1588215023242},{"_id":"themes/hexo-theme-icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1588215023243},{"_id":"themes/hexo-theme-icarus/layout/layout.jsx","hash":"66c95ba388c7129b8fda7ccd8b15a43144ee07d0","modified":1588215023246},{"_id":"themes/hexo-theme-icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1588215023246},{"_id":"themes/hexo-theme-icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1588215023246},{"_id":"themes/hexo-theme-icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1588215023248},{"_id":"themes/hexo-theme-icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1588215023248},{"_id":"themes/hexo-theme-icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1588215023247},{"_id":"themes/hexo-theme-icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":1588215023249},{"_id":"themes/hexo-theme-icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588215023243},{"_id":"themes/hexo-theme-icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588215023245},{"_id":"themes/hexo-theme-icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588215023246},{"_id":"themes/hexo-theme-icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588215023247},{"_id":"themes/hexo-theme-icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588215023247},{"_id":"themes/hexo-theme-icarus/.github/ISSUE_TEMPLATE/feature_request.md","hash":"0cbf106d95bf9991d850671a9e804f74a1783caa","modified":1588215023227},{"_id":"themes/hexo-theme-icarus/.github/ISSUE_TEMPLATE/bug_report.md","hash":"e2426853cb623d500021011820bea4726341a3d2","modified":1588215023226},{"_id":"themes/hexo-theme-icarus/.github/PULL_REQUEST_TEMPLATE/pull_request_template.md","hash":"001de87a96271fd7676fbf0fef090369369c2cc4","modified":1588215023227},{"_id":"themes/hexo-theme-icarus/include/migration/head.js","hash":"cca7d3a828427cbdd5cbc6a93e501a4fea1c72fd","modified":1588215023229},{"_id":"themes/hexo-theme-icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":1588215023229},{"_id":"themes/hexo-theme-icarus/include/schema/config.json","hash":"f91dc103f4a95c870b4d6824dfe005289db5e309","modified":1588215023233},{"_id":"themes/hexo-theme-icarus/include/style/base.styl","hash":"ea038ebd8dcd442e54814e7529aa0ec5d4991977","modified":1588215023235},{"_id":"themes/hexo-theme-icarus/include/style/article.styl","hash":"0e8c3a5cf40875d4f129a4531fd47aa158d4abe7","modified":1588215023235},{"_id":"themes/hexo-theme-icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1588215023235},{"_id":"themes/hexo-theme-icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1588215023235},{"_id":"themes/hexo-theme-icarus/include/style/codeblock.styl","hash":"44060ec764f12806bb67a6ae450e991c46adf7d0","modified":1588215023236},{"_id":"themes/hexo-theme-icarus/include/style/donate.styl","hash":"acf06ddda9ae3f671f6237fbd059360f631a3ef7","modified":1588215023236},{"_id":"themes/hexo-theme-icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1588215023236},{"_id":"themes/hexo-theme-icarus/include/style/helper.styl","hash":"f6fe487415914dc6eb1ce10f53b1ab64eeba07ed","modified":1588215023236},{"_id":"themes/hexo-theme-icarus/include/style/navbar.styl","hash":"ecc73c8ad504c0fa4bb910eb51500c14e0a8d662","modified":1588215023236},{"_id":"themes/hexo-theme-icarus/include/style/pagination.styl","hash":"748c4fa46a6e2ec73bda213bb966bb2ee840c095","modified":1588215023237},{"_id":"themes/hexo-theme-icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1588215023237},{"_id":"themes/hexo-theme-icarus/include/style/plugin.styl","hash":"8c665dad9ad7ecd64a5f969eba244a73c66a03a9","modified":1588215023237},{"_id":"themes/hexo-theme-icarus/include/style/search.styl","hash":"a8876f24d33075e52565ab070f61e453a358d5df","modified":1588215023238},{"_id":"themes/hexo-theme-icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1588215023238},{"_id":"themes/hexo-theme-icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1588215023239},{"_id":"themes/hexo-theme-icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":1588215023243},{"_id":"themes/hexo-theme-icarus/layout/common/article.jsx","hash":"f858a8ef0116ec1dc8716a1f1dd16b307cbaa95e","modified":1588215023243},{"_id":"themes/hexo-theme-icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":1588215023244},{"_id":"themes/hexo-theme-icarus/layout/common/footer.jsx","hash":"7fa8f51251fe0563ef32e2a71d449b64d458b0da","modified":1588217193867},{"_id":"themes/hexo-theme-icarus/layout/common/head.jsx","hash":"64b5c10c1d93bbf0659a04d78a4ecd8b2672c406","modified":1588215023244},{"_id":"themes/hexo-theme-icarus/layout/common/navbar.jsx","hash":"ada3968a846a3878009f1b5683346de09509297a","modified":1588215023244},{"_id":"themes/hexo-theme-icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":1588215023245},{"_id":"themes/hexo-theme-icarus/layout/common/scripts.jsx","hash":"677857a166ad8fd1fec74d869a056348bf2d6800","modified":1588215023245},{"_id":"themes/hexo-theme-icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":1588215023245},{"_id":"themes/hexo-theme-icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":1588215023245},{"_id":"themes/hexo-theme-icarus/layout/common/widgets.jsx","hash":"689cf4a6b79337b11d1d56afa9dda09223a809a1","modified":1588215023245},{"_id":"themes/hexo-theme-icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1588215023247},{"_id":"themes/hexo-theme-icarus/layout/plugin/back_to_top.jsx","hash":"54d5a7606e80f76f7492a690eb65d5b5e03b615a","modified":1588215023247},{"_id":"themes/hexo-theme-icarus/layout/widget/profile.jsx","hash":"ba594611e8227975e3f2ce0d24a7856ab9427bd8","modified":1588215023248},{"_id":"themes/hexo-theme-icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1588215023249},{"_id":"themes/hexo-theme-icarus/source/css/cyberpunk.styl","hash":"4f67ae0b413c1b0286452d607ca646c4fe717f62","modified":1588215023249},{"_id":"themes/hexo-theme-icarus/source/css/style.styl","hash":"be5d28ba5098e36483d21f94e4deb0bd2ec075e4","modified":1588215023249},{"_id":"themes/hexo-theme-icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1588215023250},{"_id":"themes/hexo-theme-icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1588215023250},{"_id":"themes/hexo-theme-icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1588215023250},{"_id":"themes/hexo-theme-icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1588215023251},{"_id":"themes/hexo-theme-icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1588215023251},{"_id":"themes/hexo-theme-icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1588215023251},{"_id":"themes/hexo-theme-icarus/source/img/thumbnail.svg","hash":"b9c58ff09ed415e6cf08b42b35faa2bc000d5059","modified":1588215023251},{"_id":"themes/hexo-theme-icarus/source/js/.eslintrc.json","hash":"6bf0641cb69dffac97f69baea192d7fa3ab612cb","modified":1588215023252},{"_id":"themes/hexo-theme-icarus/source/js/animation.js","hash":"59a05568fd5718513792b0d48bcb4bcf7eaa20e8","modified":1588215023252},{"_id":"themes/hexo-theme-icarus/source/js/main.js","hash":"3fb6be34945798cd400825e021c4267856fff2df","modified":1588215023252},{"_id":"themes/hexo-theme-icarus/source/js/back_to_top.js","hash":"0f071e2331e39043529041322c4812bb13a3990d","modified":1588215023252},{"_id":"themes/hexo-theme-icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588215023229},{"_id":"themes/hexo-theme-icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588215023233},{"_id":"themes/hexo-theme-icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588215023234},{"_id":"themes/hexo-theme-icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588215023234},{"_id":"themes/hexo-theme-icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588215023234},{"_id":"themes/hexo-theme-icarus/include/hexo/generator/category.js","hash":"d7e7779d5afd8d4e2b0cf9a15feed84c0ea42590","modified":1588215023228},{"_id":"themes/hexo-theme-icarus/include/hexo/generator/insight.js","hash":"0af168e624af01c930b4c3aaecc3af2e2dc18871","modified":1588215023228},{"_id":"themes/hexo-theme-icarus/include/schema/common/article.json","hash":"37704130789d44c313e03c9dacb809a57274c06f","modified":1588215023229},{"_id":"themes/hexo-theme-icarus/include/schema/common/comment.json","hash":"bd30bd9ffc84e88e704384acdfcaab09019a744f","modified":1588215023230},{"_id":"themes/hexo-theme-icarus/include/schema/common/donates.json","hash":"e6b655f5f4af8958efd23137e96de35426e01a77","modified":1588215023230},{"_id":"themes/hexo-theme-icarus/include/schema/common/footer.json","hash":"09d706cbb94d6da9a0d15c719ce7139325cae1c7","modified":1588215023230},{"_id":"themes/hexo-theme-icarus/include/schema/common/head.json","hash":"49a2a8c0508bad9446868c3c05e7fa3250855af8","modified":1588215023230},{"_id":"themes/hexo-theme-icarus/include/schema/common/navbar.json","hash":"df708bc8a25d4eeec268969f014ad99f9e74ef7a","modified":1588215023230},{"_id":"themes/hexo-theme-icarus/include/schema/common/plugins.json","hash":"0217f2af8a4d6731652a3a49b5801bbfe0e73fff","modified":1588215023230},{"_id":"themes/hexo-theme-icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1588215023231},{"_id":"themes/hexo-theme-icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1588215023231},{"_id":"themes/hexo-theme-icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1588215023232},{"_id":"themes/hexo-theme-icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1588215023233},{"_id":"themes/hexo-theme-icarus/include/schema/common/widgets.json","hash":"d000b4d1d09bdd64756265aa4cd2ea980ab7ddc7","modified":1588215023233},{"_id":"themes/hexo-theme-icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1588215023234},{"_id":"themes/hexo-theme-icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1588215023234},{"_id":"themes/hexo-theme-icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":1588215023235}],"Category":[{"name":"Code","_id":"ck9m4gt7z000gupqe7qmuj82i"}],"Data":[],"Page":[{"title":"About","type":"about","date":"2019-05-11T16:27:36.000Z","_content":"<br><br>\n一名刚刚入门IT行业的JAVA开发，这是我的博客(`主要记录一些日常的积累和经验总结`)\n\n\n\n\n\n","source":"about/index.md","raw":"---\ntitle: About\ntype: \"about\"\ndate: 2019-05-12 00:27:36\n---\n<br><br>\n一名刚刚入门IT行业的JAVA开发，这是我的博客(`主要记录一些日常的积累和经验总结`)\n\n\n\n\n\n","updated":"2019-12-30T06:40:13.315Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck9m4gt7l0001upqejiiw6lit","content":"<p><br><br><br>一名刚刚入门IT行业的JAVA开发，这是我的博客(<code>主要记录一些日常的积累和经验总结</code>)</p>\n","site":{"data":{}},"excerpt":"","more":"<p><br><br><br>一名刚刚入门IT行业的JAVA开发，这是我的博客(<code>主要记录一些日常的积累和经验总结</code>)</p>\n"}],"Post":[{"title":"FastJson笔记","date":"2019-05-28T08:20:19.000Z","_content":"## Maven依赖引入\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>fastjson</artifactId>\n        <version>x.x.x</version>\n    </dependency>\n\n\n## 注解使用\n### JSONField使用\n\n    @JSONField(name=\"AGE\", serialize=false)\n    private int age;\n    \n    @JSONField(name=\"LAST NAME\", ordinal = 2)\n    private String lastName;\n    \n    @JSONField(name=\"FIRST NAME\", ordinal = 1)\n    private String firstName;\n    \n    @JSONField(name=\"DATE OF BIRTH\", format=\"dd/MM/yyyy\", ordinal = 3)\n    private Date dateOfBirth;\n\n1. name:jsonKey重命名\n2. serialize:不进行序列化，也就是不在json返回值中进行输出\n3. ordinal:指定了输出顺序\n4. format:格式化date属性\n\n## 输出\n### JAVA转JSON对象\n\n    String jsonOutput= JSON.toJSONString(listOfPersons);\n\n### BeanToArray\n对bean进行排序\n\n    String jsonOutput= JSON.toJSONString(listOfPersons,SerializerFeature.BeanToArray);\n\n### 创建JSON对象\nnew一个JSONObject或者JSONArray就可以\n\n### JSON转JAVA对象\n\n    Person newPerson = JSON.parseObject(jsonObject, Person.class);\n\n    备注：若bean中指定字段中有 `@JSONField(name = \"DATE OF BIRTH\", deserialize=false)` deserialize则不会被反序列化\n\n### 使用ContextValueFilter作Value过滤\n\n    @Test\n    public void givenContextFilter_whenJavaObject_thanJsonCorrect() {\n        ContextValueFilter valueFilter = new ContextValueFilter () {\n            public Object process(\n            BeanContext context, Object object, String name, Object value) {\n                if (name.equals(\"DATE OF BIRTH\")) {\n                    return \"NOT TO DISCLOSE\";\n                }\n                if (value.equals(\"John\")) {\n                    return ((String) value).toUpperCase();\n                } else {\n                    return null;\n                }\n            }\n        };\n        String jsonOutput = JSON.toJSONString(listOfPersons, valueFilter);\n    }","source":"_posts/FastJson笔记.md","raw":"---\ntitle: FastJson笔记\ndate: 2019-05-28 16:20:19\ntags:\n- JSON\n- SpringBoot\n---\n## Maven依赖引入\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>fastjson</artifactId>\n        <version>x.x.x</version>\n    </dependency>\n\n\n## 注解使用\n### JSONField使用\n\n    @JSONField(name=\"AGE\", serialize=false)\n    private int age;\n    \n    @JSONField(name=\"LAST NAME\", ordinal = 2)\n    private String lastName;\n    \n    @JSONField(name=\"FIRST NAME\", ordinal = 1)\n    private String firstName;\n    \n    @JSONField(name=\"DATE OF BIRTH\", format=\"dd/MM/yyyy\", ordinal = 3)\n    private Date dateOfBirth;\n\n1. name:jsonKey重命名\n2. serialize:不进行序列化，也就是不在json返回值中进行输出\n3. ordinal:指定了输出顺序\n4. format:格式化date属性\n\n## 输出\n### JAVA转JSON对象\n\n    String jsonOutput= JSON.toJSONString(listOfPersons);\n\n### BeanToArray\n对bean进行排序\n\n    String jsonOutput= JSON.toJSONString(listOfPersons,SerializerFeature.BeanToArray);\n\n### 创建JSON对象\nnew一个JSONObject或者JSONArray就可以\n\n### JSON转JAVA对象\n\n    Person newPerson = JSON.parseObject(jsonObject, Person.class);\n\n    备注：若bean中指定字段中有 `@JSONField(name = \"DATE OF BIRTH\", deserialize=false)` deserialize则不会被反序列化\n\n### 使用ContextValueFilter作Value过滤\n\n    @Test\n    public void givenContextFilter_whenJavaObject_thanJsonCorrect() {\n        ContextValueFilter valueFilter = new ContextValueFilter () {\n            public Object process(\n            BeanContext context, Object object, String name, Object value) {\n                if (name.equals(\"DATE OF BIRTH\")) {\n                    return \"NOT TO DISCLOSE\";\n                }\n                if (value.equals(\"John\")) {\n                    return ((String) value).toUpperCase();\n                } else {\n                    return null;\n                }\n            }\n        };\n        String jsonOutput = JSON.toJSONString(listOfPersons, valueFilter);\n    }","slug":"FastJson笔记","published":1,"updated":"2019-12-30T06:40:13.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9m4gt7e0000upqe6lj6aplf","content":"<h2 id=\"Maven依赖引入\"><a href=\"#Maven依赖引入\" class=\"headerlink\" title=\"Maven依赖引入\"></a>Maven依赖引入</h2><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n    &lt;version&gt;x.x.x&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><h2 id=\"注解使用\"><a href=\"#注解使用\" class=\"headerlink\" title=\"注解使用\"></a>注解使用</h2><h3 id=\"JSONField使用\"><a href=\"#JSONField使用\" class=\"headerlink\" title=\"JSONField使用\"></a>JSONField使用</h3><pre><code>@JSONField(name=&quot;AGE&quot;, serialize=false)\nprivate int age;\n\n@JSONField(name=&quot;LAST NAME&quot;, ordinal = 2)\nprivate String lastName;\n\n@JSONField(name=&quot;FIRST NAME&quot;, ordinal = 1)\nprivate String firstName;\n\n@JSONField(name=&quot;DATE OF BIRTH&quot;, format=&quot;dd/MM/yyyy&quot;, ordinal = 3)\nprivate Date dateOfBirth;\n</code></pre><ol>\n<li>name:jsonKey重命名</li>\n<li>serialize:不进行序列化，也就是不在json返回值中进行输出</li>\n<li>ordinal:指定了输出顺序</li>\n<li>format:格式化date属性</li>\n</ol>\n<h2 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h2><h3 id=\"JAVA转JSON对象\"><a href=\"#JAVA转JSON对象\" class=\"headerlink\" title=\"JAVA转JSON对象\"></a>JAVA转JSON对象</h3><pre><code>String jsonOutput= JSON.toJSONString(listOfPersons);\n</code></pre><h3 id=\"BeanToArray\"><a href=\"#BeanToArray\" class=\"headerlink\" title=\"BeanToArray\"></a>BeanToArray</h3><p>对bean进行排序</p>\n<pre><code>String jsonOutput= JSON.toJSONString(listOfPersons,SerializerFeature.BeanToArray);\n</code></pre><h3 id=\"创建JSON对象\"><a href=\"#创建JSON对象\" class=\"headerlink\" title=\"创建JSON对象\"></a>创建JSON对象</h3><p>new一个JSONObject或者JSONArray就可以</p>\n<h3 id=\"JSON转JAVA对象\"><a href=\"#JSON转JAVA对象\" class=\"headerlink\" title=\"JSON转JAVA对象\"></a>JSON转JAVA对象</h3><pre><code>Person newPerson = JSON.parseObject(jsonObject, Person.class);\n\n备注：若bean中指定字段中有 `@JSONField(name = &quot;DATE OF BIRTH&quot;, deserialize=false)` deserialize则不会被反序列化\n</code></pre><h3 id=\"使用ContextValueFilter作Value过滤\"><a href=\"#使用ContextValueFilter作Value过滤\" class=\"headerlink\" title=\"使用ContextValueFilter作Value过滤\"></a>使用ContextValueFilter作Value过滤</h3><pre><code>@Test\npublic void givenContextFilter_whenJavaObject_thanJsonCorrect() {\n    ContextValueFilter valueFilter = new ContextValueFilter () {\n        public Object process(\n        BeanContext context, Object object, String name, Object value) {\n            if (name.equals(&quot;DATE OF BIRTH&quot;)) {\n                return &quot;NOT TO DISCLOSE&quot;;\n            }\n            if (value.equals(&quot;John&quot;)) {\n                return ((String) value).toUpperCase();\n            } else {\n                return null;\n            }\n        }\n    };\n    String jsonOutput = JSON.toJSONString(listOfPersons, valueFilter);\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Maven依赖引入\"><a href=\"#Maven依赖引入\" class=\"headerlink\" title=\"Maven依赖引入\"></a>Maven依赖引入</h2><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n    &lt;version&gt;x.x.x&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><h2 id=\"注解使用\"><a href=\"#注解使用\" class=\"headerlink\" title=\"注解使用\"></a>注解使用</h2><h3 id=\"JSONField使用\"><a href=\"#JSONField使用\" class=\"headerlink\" title=\"JSONField使用\"></a>JSONField使用</h3><pre><code>@JSONField(name=&quot;AGE&quot;, serialize=false)\nprivate int age;\n\n@JSONField(name=&quot;LAST NAME&quot;, ordinal = 2)\nprivate String lastName;\n\n@JSONField(name=&quot;FIRST NAME&quot;, ordinal = 1)\nprivate String firstName;\n\n@JSONField(name=&quot;DATE OF BIRTH&quot;, format=&quot;dd/MM/yyyy&quot;, ordinal = 3)\nprivate Date dateOfBirth;\n</code></pre><ol>\n<li>name:jsonKey重命名</li>\n<li>serialize:不进行序列化，也就是不在json返回值中进行输出</li>\n<li>ordinal:指定了输出顺序</li>\n<li>format:格式化date属性</li>\n</ol>\n<h2 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h2><h3 id=\"JAVA转JSON对象\"><a href=\"#JAVA转JSON对象\" class=\"headerlink\" title=\"JAVA转JSON对象\"></a>JAVA转JSON对象</h3><pre><code>String jsonOutput= JSON.toJSONString(listOfPersons);\n</code></pre><h3 id=\"BeanToArray\"><a href=\"#BeanToArray\" class=\"headerlink\" title=\"BeanToArray\"></a>BeanToArray</h3><p>对bean进行排序</p>\n<pre><code>String jsonOutput= JSON.toJSONString(listOfPersons,SerializerFeature.BeanToArray);\n</code></pre><h3 id=\"创建JSON对象\"><a href=\"#创建JSON对象\" class=\"headerlink\" title=\"创建JSON对象\"></a>创建JSON对象</h3><p>new一个JSONObject或者JSONArray就可以</p>\n<h3 id=\"JSON转JAVA对象\"><a href=\"#JSON转JAVA对象\" class=\"headerlink\" title=\"JSON转JAVA对象\"></a>JSON转JAVA对象</h3><pre><code>Person newPerson = JSON.parseObject(jsonObject, Person.class);\n\n备注：若bean中指定字段中有 `@JSONField(name = &quot;DATE OF BIRTH&quot;, deserialize=false)` deserialize则不会被反序列化\n</code></pre><h3 id=\"使用ContextValueFilter作Value过滤\"><a href=\"#使用ContextValueFilter作Value过滤\" class=\"headerlink\" title=\"使用ContextValueFilter作Value过滤\"></a>使用ContextValueFilter作Value过滤</h3><pre><code>@Test\npublic void givenContextFilter_whenJavaObject_thanJsonCorrect() {\n    ContextValueFilter valueFilter = new ContextValueFilter () {\n        public Object process(\n        BeanContext context, Object object, String name, Object value) {\n            if (name.equals(&quot;DATE OF BIRTH&quot;)) {\n                return &quot;NOT TO DISCLOSE&quot;;\n            }\n            if (value.equals(&quot;John&quot;)) {\n                return ((String) value).toUpperCase();\n            } else {\n                return null;\n            }\n        }\n    };\n    String jsonOutput = JSON.toJSONString(listOfPersons, valueFilter);\n}\n</code></pre>"},{"title":"JVM垃圾回收笔记","date":"2019-06-12T14:26:32.000Z","_content":"阅读了JVM虚拟机前几章，对于垃圾回收机制做了一个精简的笔记。对于后面的二进制字节码分析好难，真心看不懂了...😢\n<!--more-->\n# JVM垃圾回收\n\n## 判断对象已死亡\n\n1. 对象无效\n   - 引用计数法\n   - 可达性分析\n2. 引用\n   - 强引用\n   - 软引用\n   - 弱引用\n   - 虚引用\n3. 是否经历两次标记\n4. 判断常量是废弃常量\n5. 判断是否为无用类\n\n## 判断常量是否废弃\n\n没有String对象引用\n\n## 判断类为无用类\n\n- 该类所有实例被回收\n- 加载该类的ClassLoader已被回收\n- java.lang.Class对象没有地方被引用\n\n## 垃圾收集算法\n\n### 标记清除算法\n\n- 标记出需要回收的对象，然后统一回收\n- 效率高，但是会产生不连续的碎片\n\n### 复制算法\n\n- 内存等分两块，使用其中一块，等内存快用完时将还存活的对象复制到另半边，然后将死亡的对象回收\n- 内存使用率低\n\n### 标记整理算法\n\n- 适用老年代的特点，立一个边界，将存活的对象向一边移动，清理边界以外的内存\n\n### 分代收集算法\n\n- 根据对象存活周期分为老年代和新生代，根据各个年代采用合适的算法\n- 例如：新生代每次收集都会有大量对象死亡，使用复制整理算法；老年代使用标记整理算法或者标记清除算法\n\n## 收集器\n\n### Serial收集器\n\n- 单线程收集器，工作时需要“Stop The World”\n- 新生代使用复制算法；老年代使用标记-整理算法\n- 没有线程交互的开销，简单高效（相比去其他收集器的单线程比较）\n- 适合Client模式下的虚拟机\n\n### ParNew收集器\n\n- Serial的多线程版本（多线程并发）\n- 单核cpu用户需要STW；多核的垃圾收集器运行在一个CPU上面，不一定需要STW\n- 新生代使用复制算法；老年代使用标记-整理算法\n- 适合Server模式下的虚拟机\n\n### Parallel Scavenge收集器\n\n- 类似于ParNew，关注点为吞吐量\n\n### Serial Old收集器\n\n- Serial的老年代版本\n- JDK1.5以及之前版本与Parallel Scavenge收集器配合使用，或者作为CMS的后备版本\n\n### Parallel Old收集器\n\n- Parallel的老年版本\n- 注重吞吐量和CPU资源的场合，优先考虑Parallel Scavenge和Parallel Old配合使用\n\n### CMS收集器\n\n以获取最短回收停顿时间为目的，注重用户体验，实现垃圾收集线程与用户线程同时工作\n- 标记清除算法：\n    - **初始标记：** 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；\n    - **并发标记：** 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\n    - **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短\n    - **并发清除：** 开启用户线程，同时GC线程开始对为标记的区域做清扫。\n\n- 优点：并发收集，低停顿\n- 缺点：对CPU资源敏感，无法处理浮动垃圾，有大量空间碎片\n\n### G1收集器\n\n- 面向服务器的垃圾收集器：\n    - **并行与并发**：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。\n    - **分代收集**：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。\n    - **空间整合**：与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。\n    - **可预测的停顿**：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。\n        - **初始标记**\n        - **并发标记**\n        - **最终标记**\n        - **筛选回收**\n\n- 维护优先列表，根据允许的收集时间选择回收价值最大的Region进行回收\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/JVM垃圾回收笔记.md","raw":"---\ntitle: JVM垃圾回收笔记\ndate: 2019-06-12 22:26:32\ntags:\n- JVM\n- JAVA\n- 后端\n---\n阅读了JVM虚拟机前几章，对于垃圾回收机制做了一个精简的笔记。对于后面的二进制字节码分析好难，真心看不懂了...😢\n<!--more-->\n# JVM垃圾回收\n\n## 判断对象已死亡\n\n1. 对象无效\n   - 引用计数法\n   - 可达性分析\n2. 引用\n   - 强引用\n   - 软引用\n   - 弱引用\n   - 虚引用\n3. 是否经历两次标记\n4. 判断常量是废弃常量\n5. 判断是否为无用类\n\n## 判断常量是否废弃\n\n没有String对象引用\n\n## 判断类为无用类\n\n- 该类所有实例被回收\n- 加载该类的ClassLoader已被回收\n- java.lang.Class对象没有地方被引用\n\n## 垃圾收集算法\n\n### 标记清除算法\n\n- 标记出需要回收的对象，然后统一回收\n- 效率高，但是会产生不连续的碎片\n\n### 复制算法\n\n- 内存等分两块，使用其中一块，等内存快用完时将还存活的对象复制到另半边，然后将死亡的对象回收\n- 内存使用率低\n\n### 标记整理算法\n\n- 适用老年代的特点，立一个边界，将存活的对象向一边移动，清理边界以外的内存\n\n### 分代收集算法\n\n- 根据对象存活周期分为老年代和新生代，根据各个年代采用合适的算法\n- 例如：新生代每次收集都会有大量对象死亡，使用复制整理算法；老年代使用标记整理算法或者标记清除算法\n\n## 收集器\n\n### Serial收集器\n\n- 单线程收集器，工作时需要“Stop The World”\n- 新生代使用复制算法；老年代使用标记-整理算法\n- 没有线程交互的开销，简单高效（相比去其他收集器的单线程比较）\n- 适合Client模式下的虚拟机\n\n### ParNew收集器\n\n- Serial的多线程版本（多线程并发）\n- 单核cpu用户需要STW；多核的垃圾收集器运行在一个CPU上面，不一定需要STW\n- 新生代使用复制算法；老年代使用标记-整理算法\n- 适合Server模式下的虚拟机\n\n### Parallel Scavenge收集器\n\n- 类似于ParNew，关注点为吞吐量\n\n### Serial Old收集器\n\n- Serial的老年代版本\n- JDK1.5以及之前版本与Parallel Scavenge收集器配合使用，或者作为CMS的后备版本\n\n### Parallel Old收集器\n\n- Parallel的老年版本\n- 注重吞吐量和CPU资源的场合，优先考虑Parallel Scavenge和Parallel Old配合使用\n\n### CMS收集器\n\n以获取最短回收停顿时间为目的，注重用户体验，实现垃圾收集线程与用户线程同时工作\n- 标记清除算法：\n    - **初始标记：** 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；\n    - **并发标记：** 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\n    - **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短\n    - **并发清除：** 开启用户线程，同时GC线程开始对为标记的区域做清扫。\n\n- 优点：并发收集，低停顿\n- 缺点：对CPU资源敏感，无法处理浮动垃圾，有大量空间碎片\n\n### G1收集器\n\n- 面向服务器的垃圾收集器：\n    - **并行与并发**：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。\n    - **分代收集**：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。\n    - **空间整合**：与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。\n    - **可预测的停顿**：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。\n        - **初始标记**\n        - **并发标记**\n        - **最终标记**\n        - **筛选回收**\n\n- 维护优先列表，根据允许的收集时间选择回收价值最大的Region进行回收\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"JVM垃圾回收笔记","published":1,"updated":"2019-12-30T06:40:13.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9m4gt7m0002upqe9jxy04ln","content":"<p>阅读了JVM虚拟机前几章，对于垃圾回收机制做了一个精简的笔记。对于后面的二进制字节码分析好难，真心看不懂了…😢<br><a id=\"more\"></a></p>\n<h1 id=\"JVM垃圾回收\"><a href=\"#JVM垃圾回收\" class=\"headerlink\" title=\"JVM垃圾回收\"></a>JVM垃圾回收</h1><h2 id=\"判断对象已死亡\"><a href=\"#判断对象已死亡\" class=\"headerlink\" title=\"判断对象已死亡\"></a>判断对象已死亡</h2><ol>\n<li>对象无效<ul>\n<li>引用计数法</li>\n<li>可达性分析</li>\n</ul>\n</li>\n<li>引用<ul>\n<li>强引用</li>\n<li>软引用</li>\n<li>弱引用</li>\n<li>虚引用</li>\n</ul>\n</li>\n<li>是否经历两次标记</li>\n<li>判断常量是废弃常量</li>\n<li>判断是否为无用类</li>\n</ol>\n<h2 id=\"判断常量是否废弃\"><a href=\"#判断常量是否废弃\" class=\"headerlink\" title=\"判断常量是否废弃\"></a>判断常量是否废弃</h2><p>没有String对象引用</p>\n<h2 id=\"判断类为无用类\"><a href=\"#判断类为无用类\" class=\"headerlink\" title=\"判断类为无用类\"></a>判断类为无用类</h2><ul>\n<li>该类所有实例被回收</li>\n<li>加载该类的ClassLoader已被回收</li>\n<li>java.lang.Class对象没有地方被引用</li>\n</ul>\n<h2 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h2><h3 id=\"标记清除算法\"><a href=\"#标记清除算法\" class=\"headerlink\" title=\"标记清除算法\"></a>标记清除算法</h3><ul>\n<li>标记出需要回收的对象，然后统一回收</li>\n<li>效率高，但是会产生不连续的碎片</li>\n</ul>\n<h3 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h3><ul>\n<li>内存等分两块，使用其中一块，等内存快用完时将还存活的对象复制到另半边，然后将死亡的对象回收</li>\n<li>内存使用率低</li>\n</ul>\n<h3 id=\"标记整理算法\"><a href=\"#标记整理算法\" class=\"headerlink\" title=\"标记整理算法\"></a>标记整理算法</h3><ul>\n<li>适用老年代的特点，立一个边界，将存活的对象向一边移动，清理边界以外的内存</li>\n</ul>\n<h3 id=\"分代收集算法\"><a href=\"#分代收集算法\" class=\"headerlink\" title=\"分代收集算法\"></a>分代收集算法</h3><ul>\n<li>根据对象存活周期分为老年代和新生代，根据各个年代采用合适的算法</li>\n<li>例如：新生代每次收集都会有大量对象死亡，使用复制整理算法；老年代使用标记整理算法或者标记清除算法</li>\n</ul>\n<h2 id=\"收集器\"><a href=\"#收集器\" class=\"headerlink\" title=\"收集器\"></a>收集器</h2><h3 id=\"Serial收集器\"><a href=\"#Serial收集器\" class=\"headerlink\" title=\"Serial收集器\"></a>Serial收集器</h3><ul>\n<li>单线程收集器，工作时需要“Stop The World”</li>\n<li>新生代使用复制算法；老年代使用标记-整理算法</li>\n<li>没有线程交互的开销，简单高效（相比去其他收集器的单线程比较）</li>\n<li>适合Client模式下的虚拟机</li>\n</ul>\n<h3 id=\"ParNew收集器\"><a href=\"#ParNew收集器\" class=\"headerlink\" title=\"ParNew收集器\"></a>ParNew收集器</h3><ul>\n<li>Serial的多线程版本（多线程并发）</li>\n<li>单核cpu用户需要STW；多核的垃圾收集器运行在一个CPU上面，不一定需要STW</li>\n<li>新生代使用复制算法；老年代使用标记-整理算法</li>\n<li>适合Server模式下的虚拟机</li>\n</ul>\n<h3 id=\"Parallel-Scavenge收集器\"><a href=\"#Parallel-Scavenge收集器\" class=\"headerlink\" title=\"Parallel Scavenge收集器\"></a>Parallel Scavenge收集器</h3><ul>\n<li>类似于ParNew，关注点为吞吐量</li>\n</ul>\n<h3 id=\"Serial-Old收集器\"><a href=\"#Serial-Old收集器\" class=\"headerlink\" title=\"Serial Old收集器\"></a>Serial Old收集器</h3><ul>\n<li>Serial的老年代版本</li>\n<li>JDK1.5以及之前版本与Parallel Scavenge收集器配合使用，或者作为CMS的后备版本</li>\n</ul>\n<h3 id=\"Parallel-Old收集器\"><a href=\"#Parallel-Old收集器\" class=\"headerlink\" title=\"Parallel Old收集器\"></a>Parallel Old收集器</h3><ul>\n<li>Parallel的老年版本</li>\n<li>注重吞吐量和CPU资源的场合，优先考虑Parallel Scavenge和Parallel Old配合使用</li>\n</ul>\n<h3 id=\"CMS收集器\"><a href=\"#CMS收集器\" class=\"headerlink\" title=\"CMS收集器\"></a>CMS收集器</h3><p>以获取最短回收停顿时间为目的，注重用户体验，实现垃圾收集线程与用户线程同时工作</p>\n<ul>\n<li><p>标记清除算法：</p>\n<ul>\n<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；</li>\n<li><strong>并发标记：</strong> 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>\n<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>\n<li><strong>并发清除：</strong> 开启用户线程，同时GC线程开始对为标记的区域做清扫。</li>\n</ul>\n</li>\n<li><p>优点：并发收集，低停顿</p>\n</li>\n<li>缺点：对CPU资源敏感，无法处理浮动垃圾，有大量空间碎片</li>\n</ul>\n<h3 id=\"G1收集器\"><a href=\"#G1收集器\" class=\"headerlink\" title=\"G1收集器\"></a>G1收集器</h3><ul>\n<li><p>面向服务器的垃圾收集器：</p>\n<ul>\n<li><strong>并行与并发</strong>：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li>\n<li><strong>分代收集</strong>：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</li>\n<li><strong>空间整合</strong>：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li>\n<li><strong>可预测的停顿</strong>：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。<ul>\n<li><strong>初始标记</strong></li>\n<li><strong>并发标记</strong></li>\n<li><strong>最终标记</strong></li>\n<li><strong>筛选回收</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>维护优先列表，根据允许的收集时间选择回收价值最大的Region进行回收</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>阅读了JVM虚拟机前几章，对于垃圾回收机制做了一个精简的笔记。对于后面的二进制字节码分析好难，真心看不懂了…😢<br>","more":"</p>\n<h1 id=\"JVM垃圾回收\"><a href=\"#JVM垃圾回收\" class=\"headerlink\" title=\"JVM垃圾回收\"></a>JVM垃圾回收</h1><h2 id=\"判断对象已死亡\"><a href=\"#判断对象已死亡\" class=\"headerlink\" title=\"判断对象已死亡\"></a>判断对象已死亡</h2><ol>\n<li>对象无效<ul>\n<li>引用计数法</li>\n<li>可达性分析</li>\n</ul>\n</li>\n<li>引用<ul>\n<li>强引用</li>\n<li>软引用</li>\n<li>弱引用</li>\n<li>虚引用</li>\n</ul>\n</li>\n<li>是否经历两次标记</li>\n<li>判断常量是废弃常量</li>\n<li>判断是否为无用类</li>\n</ol>\n<h2 id=\"判断常量是否废弃\"><a href=\"#判断常量是否废弃\" class=\"headerlink\" title=\"判断常量是否废弃\"></a>判断常量是否废弃</h2><p>没有String对象引用</p>\n<h2 id=\"判断类为无用类\"><a href=\"#判断类为无用类\" class=\"headerlink\" title=\"判断类为无用类\"></a>判断类为无用类</h2><ul>\n<li>该类所有实例被回收</li>\n<li>加载该类的ClassLoader已被回收</li>\n<li>java.lang.Class对象没有地方被引用</li>\n</ul>\n<h2 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h2><h3 id=\"标记清除算法\"><a href=\"#标记清除算法\" class=\"headerlink\" title=\"标记清除算法\"></a>标记清除算法</h3><ul>\n<li>标记出需要回收的对象，然后统一回收</li>\n<li>效率高，但是会产生不连续的碎片</li>\n</ul>\n<h3 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h3><ul>\n<li>内存等分两块，使用其中一块，等内存快用完时将还存活的对象复制到另半边，然后将死亡的对象回收</li>\n<li>内存使用率低</li>\n</ul>\n<h3 id=\"标记整理算法\"><a href=\"#标记整理算法\" class=\"headerlink\" title=\"标记整理算法\"></a>标记整理算法</h3><ul>\n<li>适用老年代的特点，立一个边界，将存活的对象向一边移动，清理边界以外的内存</li>\n</ul>\n<h3 id=\"分代收集算法\"><a href=\"#分代收集算法\" class=\"headerlink\" title=\"分代收集算法\"></a>分代收集算法</h3><ul>\n<li>根据对象存活周期分为老年代和新生代，根据各个年代采用合适的算法</li>\n<li>例如：新生代每次收集都会有大量对象死亡，使用复制整理算法；老年代使用标记整理算法或者标记清除算法</li>\n</ul>\n<h2 id=\"收集器\"><a href=\"#收集器\" class=\"headerlink\" title=\"收集器\"></a>收集器</h2><h3 id=\"Serial收集器\"><a href=\"#Serial收集器\" class=\"headerlink\" title=\"Serial收集器\"></a>Serial收集器</h3><ul>\n<li>单线程收集器，工作时需要“Stop The World”</li>\n<li>新生代使用复制算法；老年代使用标记-整理算法</li>\n<li>没有线程交互的开销，简单高效（相比去其他收集器的单线程比较）</li>\n<li>适合Client模式下的虚拟机</li>\n</ul>\n<h3 id=\"ParNew收集器\"><a href=\"#ParNew收集器\" class=\"headerlink\" title=\"ParNew收集器\"></a>ParNew收集器</h3><ul>\n<li>Serial的多线程版本（多线程并发）</li>\n<li>单核cpu用户需要STW；多核的垃圾收集器运行在一个CPU上面，不一定需要STW</li>\n<li>新生代使用复制算法；老年代使用标记-整理算法</li>\n<li>适合Server模式下的虚拟机</li>\n</ul>\n<h3 id=\"Parallel-Scavenge收集器\"><a href=\"#Parallel-Scavenge收集器\" class=\"headerlink\" title=\"Parallel Scavenge收集器\"></a>Parallel Scavenge收集器</h3><ul>\n<li>类似于ParNew，关注点为吞吐量</li>\n</ul>\n<h3 id=\"Serial-Old收集器\"><a href=\"#Serial-Old收集器\" class=\"headerlink\" title=\"Serial Old收集器\"></a>Serial Old收集器</h3><ul>\n<li>Serial的老年代版本</li>\n<li>JDK1.5以及之前版本与Parallel Scavenge收集器配合使用，或者作为CMS的后备版本</li>\n</ul>\n<h3 id=\"Parallel-Old收集器\"><a href=\"#Parallel-Old收集器\" class=\"headerlink\" title=\"Parallel Old收集器\"></a>Parallel Old收集器</h3><ul>\n<li>Parallel的老年版本</li>\n<li>注重吞吐量和CPU资源的场合，优先考虑Parallel Scavenge和Parallel Old配合使用</li>\n</ul>\n<h3 id=\"CMS收集器\"><a href=\"#CMS收集器\" class=\"headerlink\" title=\"CMS收集器\"></a>CMS收集器</h3><p>以获取最短回收停顿时间为目的，注重用户体验，实现垃圾收集线程与用户线程同时工作</p>\n<ul>\n<li><p>标记清除算法：</p>\n<ul>\n<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；</li>\n<li><strong>并发标记：</strong> 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>\n<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>\n<li><strong>并发清除：</strong> 开启用户线程，同时GC线程开始对为标记的区域做清扫。</li>\n</ul>\n</li>\n<li><p>优点：并发收集，低停顿</p>\n</li>\n<li>缺点：对CPU资源敏感，无法处理浮动垃圾，有大量空间碎片</li>\n</ul>\n<h3 id=\"G1收集器\"><a href=\"#G1收集器\" class=\"headerlink\" title=\"G1收集器\"></a>G1收集器</h3><ul>\n<li><p>面向服务器的垃圾收集器：</p>\n<ul>\n<li><strong>并行与并发</strong>：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li>\n<li><strong>分代收集</strong>：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</li>\n<li><strong>空间整合</strong>：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li>\n<li><strong>可预测的停顿</strong>：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。<ul>\n<li><strong>初始标记</strong></li>\n<li><strong>并发标记</strong></li>\n<li><strong>最终标记</strong></li>\n<li><strong>筛选回收</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>维护优先列表，根据允许的收集时间选择回收价值最大的Region进行回收</p>\n</li>\n</ul>"},{"title":"SQL笔记","date":"2019-05-29T05:37:48.000Z","_content":"<!--more-->\nGroup by使用场景\n1、当聚集函数和非聚集函数出现在一起时，需要将非聚集函数进行group by\n2、当只做聚集函数查询时候，就不需要进行分组了","source":"_posts/SQL笔记.md","raw":"---\ntitle: SQL笔记\ndate: 2019-05-29 13:37:48\ntags:\n- SQL\n- 数据库\n---\n<!--more-->\nGroup by使用场景\n1、当聚集函数和非聚集函数出现在一起时，需要将非聚集函数进行group by\n2、当只做聚集函数查询时候，就不需要进行分组了","slug":"SQL笔记","published":1,"updated":"2019-12-30T06:40:13.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9m4gt7q0004upqezgjrsfjn","content":"<a id=\"more\"></a>\n<p>Group by使用场景<br>1、当聚集函数和非聚集函数出现在一起时，需要将非聚集函数进行group by<br>2、当只做聚集函数查询时候，就不需要进行分组了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Group by使用场景<br>1、当聚集函数和非聚集函数出现在一起时，需要将非聚集函数进行group by<br>2、当只做聚集函数查询时候，就不需要进行分组了</p>"},{"title":"SecureFX中文乱码","date":"2019-06-29T14:18:20.000Z","_content":"## 解决中文乱码问题\n\n1. `Options->Global Options->General->Default Session`，找到配置目录；\n\n2. 进入该配置目录的Sessions文件夹，修改对应的.ini文件，找到包含：\n\n        D:\"Filenames Always Use UTF8\"=00000000\n\n   的这一行，修改配置文件内容为：\n\n        D:\"Filenames Always Use UTF8\"=00000001 \n\n   即可；\n\n3. 重启SecureFX，再次连接，中文就显示正常了。\n\n","source":"_posts/SecureFX中文乱码.md","raw":"---\ntitle: SecureFX中文乱码\ndate: 2019-06-29 22:18:20\ntags:\n- MAC系统\n- 软件\n---\n## 解决中文乱码问题\n\n1. `Options->Global Options->General->Default Session`，找到配置目录；\n\n2. 进入该配置目录的Sessions文件夹，修改对应的.ini文件，找到包含：\n\n        D:\"Filenames Always Use UTF8\"=00000000\n\n   的这一行，修改配置文件内容为：\n\n        D:\"Filenames Always Use UTF8\"=00000001 \n\n   即可；\n\n3. 重启SecureFX，再次连接，中文就显示正常了。\n\n","slug":"SecureFX中文乱码","published":1,"updated":"2019-12-30T06:40:13.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9m4gt7s0005upqe26c63a1o","content":"<h2 id=\"解决中文乱码问题\"><a href=\"#解决中文乱码问题\" class=\"headerlink\" title=\"解决中文乱码问题\"></a>解决中文乱码问题</h2><ol>\n<li><p><code>Options-&gt;Global Options-&gt;General-&gt;Default Session</code>，找到配置目录；</p>\n</li>\n<li><p>进入该配置目录的Sessions文件夹，修改对应的.ini文件，找到包含：</p>\n<pre><code>D:&quot;Filenames Always Use UTF8&quot;=00000000\n</code></pre><p>的这一行，修改配置文件内容为：</p>\n<pre><code>D:&quot;Filenames Always Use UTF8&quot;=00000001 \n</code></pre><p>即可；</p>\n</li>\n<li><p>重启SecureFX，再次连接，中文就显示正常了。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"解决中文乱码问题\"><a href=\"#解决中文乱码问题\" class=\"headerlink\" title=\"解决中文乱码问题\"></a>解决中文乱码问题</h2><ol>\n<li><p><code>Options-&gt;Global Options-&gt;General-&gt;Default Session</code>，找到配置目录；</p>\n</li>\n<li><p>进入该配置目录的Sessions文件夹，修改对应的.ini文件，找到包含：</p>\n<pre><code>D:&quot;Filenames Always Use UTF8&quot;=00000000\n</code></pre><p>的这一行，修改配置文件内容为：</p>\n<pre><code>D:&quot;Filenames Always Use UTF8&quot;=00000001 \n</code></pre><p>即可；</p>\n</li>\n<li><p>重启SecureFX，再次连接，中文就显示正常了。</p>\n</li>\n</ol>\n"},{"title":"SpringBoot与Vue的整合及部署","date":"2019-05-12T05:06:37.000Z","_content":"\n# SpringBoot与Vue的整合实现前后端分离\n\n## vue项目创建\n\n近期工作的项目中采用了Spring和Vue整合达到前后端完全分离的目的。vue使用了elementUI的UI框架，一边抄官方文档，一边修修改改，很方便上手。\n\n😊这里学习整理一下，准备用到自己的毕业设计里….\n\n###  创建vue项目\n\n\n    vue init webpack \n\n\n\n（`注意的是，谨慎使用eslint这个工具`）\n\n### 引入以及配置依赖包\n\n若使用elementUI组件（需要安装依赖npm install --save element-ui）:\n\n1. 在src文件夹main.js文件中添加依赖以及引用\n\n        /* elementUI组件引用 */\n        import ElementUI from 'element-ui';\n        import '../node_modules/element-ui/lib/theme-chalk/index.css';\n        /* elementUI组件调用 */\n        Vue.use(ElementUI)\n\n\n\n2. 另外还可以加上axios的依赖\n\n        /* axios引用 */\n        import axios from 'axios';\n        /* axios掉用 */\n        Vue.prototype.$axios = axios\n        /* 设置header头，表示请求是ajax请求 */（这一行虽然写了注释，但是不懂，不知道可不可以不写）\n        axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';\n\n\n\n### 编写实例测试\n\n在components中编写实例:\n\n\n    <template>  \n    <div class=\"hello\">  \n        <h1>{{ msg }}</h1>  \n        <h2>Essential Links</h2>  \n        <el-button>默认按钮</el-button>  \n        <el-button type=\"primary\">主要按钮</el-button>  \n        <el-button type=\"text\">文字按钮</el-button>  \n        <div>\n        <el-select v-model=\"value\" placeholder=\"请选择\">\n            <el-option\n            v-for=\"item in options\"\n            :key=\"item.value\"\n            :label=\"item.label\"\n            :value=\"item.value\">\n            </el-option>\n        </el-select>\n        </div>\n    </div>  \n    </template>  \n\n    <script>  \n\n    export default {  \n    name: 'hello',  \n    data () {  \n        return {  \n        msg: '我是第二页',\n        options: [{\n            value: '选项1',\n            label: '黄金糕'\n            }, {\n            value: '选项2',\n            label: '双皮奶'\n            }, {\n            value: '选项3',\n            label: '蚵仔煎'\n            }, {\n            value: '选项4',\n            label: '龙须面'\n            }, {\n            value: '选项5',\n            label: '北京烤鸭'\n            }],\n            value:\"\", \n        }  \n    },\n    created: function(){\n        this.login();\n    },\n    methods: {\n        login(){\n        console.log(\"login\");\n        this.$axios.get(_const.baseUrl + \"/login\")\n        .then(function(res){\n            console.log(res.data);\n        })\n        .catch(function(error){\n            console.log(error);\n        });\n        },\n    }, \n    }  \n    </script>  \n\n\n\n\n\n### 配置全局变量\n\naxios的地址可以在全局变量中定义然后使用，具体操作可以在static文件下新建一个全局变量文件：\n\n\n    const sysConfig = {\n        baseIp: '127.0.0.1',\n        basePort: '8888',\n        protocol: 'http://',\n        baseUrl: 'http://127.0.0.1:8888/blog',\n    }\n    let bindToGlobal = (obj, key) => {\n        if (typeof window[key] === 'undefined') {\n            window[key] = {};\n        }\n\n        for (let i in obj) {\n            window[key][i] = obj[i]\n        }\n    }\n    bindToGlobal(sysConfig,'_const')\n\n\n\n\n\n\n### 附！项目文件结构\n\n![Eh1EHe.png](https://s2.ax1x.com/2019/05/12/Eh1EHe.png)\n\n### 运行启动前端项目\n\n先安装依赖：\n\n    npm install\n\n后运行项目:\n\n    npm run dev\n\n## SpringBoot创建\n\n### 新建springboot项目\n\n用idea新建一个springboot项目，打包形式首先选择成war包（若一开始选择的是jar包，后期通过修改启动类以及pom文件改成war打包形式，具体参见\"springboot项目打包成war记录\"）\n\n### 编写实例测试\n\n写一个controller类作测试:\n\n    package com.csidez.blog.controller;\n\n    import org.springframework.web.bind.annotation.*;\n\n    //允许跨域访问\n    @CrossOrigin\n    @RestController\n    public class testController {\n\n        @GetMapping(value = \"/login\")\n        public String login(){\n            return \"Success\";\n        }\n    }\n\n\n### 运行启动后端项目\n\n## 整合及部署\n\n### 端口问题\n\n因为两个都是跑在8080端口上的，跑了一个另一个会冲突，所以本地测试的时候我修改springboot的tomcat的端口，可以在properties文件中添加`server.port=8888`这一行将端口修改到8888上面了\n\n### 部署问题\n\nwar包是在tomcat的webapps文件下解压开的，jar -xvf *.war所以会生成相应的名字，这样springboot访问时，连接中也需要加上该文件名。\n因此，在设置前端axios的地址中，定义时需要注意url地址。\nvue使用cnpm run build打包生成的dist文件，将dist里的两个文件直接黏贴到解压开的war中，这样出现另一个问题，无法打开vue的页面，需要修改在config文件夹中的index.js文件。将\n\n    assetsPublicPath: '/'\n\n修改为\n\n\n    assetsPublicPath: './'\n\n或者也可以改为\n\n\n    assetsPublicPath: '/war包文件夹名字/',\n\n\n注意需要改两处\n\n### 跨域问题\n\n由于我的部署方式是将vue项目打的包直接丢进springboot的war包解压开的文件夹内，未见此问题。如果报一下错误\n\n    No 'Access-Control-Allow-Origin' header is present on the requested resource.\n\n应该是前面部署整合时候处理URL的问题，没有处理好。\n\n","source":"_posts/SpringBoot与Vue的整合及部署.md","raw":"---\ntitle: SpringBoot与Vue的整合及部署\ndate: 2019-05-12 13:06:37\ntags:\n- SpringBoot\n- Vue\n---\n\n# SpringBoot与Vue的整合实现前后端分离\n\n## vue项目创建\n\n近期工作的项目中采用了Spring和Vue整合达到前后端完全分离的目的。vue使用了elementUI的UI框架，一边抄官方文档，一边修修改改，很方便上手。\n\n😊这里学习整理一下，准备用到自己的毕业设计里….\n\n###  创建vue项目\n\n\n    vue init webpack \n\n\n\n（`注意的是，谨慎使用eslint这个工具`）\n\n### 引入以及配置依赖包\n\n若使用elementUI组件（需要安装依赖npm install --save element-ui）:\n\n1. 在src文件夹main.js文件中添加依赖以及引用\n\n        /* elementUI组件引用 */\n        import ElementUI from 'element-ui';\n        import '../node_modules/element-ui/lib/theme-chalk/index.css';\n        /* elementUI组件调用 */\n        Vue.use(ElementUI)\n\n\n\n2. 另外还可以加上axios的依赖\n\n        /* axios引用 */\n        import axios from 'axios';\n        /* axios掉用 */\n        Vue.prototype.$axios = axios\n        /* 设置header头，表示请求是ajax请求 */（这一行虽然写了注释，但是不懂，不知道可不可以不写）\n        axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';\n\n\n\n### 编写实例测试\n\n在components中编写实例:\n\n\n    <template>  \n    <div class=\"hello\">  \n        <h1>{{ msg }}</h1>  \n        <h2>Essential Links</h2>  \n        <el-button>默认按钮</el-button>  \n        <el-button type=\"primary\">主要按钮</el-button>  \n        <el-button type=\"text\">文字按钮</el-button>  \n        <div>\n        <el-select v-model=\"value\" placeholder=\"请选择\">\n            <el-option\n            v-for=\"item in options\"\n            :key=\"item.value\"\n            :label=\"item.label\"\n            :value=\"item.value\">\n            </el-option>\n        </el-select>\n        </div>\n    </div>  \n    </template>  \n\n    <script>  \n\n    export default {  \n    name: 'hello',  \n    data () {  \n        return {  \n        msg: '我是第二页',\n        options: [{\n            value: '选项1',\n            label: '黄金糕'\n            }, {\n            value: '选项2',\n            label: '双皮奶'\n            }, {\n            value: '选项3',\n            label: '蚵仔煎'\n            }, {\n            value: '选项4',\n            label: '龙须面'\n            }, {\n            value: '选项5',\n            label: '北京烤鸭'\n            }],\n            value:\"\", \n        }  \n    },\n    created: function(){\n        this.login();\n    },\n    methods: {\n        login(){\n        console.log(\"login\");\n        this.$axios.get(_const.baseUrl + \"/login\")\n        .then(function(res){\n            console.log(res.data);\n        })\n        .catch(function(error){\n            console.log(error);\n        });\n        },\n    }, \n    }  \n    </script>  \n\n\n\n\n\n### 配置全局变量\n\naxios的地址可以在全局变量中定义然后使用，具体操作可以在static文件下新建一个全局变量文件：\n\n\n    const sysConfig = {\n        baseIp: '127.0.0.1',\n        basePort: '8888',\n        protocol: 'http://',\n        baseUrl: 'http://127.0.0.1:8888/blog',\n    }\n    let bindToGlobal = (obj, key) => {\n        if (typeof window[key] === 'undefined') {\n            window[key] = {};\n        }\n\n        for (let i in obj) {\n            window[key][i] = obj[i]\n        }\n    }\n    bindToGlobal(sysConfig,'_const')\n\n\n\n\n\n\n### 附！项目文件结构\n\n![Eh1EHe.png](https://s2.ax1x.com/2019/05/12/Eh1EHe.png)\n\n### 运行启动前端项目\n\n先安装依赖：\n\n    npm install\n\n后运行项目:\n\n    npm run dev\n\n## SpringBoot创建\n\n### 新建springboot项目\n\n用idea新建一个springboot项目，打包形式首先选择成war包（若一开始选择的是jar包，后期通过修改启动类以及pom文件改成war打包形式，具体参见\"springboot项目打包成war记录\"）\n\n### 编写实例测试\n\n写一个controller类作测试:\n\n    package com.csidez.blog.controller;\n\n    import org.springframework.web.bind.annotation.*;\n\n    //允许跨域访问\n    @CrossOrigin\n    @RestController\n    public class testController {\n\n        @GetMapping(value = \"/login\")\n        public String login(){\n            return \"Success\";\n        }\n    }\n\n\n### 运行启动后端项目\n\n## 整合及部署\n\n### 端口问题\n\n因为两个都是跑在8080端口上的，跑了一个另一个会冲突，所以本地测试的时候我修改springboot的tomcat的端口，可以在properties文件中添加`server.port=8888`这一行将端口修改到8888上面了\n\n### 部署问题\n\nwar包是在tomcat的webapps文件下解压开的，jar -xvf *.war所以会生成相应的名字，这样springboot访问时，连接中也需要加上该文件名。\n因此，在设置前端axios的地址中，定义时需要注意url地址。\nvue使用cnpm run build打包生成的dist文件，将dist里的两个文件直接黏贴到解压开的war中，这样出现另一个问题，无法打开vue的页面，需要修改在config文件夹中的index.js文件。将\n\n    assetsPublicPath: '/'\n\n修改为\n\n\n    assetsPublicPath: './'\n\n或者也可以改为\n\n\n    assetsPublicPath: '/war包文件夹名字/',\n\n\n注意需要改两处\n\n### 跨域问题\n\n由于我的部署方式是将vue项目打的包直接丢进springboot的war包解压开的文件夹内，未见此问题。如果报一下错误\n\n    No 'Access-Control-Allow-Origin' header is present on the requested resource.\n\n应该是前面部署整合时候处理URL的问题，没有处理好。\n\n","slug":"SpringBoot与Vue的整合及部署","published":1,"updated":"2019-12-30T06:40:13.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9m4gt7t0006upqeyxxmh9y3","content":"<h1 id=\"SpringBoot与Vue的整合实现前后端分离\"><a href=\"#SpringBoot与Vue的整合实现前后端分离\" class=\"headerlink\" title=\"SpringBoot与Vue的整合实现前后端分离\"></a>SpringBoot与Vue的整合实现前后端分离</h1><h2 id=\"vue项目创建\"><a href=\"#vue项目创建\" class=\"headerlink\" title=\"vue项目创建\"></a>vue项目创建</h2><p>近期工作的项目中采用了Spring和Vue整合达到前后端完全分离的目的。vue使用了elementUI的UI框架，一边抄官方文档，一边修修改改，很方便上手。</p>\n<p>😊这里学习整理一下，准备用到自己的毕业设计里….</p>\n<h3 id=\"创建vue项目\"><a href=\"#创建vue项目\" class=\"headerlink\" title=\"创建vue项目\"></a>创建vue项目</h3><pre><code>vue init webpack \n</code></pre><p>（<code>注意的是，谨慎使用eslint这个工具</code>）</p>\n<h3 id=\"引入以及配置依赖包\"><a href=\"#引入以及配置依赖包\" class=\"headerlink\" title=\"引入以及配置依赖包\"></a>引入以及配置依赖包</h3><p>若使用elementUI组件（需要安装依赖npm install –save element-ui）:</p>\n<ol>\n<li><p>在src文件夹main.js文件中添加依赖以及引用</p>\n<pre><code>/* elementUI组件引用 */\nimport ElementUI from &apos;element-ui&apos;;\nimport &apos;../node_modules/element-ui/lib/theme-chalk/index.css&apos;;\n/* elementUI组件调用 */\nVue.use(ElementUI)\n</code></pre></li>\n</ol>\n<ol start=\"2\">\n<li><p>另外还可以加上axios的依赖</p>\n<pre><code>/* axios引用 */\nimport axios from &apos;axios&apos;;\n/* axios掉用 */\nVue.prototype.$axios = axios\n/* 设置header头，表示请求是ajax请求 */（这一行虽然写了注释，但是不懂，不知道可不可以不写）\naxios.defaults.headers.common[&apos;X-Requested-With&apos;] = &apos;XMLHttpRequest&apos;;\n</code></pre></li>\n</ol>\n<h3 id=\"编写实例测试\"><a href=\"#编写实例测试\" class=\"headerlink\" title=\"编写实例测试\"></a>编写实例测试</h3><p>在components中编写实例:</p>\n<pre><code>&lt;template&gt;  \n&lt;div class=&quot;hello&quot;&gt;  \n    &lt;h1&gt;{{ msg }}&lt;/h1&gt;  \n    &lt;h2&gt;Essential Links&lt;/h2&gt;  \n    &lt;el-button&gt;默认按钮&lt;/el-button&gt;  \n    &lt;el-button type=&quot;primary&quot;&gt;主要按钮&lt;/el-button&gt;  \n    &lt;el-button type=&quot;text&quot;&gt;文字按钮&lt;/el-button&gt;  \n    &lt;div&gt;\n    &lt;el-select v-model=&quot;value&quot; placeholder=&quot;请选择&quot;&gt;\n        &lt;el-option\n        v-for=&quot;item in options&quot;\n        :key=&quot;item.value&quot;\n        :label=&quot;item.label&quot;\n        :value=&quot;item.value&quot;&gt;\n        &lt;/el-option&gt;\n    &lt;/el-select&gt;\n    &lt;/div&gt;\n&lt;/div&gt;  \n&lt;/template&gt;  \n\n&lt;script&gt;  \n\nexport default {  \nname: &apos;hello&apos;,  \ndata () {  \n    return {  \n    msg: &apos;我是第二页&apos;,\n    options: [{\n        value: &apos;选项1&apos;,\n        label: &apos;黄金糕&apos;\n        }, {\n        value: &apos;选项2&apos;,\n        label: &apos;双皮奶&apos;\n        }, {\n        value: &apos;选项3&apos;,\n        label: &apos;蚵仔煎&apos;\n        }, {\n        value: &apos;选项4&apos;,\n        label: &apos;龙须面&apos;\n        }, {\n        value: &apos;选项5&apos;,\n        label: &apos;北京烤鸭&apos;\n        }],\n        value:&quot;&quot;, \n    }  \n},\ncreated: function(){\n    this.login();\n},\nmethods: {\n    login(){\n    console.log(&quot;login&quot;);\n    this.$axios.get(_const.baseUrl + &quot;/login&quot;)\n    .then(function(res){\n        console.log(res.data);\n    })\n    .catch(function(error){\n        console.log(error);\n    });\n    },\n}, \n}  \n&lt;/script&gt;  \n</code></pre><h3 id=\"配置全局变量\"><a href=\"#配置全局变量\" class=\"headerlink\" title=\"配置全局变量\"></a>配置全局变量</h3><p>axios的地址可以在全局变量中定义然后使用，具体操作可以在static文件下新建一个全局变量文件：</p>\n<pre><code>const sysConfig = {\n    baseIp: &apos;127.0.0.1&apos;,\n    basePort: &apos;8888&apos;,\n    protocol: &apos;http://&apos;,\n    baseUrl: &apos;http://127.0.0.1:8888/blog&apos;,\n}\nlet bindToGlobal = (obj, key) =&gt; {\n    if (typeof window[key] === &apos;undefined&apos;) {\n        window[key] = {};\n    }\n\n    for (let i in obj) {\n        window[key][i] = obj[i]\n    }\n}\nbindToGlobal(sysConfig,&apos;_const&apos;)\n</code></pre><h3 id=\"附！项目文件结构\"><a href=\"#附！项目文件结构\" class=\"headerlink\" title=\"附！项目文件结构\"></a>附！项目文件结构</h3><p><img src=\"https://s2.ax1x.com/2019/05/12/Eh1EHe.png\" srcset=\"/img/loading.gif\" alt=\"Eh1EHe.png\"></p>\n<h3 id=\"运行启动前端项目\"><a href=\"#运行启动前端项目\" class=\"headerlink\" title=\"运行启动前端项目\"></a>运行启动前端项目</h3><p>先安装依赖：</p>\n<pre><code>npm install\n</code></pre><p>后运行项目:</p>\n<pre><code>npm run dev\n</code></pre><h2 id=\"SpringBoot创建\"><a href=\"#SpringBoot创建\" class=\"headerlink\" title=\"SpringBoot创建\"></a>SpringBoot创建</h2><h3 id=\"新建springboot项目\"><a href=\"#新建springboot项目\" class=\"headerlink\" title=\"新建springboot项目\"></a>新建springboot项目</h3><p>用idea新建一个springboot项目，打包形式首先选择成war包（若一开始选择的是jar包，后期通过修改启动类以及pom文件改成war打包形式，具体参见”springboot项目打包成war记录”）</p>\n<h3 id=\"编写实例测试-1\"><a href=\"#编写实例测试-1\" class=\"headerlink\" title=\"编写实例测试\"></a>编写实例测试</h3><p>写一个controller类作测试:</p>\n<pre><code>package com.csidez.blog.controller;\n\nimport org.springframework.web.bind.annotation.*;\n\n//允许跨域访问\n@CrossOrigin\n@RestController\npublic class testController {\n\n    @GetMapping(value = &quot;/login&quot;)\n    public String login(){\n        return &quot;Success&quot;;\n    }\n}\n</code></pre><h3 id=\"运行启动后端项目\"><a href=\"#运行启动后端项目\" class=\"headerlink\" title=\"运行启动后端项目\"></a>运行启动后端项目</h3><h2 id=\"整合及部署\"><a href=\"#整合及部署\" class=\"headerlink\" title=\"整合及部署\"></a>整合及部署</h2><h3 id=\"端口问题\"><a href=\"#端口问题\" class=\"headerlink\" title=\"端口问题\"></a>端口问题</h3><p>因为两个都是跑在8080端口上的，跑了一个另一个会冲突，所以本地测试的时候我修改springboot的tomcat的端口，可以在properties文件中添加<code>server.port=8888</code>这一行将端口修改到8888上面了</p>\n<h3 id=\"部署问题\"><a href=\"#部署问题\" class=\"headerlink\" title=\"部署问题\"></a>部署问题</h3><p>war包是在tomcat的webapps文件下解压开的，jar -xvf *.war所以会生成相应的名字，这样springboot访问时，连接中也需要加上该文件名。<br>因此，在设置前端axios的地址中，定义时需要注意url地址。<br>vue使用cnpm run build打包生成的dist文件，将dist里的两个文件直接黏贴到解压开的war中，这样出现另一个问题，无法打开vue的页面，需要修改在config文件夹中的index.js文件。将</p>\n<pre><code>assetsPublicPath: &apos;/&apos;\n</code></pre><p>修改为</p>\n<pre><code>assetsPublicPath: &apos;./&apos;\n</code></pre><p>或者也可以改为</p>\n<pre><code>assetsPublicPath: &apos;/war包文件夹名字/&apos;,\n</code></pre><p>注意需要改两处</p>\n<h3 id=\"跨域问题\"><a href=\"#跨域问题\" class=\"headerlink\" title=\"跨域问题\"></a>跨域问题</h3><p>由于我的部署方式是将vue项目打的包直接丢进springboot的war包解压开的文件夹内，未见此问题。如果报一下错误</p>\n<pre><code>No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource.\n</code></pre><p>应该是前面部署整合时候处理URL的问题，没有处理好。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SpringBoot与Vue的整合实现前后端分离\"><a href=\"#SpringBoot与Vue的整合实现前后端分离\" class=\"headerlink\" title=\"SpringBoot与Vue的整合实现前后端分离\"></a>SpringBoot与Vue的整合实现前后端分离</h1><h2 id=\"vue项目创建\"><a href=\"#vue项目创建\" class=\"headerlink\" title=\"vue项目创建\"></a>vue项目创建</h2><p>近期工作的项目中采用了Spring和Vue整合达到前后端完全分离的目的。vue使用了elementUI的UI框架，一边抄官方文档，一边修修改改，很方便上手。</p>\n<p>😊这里学习整理一下，准备用到自己的毕业设计里….</p>\n<h3 id=\"创建vue项目\"><a href=\"#创建vue项目\" class=\"headerlink\" title=\"创建vue项目\"></a>创建vue项目</h3><pre><code>vue init webpack \n</code></pre><p>（<code>注意的是，谨慎使用eslint这个工具</code>）</p>\n<h3 id=\"引入以及配置依赖包\"><a href=\"#引入以及配置依赖包\" class=\"headerlink\" title=\"引入以及配置依赖包\"></a>引入以及配置依赖包</h3><p>若使用elementUI组件（需要安装依赖npm install –save element-ui）:</p>\n<ol>\n<li><p>在src文件夹main.js文件中添加依赖以及引用</p>\n<pre><code>/* elementUI组件引用 */\nimport ElementUI from &apos;element-ui&apos;;\nimport &apos;../node_modules/element-ui/lib/theme-chalk/index.css&apos;;\n/* elementUI组件调用 */\nVue.use(ElementUI)\n</code></pre></li>\n</ol>\n<ol start=\"2\">\n<li><p>另外还可以加上axios的依赖</p>\n<pre><code>/* axios引用 */\nimport axios from &apos;axios&apos;;\n/* axios掉用 */\nVue.prototype.$axios = axios\n/* 设置header头，表示请求是ajax请求 */（这一行虽然写了注释，但是不懂，不知道可不可以不写）\naxios.defaults.headers.common[&apos;X-Requested-With&apos;] = &apos;XMLHttpRequest&apos;;\n</code></pre></li>\n</ol>\n<h3 id=\"编写实例测试\"><a href=\"#编写实例测试\" class=\"headerlink\" title=\"编写实例测试\"></a>编写实例测试</h3><p>在components中编写实例:</p>\n<pre><code>&lt;template&gt;  \n&lt;div class=&quot;hello&quot;&gt;  \n    &lt;h1&gt;{{ msg }}&lt;/h1&gt;  \n    &lt;h2&gt;Essential Links&lt;/h2&gt;  \n    &lt;el-button&gt;默认按钮&lt;/el-button&gt;  \n    &lt;el-button type=&quot;primary&quot;&gt;主要按钮&lt;/el-button&gt;  \n    &lt;el-button type=&quot;text&quot;&gt;文字按钮&lt;/el-button&gt;  \n    &lt;div&gt;\n    &lt;el-select v-model=&quot;value&quot; placeholder=&quot;请选择&quot;&gt;\n        &lt;el-option\n        v-for=&quot;item in options&quot;\n        :key=&quot;item.value&quot;\n        :label=&quot;item.label&quot;\n        :value=&quot;item.value&quot;&gt;\n        &lt;/el-option&gt;\n    &lt;/el-select&gt;\n    &lt;/div&gt;\n&lt;/div&gt;  \n&lt;/template&gt;  \n\n&lt;script&gt;  \n\nexport default {  \nname: &apos;hello&apos;,  \ndata () {  \n    return {  \n    msg: &apos;我是第二页&apos;,\n    options: [{\n        value: &apos;选项1&apos;,\n        label: &apos;黄金糕&apos;\n        }, {\n        value: &apos;选项2&apos;,\n        label: &apos;双皮奶&apos;\n        }, {\n        value: &apos;选项3&apos;,\n        label: &apos;蚵仔煎&apos;\n        }, {\n        value: &apos;选项4&apos;,\n        label: &apos;龙须面&apos;\n        }, {\n        value: &apos;选项5&apos;,\n        label: &apos;北京烤鸭&apos;\n        }],\n        value:&quot;&quot;, \n    }  \n},\ncreated: function(){\n    this.login();\n},\nmethods: {\n    login(){\n    console.log(&quot;login&quot;);\n    this.$axios.get(_const.baseUrl + &quot;/login&quot;)\n    .then(function(res){\n        console.log(res.data);\n    })\n    .catch(function(error){\n        console.log(error);\n    });\n    },\n}, \n}  \n&lt;/script&gt;  \n</code></pre><h3 id=\"配置全局变量\"><a href=\"#配置全局变量\" class=\"headerlink\" title=\"配置全局变量\"></a>配置全局变量</h3><p>axios的地址可以在全局变量中定义然后使用，具体操作可以在static文件下新建一个全局变量文件：</p>\n<pre><code>const sysConfig = {\n    baseIp: &apos;127.0.0.1&apos;,\n    basePort: &apos;8888&apos;,\n    protocol: &apos;http://&apos;,\n    baseUrl: &apos;http://127.0.0.1:8888/blog&apos;,\n}\nlet bindToGlobal = (obj, key) =&gt; {\n    if (typeof window[key] === &apos;undefined&apos;) {\n        window[key] = {};\n    }\n\n    for (let i in obj) {\n        window[key][i] = obj[i]\n    }\n}\nbindToGlobal(sysConfig,&apos;_const&apos;)\n</code></pre><h3 id=\"附！项目文件结构\"><a href=\"#附！项目文件结构\" class=\"headerlink\" title=\"附！项目文件结构\"></a>附！项目文件结构</h3><p><img src=\"https://s2.ax1x.com/2019/05/12/Eh1EHe.png\" srcset=\"/img/loading.gif\" alt=\"Eh1EHe.png\"></p>\n<h3 id=\"运行启动前端项目\"><a href=\"#运行启动前端项目\" class=\"headerlink\" title=\"运行启动前端项目\"></a>运行启动前端项目</h3><p>先安装依赖：</p>\n<pre><code>npm install\n</code></pre><p>后运行项目:</p>\n<pre><code>npm run dev\n</code></pre><h2 id=\"SpringBoot创建\"><a href=\"#SpringBoot创建\" class=\"headerlink\" title=\"SpringBoot创建\"></a>SpringBoot创建</h2><h3 id=\"新建springboot项目\"><a href=\"#新建springboot项目\" class=\"headerlink\" title=\"新建springboot项目\"></a>新建springboot项目</h3><p>用idea新建一个springboot项目，打包形式首先选择成war包（若一开始选择的是jar包，后期通过修改启动类以及pom文件改成war打包形式，具体参见”springboot项目打包成war记录”）</p>\n<h3 id=\"编写实例测试-1\"><a href=\"#编写实例测试-1\" class=\"headerlink\" title=\"编写实例测试\"></a>编写实例测试</h3><p>写一个controller类作测试:</p>\n<pre><code>package com.csidez.blog.controller;\n\nimport org.springframework.web.bind.annotation.*;\n\n//允许跨域访问\n@CrossOrigin\n@RestController\npublic class testController {\n\n    @GetMapping(value = &quot;/login&quot;)\n    public String login(){\n        return &quot;Success&quot;;\n    }\n}\n</code></pre><h3 id=\"运行启动后端项目\"><a href=\"#运行启动后端项目\" class=\"headerlink\" title=\"运行启动后端项目\"></a>运行启动后端项目</h3><h2 id=\"整合及部署\"><a href=\"#整合及部署\" class=\"headerlink\" title=\"整合及部署\"></a>整合及部署</h2><h3 id=\"端口问题\"><a href=\"#端口问题\" class=\"headerlink\" title=\"端口问题\"></a>端口问题</h3><p>因为两个都是跑在8080端口上的，跑了一个另一个会冲突，所以本地测试的时候我修改springboot的tomcat的端口，可以在properties文件中添加<code>server.port=8888</code>这一行将端口修改到8888上面了</p>\n<h3 id=\"部署问题\"><a href=\"#部署问题\" class=\"headerlink\" title=\"部署问题\"></a>部署问题</h3><p>war包是在tomcat的webapps文件下解压开的，jar -xvf *.war所以会生成相应的名字，这样springboot访问时，连接中也需要加上该文件名。<br>因此，在设置前端axios的地址中，定义时需要注意url地址。<br>vue使用cnpm run build打包生成的dist文件，将dist里的两个文件直接黏贴到解压开的war中，这样出现另一个问题，无法打开vue的页面，需要修改在config文件夹中的index.js文件。将</p>\n<pre><code>assetsPublicPath: &apos;/&apos;\n</code></pre><p>修改为</p>\n<pre><code>assetsPublicPath: &apos;./&apos;\n</code></pre><p>或者也可以改为</p>\n<pre><code>assetsPublicPath: &apos;/war包文件夹名字/&apos;,\n</code></pre><p>注意需要改两处</p>\n<h3 id=\"跨域问题\"><a href=\"#跨域问题\" class=\"headerlink\" title=\"跨域问题\"></a>跨域问题</h3><p>由于我的部署方式是将vue项目打的包直接丢进springboot的war包解压开的文件夹内，未见此问题。如果报一下错误</p>\n<pre><code>No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource.\n</code></pre><p>应该是前面部署整合时候处理URL的问题，没有处理好。</p>\n"},{"title":"Entity，Bo，Vo，Po,Dto,Pojo的理解和区分","date":"2020-02-24T09:31:15.000Z","_content":"# Entity，Bo，Vo，Po,Dto,Pojo的理解和区分\n\n\n## POJO\nplian ordinary java object：简单无规则java对象\n纯的传统意义的java对象，最基本的Java Bean只有属性加上属性的get和set方法\n\n可以额转化为PO、DTO、VO；比如POJO在传输过程中就是DTO\n\n## PO和Entity\n- entity:\n   最常用实体类，基本和数据表一一对应，一个实体一张表。\n- Po: \n   代表持久层对象的意思，对应数据库中表的字段，数据库表中的记录在java对象中的显示状态，最形象的理解就是一个PO就是数据库中的一条记录。\n\n   好处是可以把一条记录作为一个对象处理，可以方便的转为其它对象。Vo和Po，都是属性加上属性的get和set方法；表面看没什么不同，但代表的含义是完全不同的。\n- 总结：所以Po和Entity有什么区别呢？.....\n\n## Bo\n很明显就是business object，业务对象。\nBo就是把业务逻辑封装为一个对象（注意是逻辑，业务逻辑），这个对象可以包括一个或多个其它的对象。通过调用Dao方法，结合Po或Vo进行业务操作。\n\n投保人是一个Po，被保险人是一个Po，险种信息也是一个Po等等，他们组合起来就是一张保单的Bo。\n   - 保单信息（Bo）\n      - 投保人信息（Po）\n      - 被保险人信息（Po）\n      - 险种信息（Po）\n## Vo\n个人认为叫View Object更加合适。\n\n代表值对象的意思，通常用于业务层之间的数据传递，由new创建，由GC回收。\n主要体现在视图的对象，对于一个WEB页面将整个页面的属性封装成一个对象，然后用一个VO对象在控制层与视图层进行传输交换。\n\n## Dto\n代表数据传输对象的意思\n\n简而言之，就是接口之间传递的数据封装。表里面有十几个字段：id，name，gender（M/F)，age……而页面需要展示三个字段：name，gender(男/女)，age\n\nDTO由此产生，一是能提高数据传输的速度(减少了传输字段)，二能隐藏后端表结构","source":"_posts/Entity，Bo，Vo，Po,Dto,Pojo的理解和区分.md","raw":"---\ntitle: Entity，Bo，Vo，Po,Dto,Pojo的理解和区分\ndate: 2020-02-24 17:31:15\ntags: \n- JAVA\n---\n# Entity，Bo，Vo，Po,Dto,Pojo的理解和区分\n\n\n## POJO\nplian ordinary java object：简单无规则java对象\n纯的传统意义的java对象，最基本的Java Bean只有属性加上属性的get和set方法\n\n可以额转化为PO、DTO、VO；比如POJO在传输过程中就是DTO\n\n## PO和Entity\n- entity:\n   最常用实体类，基本和数据表一一对应，一个实体一张表。\n- Po: \n   代表持久层对象的意思，对应数据库中表的字段，数据库表中的记录在java对象中的显示状态，最形象的理解就是一个PO就是数据库中的一条记录。\n\n   好处是可以把一条记录作为一个对象处理，可以方便的转为其它对象。Vo和Po，都是属性加上属性的get和set方法；表面看没什么不同，但代表的含义是完全不同的。\n- 总结：所以Po和Entity有什么区别呢？.....\n\n## Bo\n很明显就是business object，业务对象。\nBo就是把业务逻辑封装为一个对象（注意是逻辑，业务逻辑），这个对象可以包括一个或多个其它的对象。通过调用Dao方法，结合Po或Vo进行业务操作。\n\n投保人是一个Po，被保险人是一个Po，险种信息也是一个Po等等，他们组合起来就是一张保单的Bo。\n   - 保单信息（Bo）\n      - 投保人信息（Po）\n      - 被保险人信息（Po）\n      - 险种信息（Po）\n## Vo\n个人认为叫View Object更加合适。\n\n代表值对象的意思，通常用于业务层之间的数据传递，由new创建，由GC回收。\n主要体现在视图的对象，对于一个WEB页面将整个页面的属性封装成一个对象，然后用一个VO对象在控制层与视图层进行传输交换。\n\n## Dto\n代表数据传输对象的意思\n\n简而言之，就是接口之间传递的数据封装。表里面有十几个字段：id，name，gender（M/F)，age……而页面需要展示三个字段：name，gender(男/女)，age\n\nDTO由此产生，一是能提高数据传输的速度(减少了传输字段)，二能隐藏后端表结构","slug":"Entity，Bo，Vo，Po,Dto,Pojo的理解和区分","published":1,"updated":"2020-04-07T06:12:59.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9m4gt7u0008upqenbvn1nlv","content":"<h1 id=\"Entity，Bo，Vo，Po-Dto-Pojo的理解和区分\"><a href=\"#Entity，Bo，Vo，Po-Dto-Pojo的理解和区分\" class=\"headerlink\" title=\"Entity，Bo，Vo，Po,Dto,Pojo的理解和区分\"></a>Entity，Bo，Vo，Po,Dto,Pojo的理解和区分</h1><h2 id=\"POJO\"><a href=\"#POJO\" class=\"headerlink\" title=\"POJO\"></a>POJO</h2><p>plian ordinary java object：简单无规则java对象<br>纯的传统意义的java对象，最基本的Java Bean只有属性加上属性的get和set方法</p>\n<p>可以额转化为PO、DTO、VO；比如POJO在传输过程中就是DTO</p>\n<h2 id=\"PO和Entity\"><a href=\"#PO和Entity\" class=\"headerlink\" title=\"PO和Entity\"></a>PO和Entity</h2><ul>\n<li>entity:<br> 最常用实体类，基本和数据表一一对应，一个实体一张表。</li>\n<li><p>Po:<br> 代表持久层对象的意思，对应数据库中表的字段，数据库表中的记录在java对象中的显示状态，最形象的理解就是一个PO就是数据库中的一条记录。</p>\n<p> 好处是可以把一条记录作为一个对象处理，可以方便的转为其它对象。Vo和Po，都是属性加上属性的get和set方法；表面看没什么不同，但代表的含义是完全不同的。</p>\n</li>\n<li>总结：所以Po和Entity有什么区别呢？…..</li>\n</ul>\n<h2 id=\"Bo\"><a href=\"#Bo\" class=\"headerlink\" title=\"Bo\"></a>Bo</h2><p>很明显就是business object，业务对象。<br>Bo就是把业务逻辑封装为一个对象（注意是逻辑，业务逻辑），这个对象可以包括一个或多个其它的对象。通过调用Dao方法，结合Po或Vo进行业务操作。</p>\n<p>投保人是一个Po，被保险人是一个Po，险种信息也是一个Po等等，他们组合起来就是一张保单的Bo。</p>\n<ul>\n<li>保单信息（Bo）<ul>\n<li>投保人信息（Po）</li>\n<li>被保险人信息（Po）</li>\n<li>险种信息（Po）<h2 id=\"Vo\"><a href=\"#Vo\" class=\"headerlink\" title=\"Vo\"></a>Vo</h2>个人认为叫View Object更加合适。</li>\n</ul>\n</li>\n</ul>\n<p>代表值对象的意思，通常用于业务层之间的数据传递，由new创建，由GC回收。<br>主要体现在视图的对象，对于一个WEB页面将整个页面的属性封装成一个对象，然后用一个VO对象在控制层与视图层进行传输交换。</p>\n<h2 id=\"Dto\"><a href=\"#Dto\" class=\"headerlink\" title=\"Dto\"></a>Dto</h2><p>代表数据传输对象的意思</p>\n<p>简而言之，就是接口之间传递的数据封装。表里面有十几个字段：id，name，gender（M/F)，age……而页面需要展示三个字段：name，gender(男/女)，age</p>\n<p>DTO由此产生，一是能提高数据传输的速度(减少了传输字段)，二能隐藏后端表结构</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Entity，Bo，Vo，Po-Dto-Pojo的理解和区分\"><a href=\"#Entity，Bo，Vo，Po-Dto-Pojo的理解和区分\" class=\"headerlink\" title=\"Entity，Bo，Vo，Po,Dto,Pojo的理解和区分\"></a>Entity，Bo，Vo，Po,Dto,Pojo的理解和区分</h1><h2 id=\"POJO\"><a href=\"#POJO\" class=\"headerlink\" title=\"POJO\"></a>POJO</h2><p>plian ordinary java object：简单无规则java对象<br>纯的传统意义的java对象，最基本的Java Bean只有属性加上属性的get和set方法</p>\n<p>可以额转化为PO、DTO、VO；比如POJO在传输过程中就是DTO</p>\n<h2 id=\"PO和Entity\"><a href=\"#PO和Entity\" class=\"headerlink\" title=\"PO和Entity\"></a>PO和Entity</h2><ul>\n<li>entity:<br> 最常用实体类，基本和数据表一一对应，一个实体一张表。</li>\n<li><p>Po:<br> 代表持久层对象的意思，对应数据库中表的字段，数据库表中的记录在java对象中的显示状态，最形象的理解就是一个PO就是数据库中的一条记录。</p>\n<p> 好处是可以把一条记录作为一个对象处理，可以方便的转为其它对象。Vo和Po，都是属性加上属性的get和set方法；表面看没什么不同，但代表的含义是完全不同的。</p>\n</li>\n<li>总结：所以Po和Entity有什么区别呢？…..</li>\n</ul>\n<h2 id=\"Bo\"><a href=\"#Bo\" class=\"headerlink\" title=\"Bo\"></a>Bo</h2><p>很明显就是business object，业务对象。<br>Bo就是把业务逻辑封装为一个对象（注意是逻辑，业务逻辑），这个对象可以包括一个或多个其它的对象。通过调用Dao方法，结合Po或Vo进行业务操作。</p>\n<p>投保人是一个Po，被保险人是一个Po，险种信息也是一个Po等等，他们组合起来就是一张保单的Bo。</p>\n<ul>\n<li>保单信息（Bo）<ul>\n<li>投保人信息（Po）</li>\n<li>被保险人信息（Po）</li>\n<li>险种信息（Po）<h2 id=\"Vo\"><a href=\"#Vo\" class=\"headerlink\" title=\"Vo\"></a>Vo</h2>个人认为叫View Object更加合适。</li>\n</ul>\n</li>\n</ul>\n<p>代表值对象的意思，通常用于业务层之间的数据传递，由new创建，由GC回收。<br>主要体现在视图的对象，对于一个WEB页面将整个页面的属性封装成一个对象，然后用一个VO对象在控制层与视图层进行传输交换。</p>\n<h2 id=\"Dto\"><a href=\"#Dto\" class=\"headerlink\" title=\"Dto\"></a>Dto</h2><p>代表数据传输对象的意思</p>\n<p>简而言之，就是接口之间传递的数据封装。表里面有十几个字段：id，name，gender（M/F)，age……而页面需要展示三个字段：name，gender(男/女)，age</p>\n<p>DTO由此产生，一是能提高数据传输的速度(减少了传输字段)，二能隐藏后端表结构</p>\n"},{"title":"Spring单元测试编写","date":"2020-01-22T06:09:01.000Z","_content":"# SpringBoot单元测试\n## Controller层\n### 登录校验(一般情况不使用)\n\n```java\n@RunWith(SpringRunner.class)\n@Transactional//测试结束后rollback\n@SpringBootTest\npublic abstract class BaseTest {\n    private static final LoginBean LOGINBEAN;\n    static {\n        LoginBean.Builder builder = new LoginBean.Builder();\n        builder.setAccountID(\"7f2b815be57541549b7c4cd1e81f2923\");\n        builder.setCompanyID(\"08d181119a7b4c0e94ff368942fd4420\");\n        builder.setLoginName(\"utry\");\n        builder.setRealName(\"远传\");\n        LOGINBEAN = builder.build();\n        LoginInfo.putSp(LOGINBEAN);\n    }\n\n    @Autowired\n    protected ICacheService cache;\n    \n    {\n        init();\n    }\n\n    private static void init() {\n        preloadModules();\n        splitMapper();\n    }\n\n    private static void preloadModules() {\n        UtryCloudModuleManager.initModules();\n    }\n\n    private static void splitMapper() {\n        new MybatisMapperSplitListener(\"mapper\").onApplicationEvent(null);\n    }\n\n    @Before\n    public void setUp() {\n        LoginInfo.setThreadLocal(cache, LOGINBEAN);\n    }\n}\n```\n\n### 注解\n\n- 测试类注解\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\n```\n- 模拟MVC环境注解以及代码\n```java\nprivate MockMVC mockMVC\n@Autowired\nprivate WebApplicationContext webApplicationContext;\n\n```\n- 通过@Before方法，提前准备测试环境\n\n`注意（此处的MockMvc 实例化是通过手工方式创建，如果想通过spring的bean注入方式的话，在类上加@AutoConfigureMockMvc/@Controller等注解，只要等同于@Component效果即可，然后在上面的第2步中进行注入，即在成员变量mockMvc上加注解@Autowired）`\n\n```java\n@Before\npublic void setup(){\n    /*通过bean注入方式\n    mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();\n    */\n\n    /*手动指定需要测试controller类*/\n    mockMvc = MockMvcBuilders.standaloneSetup(new RecordTapDataImportController()).build();\n}\n\n```\n\n### 编写测试方法@Test\n- 普通的测试方法\n```java\n/**\n     * 获取最新app信息\n     */\n\t@Test\n\tpublic void TestGetAppLatestVersion() throws Exception{\n\t\tRequestBuilder request = null;\n\t\t//构造请求\n\t\trequest = post(\"/appProducer/getAppLatestVersion\") \n\t\t\t\t.param(\"appId\", \"1001\"); \n\t\t//执行请求\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())//返回HTTP状态为200\n\t\t        .andExpect(jsonPath(\"$.status\", not(\"E\")))//使用jsonPath解析JSON返回值，判断具体的内容, 此处不希望status返回E\n\t\t        .andDo(print());//打印结果\n\t\t        //.andReturn();//想要返回结果，使用此方法\n\t\t\n\t}\n\t\n\t/**\n\t * 用户通过微信方式扫描下载APP，则会提示使用浏览器打开地址\n\t */\n\t@Test\n\tpublic void TestDownloadAppByMicroMessenger() throws Exception{\n\t\tRequestBuilder request = null;\n\t\t//构造请求\n\t\trequest = get(\"/appProducer/downloadApp\")\n\t\t\t\t.header(\"user-agent\", \"MicroMessenger\")\n\t\t\t\t.param(\"appId\", \"1001\"); \n\t\t//执行请求\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())//返回HTTP状态为200\n\t\t        .andExpect(content().string(containsString(\"选择浏览器打开即可\")))//返回结果中需包含的文字\n\t\t        .andDo(print());//打印结果\n\t\t\n\t}\n\t\n\t/**\n\t * 用户通过Android扫描下载APP\n\t */\n\t@Test\n\tpublic void TestDownloadAppByAndroid() throws Exception{\n\t\tRequestBuilder request = null;\n\t\t//构造请求\n\t\trequest = get(\"/appProducer/downloadApp\")\n\t\t\t\t.header(\"user-agent\", \"Android\")\n\t\t\t\t.param(\"appId\", \"1001\"); \n\t\t//执行请求\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())//返回HTTP状态为200\n\t\t        .andDo(print());//打印结果\n\t\t\n\t}\n\t\n\t/**\n\t * 用户通过iPhone扫描下载APP，则会重定向至评苹果APP官网\n\t */\n\t@Test\n\tpublic void TestDownloadAppByIphone() throws Exception{\n\t\tRequestBuilder request = null;\n\t\t//构造请求\n\t\trequest = get(\"/appProducer/downloadApp\")\n\t\t\t\t.header(\"user-agent\", \"iPhone\")\n\t\t\t\t.param(\"appId\", \"1001\"); \n\t\t//执行请求\n\t\tmockMvc.perform(request) \n\t\t\t\t.andExpect(status().is3xxRedirection())//表示页面被重定向\n\t\t\t\t.andExpect(redirectedUrl(\"https://www.apple.com/cn/itunes/charts/\"))//验证处理完请求后重定向的url\n\t\t        .andDo(print());//打印结果\n\t\t\n\t}\n\t\n\t/**\n\t * 用户通过iPad扫描下载APP，则会重定向至评苹果APP官网\n\t */\n\t@Test\n\tpublic void TestDownloadAppByIPad() throws Exception{\n\t\tRequestBuilder request = null;\n\t\t//构造请求\n\t\trequest = get(\"/appProducer/downloadApp\")\n\t\t\t\t.header(\"user-agent\", \"iPad\")\n\t\t\t\t.param(\"appId\", \"1001\"); \n\t\t//执行请求\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().is3xxRedirection())//表示页面被重定向\n\t\t        .andExpect(redirectedUrl(\"https://www.apple.com/cn/itunes/charts/\"))//验证处理完请求后重定向的url\n\t\t        .andDo(print());//打印结果\n\t\t\n\t}\n\t\n\t/**\n\t * 用户通过其他方式扫描下载APP，则会提示仅支持的下载方式\n\t */\n\t@Test\n\tpublic void TestDownloadAppByOther() throws Exception{\n\t\tRequestBuilder request = null;\n\t\t//构造请求\n\t\trequest = get(\"/appProducer/downloadApp\")\n\t\t\t\t.header(\"user-agent\", \"other\")\n\t\t\t\t.param(\"appId\", \"1001\"); \n\t\t//执行请求\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())//返回HTTP状态为200\n\t\t        .andExpect(content().string(containsString(\"<h1>出现该页面可能是以下原因</h1>\")))\n\t\t        .andDo(print());//打印结果\n\t\t\n\t}\n\t\n\t/**\n\t * APP升级\n\t */\n\t@Test\n\tpublic void TestUpgradeApp() throws Exception{\n\t\tRequestBuilder request = null;\n\t\t//构造请求\n\t\trequest = get(\"/appProducer/upgradeApp\")\n\t\t\t\t.param(\"appId\", \"1001\"); \n\t\t//执行请求\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())//返回HTTP状态为200\n\t\t        .andDo(print());//打印结果\n\t\t\n\t}\n```\n\n```java\n@Test\npublic void controllerTest() throws Exception{\n\n    VoiceData voiceData = new VoiceData();\n    voiceData.setId(\"123\");\n    voiceData.setServiceName(\"jack\");\n\n    VoiceDataBo voiceDataBo = new VoiceDataBo();\n    voiceDataBo.setCallId(\"123\");\n    voiceDataBo.setSeatName(\"tom\");\n\n    List dataList = new ArrayList();\n    dataList.add(voiceData);\n\n    /*构造一个请求*/\n    RequestBuilder request = null;\n    request = MockMvcRequestBuilders.post(\"/recordTapImport/voiceData\")\n            .contentType(MediaType.APPLICATION_JSON).content(JSON.toJSONString(dataList));\n\n    /*执行一个请求*/\n    mockMvc.perform(request).andDo(print()).andReturn();\n}\n```\n\n- 当发送一个被@ResponceBody标识的参数，遇到400的返回错误。\n    `注意上面contentType需要设置成MediaType.APPLICATION_JSON，即声明是发送“application/json”格式的数据。使用content方法，将转换的json数据放到request的body中。`\n\n","source":"_posts/Spring单元测试编写.md","raw":"---\ntitle: Spring单元测试编写\ndate: 2020-01-22 14:09:01\ntags: 单元测试\n---\n# SpringBoot单元测试\n## Controller层\n### 登录校验(一般情况不使用)\n\n```java\n@RunWith(SpringRunner.class)\n@Transactional//测试结束后rollback\n@SpringBootTest\npublic abstract class BaseTest {\n    private static final LoginBean LOGINBEAN;\n    static {\n        LoginBean.Builder builder = new LoginBean.Builder();\n        builder.setAccountID(\"7f2b815be57541549b7c4cd1e81f2923\");\n        builder.setCompanyID(\"08d181119a7b4c0e94ff368942fd4420\");\n        builder.setLoginName(\"utry\");\n        builder.setRealName(\"远传\");\n        LOGINBEAN = builder.build();\n        LoginInfo.putSp(LOGINBEAN);\n    }\n\n    @Autowired\n    protected ICacheService cache;\n    \n    {\n        init();\n    }\n\n    private static void init() {\n        preloadModules();\n        splitMapper();\n    }\n\n    private static void preloadModules() {\n        UtryCloudModuleManager.initModules();\n    }\n\n    private static void splitMapper() {\n        new MybatisMapperSplitListener(\"mapper\").onApplicationEvent(null);\n    }\n\n    @Before\n    public void setUp() {\n        LoginInfo.setThreadLocal(cache, LOGINBEAN);\n    }\n}\n```\n\n### 注解\n\n- 测试类注解\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\n```\n- 模拟MVC环境注解以及代码\n```java\nprivate MockMVC mockMVC\n@Autowired\nprivate WebApplicationContext webApplicationContext;\n\n```\n- 通过@Before方法，提前准备测试环境\n\n`注意（此处的MockMvc 实例化是通过手工方式创建，如果想通过spring的bean注入方式的话，在类上加@AutoConfigureMockMvc/@Controller等注解，只要等同于@Component效果即可，然后在上面的第2步中进行注入，即在成员变量mockMvc上加注解@Autowired）`\n\n```java\n@Before\npublic void setup(){\n    /*通过bean注入方式\n    mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();\n    */\n\n    /*手动指定需要测试controller类*/\n    mockMvc = MockMvcBuilders.standaloneSetup(new RecordTapDataImportController()).build();\n}\n\n```\n\n### 编写测试方法@Test\n- 普通的测试方法\n```java\n/**\n     * 获取最新app信息\n     */\n\t@Test\n\tpublic void TestGetAppLatestVersion() throws Exception{\n\t\tRequestBuilder request = null;\n\t\t//构造请求\n\t\trequest = post(\"/appProducer/getAppLatestVersion\") \n\t\t\t\t.param(\"appId\", \"1001\"); \n\t\t//执行请求\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())//返回HTTP状态为200\n\t\t        .andExpect(jsonPath(\"$.status\", not(\"E\")))//使用jsonPath解析JSON返回值，判断具体的内容, 此处不希望status返回E\n\t\t        .andDo(print());//打印结果\n\t\t        //.andReturn();//想要返回结果，使用此方法\n\t\t\n\t}\n\t\n\t/**\n\t * 用户通过微信方式扫描下载APP，则会提示使用浏览器打开地址\n\t */\n\t@Test\n\tpublic void TestDownloadAppByMicroMessenger() throws Exception{\n\t\tRequestBuilder request = null;\n\t\t//构造请求\n\t\trequest = get(\"/appProducer/downloadApp\")\n\t\t\t\t.header(\"user-agent\", \"MicroMessenger\")\n\t\t\t\t.param(\"appId\", \"1001\"); \n\t\t//执行请求\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())//返回HTTP状态为200\n\t\t        .andExpect(content().string(containsString(\"选择浏览器打开即可\")))//返回结果中需包含的文字\n\t\t        .andDo(print());//打印结果\n\t\t\n\t}\n\t\n\t/**\n\t * 用户通过Android扫描下载APP\n\t */\n\t@Test\n\tpublic void TestDownloadAppByAndroid() throws Exception{\n\t\tRequestBuilder request = null;\n\t\t//构造请求\n\t\trequest = get(\"/appProducer/downloadApp\")\n\t\t\t\t.header(\"user-agent\", \"Android\")\n\t\t\t\t.param(\"appId\", \"1001\"); \n\t\t//执行请求\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())//返回HTTP状态为200\n\t\t        .andDo(print());//打印结果\n\t\t\n\t}\n\t\n\t/**\n\t * 用户通过iPhone扫描下载APP，则会重定向至评苹果APP官网\n\t */\n\t@Test\n\tpublic void TestDownloadAppByIphone() throws Exception{\n\t\tRequestBuilder request = null;\n\t\t//构造请求\n\t\trequest = get(\"/appProducer/downloadApp\")\n\t\t\t\t.header(\"user-agent\", \"iPhone\")\n\t\t\t\t.param(\"appId\", \"1001\"); \n\t\t//执行请求\n\t\tmockMvc.perform(request) \n\t\t\t\t.andExpect(status().is3xxRedirection())//表示页面被重定向\n\t\t\t\t.andExpect(redirectedUrl(\"https://www.apple.com/cn/itunes/charts/\"))//验证处理完请求后重定向的url\n\t\t        .andDo(print());//打印结果\n\t\t\n\t}\n\t\n\t/**\n\t * 用户通过iPad扫描下载APP，则会重定向至评苹果APP官网\n\t */\n\t@Test\n\tpublic void TestDownloadAppByIPad() throws Exception{\n\t\tRequestBuilder request = null;\n\t\t//构造请求\n\t\trequest = get(\"/appProducer/downloadApp\")\n\t\t\t\t.header(\"user-agent\", \"iPad\")\n\t\t\t\t.param(\"appId\", \"1001\"); \n\t\t//执行请求\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().is3xxRedirection())//表示页面被重定向\n\t\t        .andExpect(redirectedUrl(\"https://www.apple.com/cn/itunes/charts/\"))//验证处理完请求后重定向的url\n\t\t        .andDo(print());//打印结果\n\t\t\n\t}\n\t\n\t/**\n\t * 用户通过其他方式扫描下载APP，则会提示仅支持的下载方式\n\t */\n\t@Test\n\tpublic void TestDownloadAppByOther() throws Exception{\n\t\tRequestBuilder request = null;\n\t\t//构造请求\n\t\trequest = get(\"/appProducer/downloadApp\")\n\t\t\t\t.header(\"user-agent\", \"other\")\n\t\t\t\t.param(\"appId\", \"1001\"); \n\t\t//执行请求\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())//返回HTTP状态为200\n\t\t        .andExpect(content().string(containsString(\"<h1>出现该页面可能是以下原因</h1>\")))\n\t\t        .andDo(print());//打印结果\n\t\t\n\t}\n\t\n\t/**\n\t * APP升级\n\t */\n\t@Test\n\tpublic void TestUpgradeApp() throws Exception{\n\t\tRequestBuilder request = null;\n\t\t//构造请求\n\t\trequest = get(\"/appProducer/upgradeApp\")\n\t\t\t\t.param(\"appId\", \"1001\"); \n\t\t//执行请求\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())//返回HTTP状态为200\n\t\t        .andDo(print());//打印结果\n\t\t\n\t}\n```\n\n```java\n@Test\npublic void controllerTest() throws Exception{\n\n    VoiceData voiceData = new VoiceData();\n    voiceData.setId(\"123\");\n    voiceData.setServiceName(\"jack\");\n\n    VoiceDataBo voiceDataBo = new VoiceDataBo();\n    voiceDataBo.setCallId(\"123\");\n    voiceDataBo.setSeatName(\"tom\");\n\n    List dataList = new ArrayList();\n    dataList.add(voiceData);\n\n    /*构造一个请求*/\n    RequestBuilder request = null;\n    request = MockMvcRequestBuilders.post(\"/recordTapImport/voiceData\")\n            .contentType(MediaType.APPLICATION_JSON).content(JSON.toJSONString(dataList));\n\n    /*执行一个请求*/\n    mockMvc.perform(request).andDo(print()).andReturn();\n}\n```\n\n- 当发送一个被@ResponceBody标识的参数，遇到400的返回错误。\n    `注意上面contentType需要设置成MediaType.APPLICATION_JSON，即声明是发送“application/json”格式的数据。使用content方法，将转换的json数据放到request的body中。`\n\n","slug":"Spring单元测试编写","published":1,"updated":"2020-04-07T06:09:39.976Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9m4gt7v0009upqethe6w40u","content":"<h1 id=\"SpringBoot单元测试\"><a href=\"#SpringBoot单元测试\" class=\"headerlink\" title=\"SpringBoot单元测试\"></a>SpringBoot单元测试</h1><h2 id=\"Controller层\"><a href=\"#Controller层\" class=\"headerlink\" title=\"Controller层\"></a>Controller层</h2><h3 id=\"登录校验-一般情况不使用\"><a href=\"#登录校验-一般情况不使用\" class=\"headerlink\" title=\"登录校验(一般情况不使用)\"></a>登录校验(一般情况不使用)</h3><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@RunWith</span>(SpringRunner<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)\n@<span class=\"hljs-title\">Transactional</span>//测试结束后<span class=\"hljs-title\">rollback</span>\n@<span class=\"hljs-title\">SpringBootTest</span>\n<span class=\"hljs-title\">public</span> <span class=\"hljs-title\">abstract</span> <span class=\"hljs-title\">class</span> <span class=\"hljs-title\">BaseTest</span> </span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> LoginBean LOGINBEAN;\n    <span class=\"hljs-keyword\">static</span> &#123;\n        LoginBean.Builder builder = <span class=\"hljs-keyword\">new</span> LoginBean.Builder();\n        builder.setAccountID(<span class=\"hljs-string\">\"7f2b815be57541549b7c4cd1e81f2923\"</span>);\n        builder.setCompanyID(<span class=\"hljs-string\">\"08d181119a7b4c0e94ff368942fd4420\"</span>);\n        builder.setLoginName(<span class=\"hljs-string\">\"utry\"</span>);\n        builder.setRealName(<span class=\"hljs-string\">\"远传\"</span>);\n        LOGINBEAN = builder.build();\n        LoginInfo.putSp(LOGINBEAN);\n    &#125;\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">protected</span> ICacheService cache;\n    \n    &#123;\n        init();\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">()</span> </span>&#123;\n        preloadModules();\n        splitMapper();\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">preloadModules</span><span class=\"hljs-params\">()</span> </span>&#123;\n        UtryCloudModuleManager.initModules();\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">splitMapper</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">new</span> MybatisMapperSplitListener(<span class=\"hljs-string\">\"mapper\"</span>).onApplicationEvent(<span class=\"hljs-keyword\">null</span>);\n    &#125;\n\n    <span class=\"hljs-meta\">@Before</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setUp</span><span class=\"hljs-params\">()</span> </span>&#123;\n        LoginInfo.setThreadLocal(cache, LOGINBEAN);\n    &#125;\n&#125;</code></pre>\n<h3 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h3><ul>\n<li><p>测试类注解</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@RunWith</span>(SpringRunner<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)\n@<span class=\"hljs-title\">SpringBootTest</span></span></code></pre>\n</li>\n<li><p>模拟MVC环境注解以及代码</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> MockMVC mockMVC\n<span class=\"hljs-meta\">@Autowired</span>\n<span class=\"hljs-keyword\">private</span> WebApplicationContext webApplicationContext;</code></pre>\n</li>\n<li><p>通过@Before方法，提前准备测试环境</p>\n</li>\n</ul>\n<p><code>注意（此处的MockMvc 实例化是通过手工方式创建，如果想通过spring的bean注入方式的话，在类上加@AutoConfigureMockMvc/@Controller等注解，只要等同于@Component效果即可，然后在上面的第2步中进行注入，即在成员变量mockMvc上加注解@Autowired）</code></p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Before</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setup</span><span class=\"hljs-params\">()</span></span>&#123;\n    <span class=\"hljs-comment\">/*通过bean注入方式\n    mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();\n    */</span>\n\n    <span class=\"hljs-comment\">/*手动指定需要测试controller类*/</span>\n    mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> RecordTapDataImportController()).build();\n&#125;</code></pre>\n<h3 id=\"编写测试方法-Test\"><a href=\"#编写测试方法-Test\" class=\"headerlink\" title=\"编写测试方法@Test\"></a>编写测试方法@Test</h3><ul>\n<li>普通的测试方法<pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**\n     * 获取最新app信息\n     */</span>\n\t<span class=\"hljs-meta\">@Test</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">TestGetAppLatestVersion</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception</span>&#123;\n\t\tRequestBuilder request = <span class=\"hljs-keyword\">null</span>;\n\t\t<span class=\"hljs-comment\">//构造请求</span>\n\t\trequest = post(<span class=\"hljs-string\">\"/appProducer/getAppLatestVersion\"</span>) \n\t\t\t\t.param(<span class=\"hljs-string\">\"appId\"</span>, <span class=\"hljs-string\">\"1001\"</span>); \n\t\t<span class=\"hljs-comment\">//执行请求</span>\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())<span class=\"hljs-comment\">//返回HTTP状态为200</span>\n\t\t        .andExpect(jsonPath(<span class=\"hljs-string\">\"$.status\"</span>, not(<span class=\"hljs-string\">\"E\"</span>)))<span class=\"hljs-comment\">//使用jsonPath解析JSON返回值，判断具体的内容, 此处不希望status返回E</span>\n\t\t        .andDo(print());<span class=\"hljs-comment\">//打印结果</span>\n\t\t        <span class=\"hljs-comment\">//.andReturn();//想要返回结果，使用此方法</span>\n\t\t\n\t&#125;\n\t\n\t<span class=\"hljs-comment\">/**\n\t * 用户通过微信方式扫描下载APP，则会提示使用浏览器打开地址\n\t */</span>\n\t<span class=\"hljs-meta\">@Test</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">TestDownloadAppByMicroMessenger</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception</span>&#123;\n\t\tRequestBuilder request = <span class=\"hljs-keyword\">null</span>;\n\t\t<span class=\"hljs-comment\">//构造请求</span>\n\t\trequest = get(<span class=\"hljs-string\">\"/appProducer/downloadApp\"</span>)\n\t\t\t\t.header(<span class=\"hljs-string\">\"user-agent\"</span>, <span class=\"hljs-string\">\"MicroMessenger\"</span>)\n\t\t\t\t.param(<span class=\"hljs-string\">\"appId\"</span>, <span class=\"hljs-string\">\"1001\"</span>); \n\t\t<span class=\"hljs-comment\">//执行请求</span>\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())<span class=\"hljs-comment\">//返回HTTP状态为200</span>\n\t\t        .andExpect(content().string(containsString(<span class=\"hljs-string\">\"选择浏览器打开即可\"</span>)))<span class=\"hljs-comment\">//返回结果中需包含的文字</span>\n\t\t        .andDo(print());<span class=\"hljs-comment\">//打印结果</span>\n\t\t\n\t&#125;\n\t\n\t<span class=\"hljs-comment\">/**\n\t * 用户通过Android扫描下载APP\n\t */</span>\n\t<span class=\"hljs-meta\">@Test</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">TestDownloadAppByAndroid</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception</span>&#123;\n\t\tRequestBuilder request = <span class=\"hljs-keyword\">null</span>;\n\t\t<span class=\"hljs-comment\">//构造请求</span>\n\t\trequest = get(<span class=\"hljs-string\">\"/appProducer/downloadApp\"</span>)\n\t\t\t\t.header(<span class=\"hljs-string\">\"user-agent\"</span>, <span class=\"hljs-string\">\"Android\"</span>)\n\t\t\t\t.param(<span class=\"hljs-string\">\"appId\"</span>, <span class=\"hljs-string\">\"1001\"</span>); \n\t\t<span class=\"hljs-comment\">//执行请求</span>\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())<span class=\"hljs-comment\">//返回HTTP状态为200</span>\n\t\t        .andDo(print());<span class=\"hljs-comment\">//打印结果</span>\n\t\t\n\t&#125;\n\t\n\t<span class=\"hljs-comment\">/**\n\t * 用户通过iPhone扫描下载APP，则会重定向至评苹果APP官网\n\t */</span>\n\t<span class=\"hljs-meta\">@Test</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">TestDownloadAppByIphone</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception</span>&#123;\n\t\tRequestBuilder request = <span class=\"hljs-keyword\">null</span>;\n\t\t<span class=\"hljs-comment\">//构造请求</span>\n\t\trequest = get(<span class=\"hljs-string\">\"/appProducer/downloadApp\"</span>)\n\t\t\t\t.header(<span class=\"hljs-string\">\"user-agent\"</span>, <span class=\"hljs-string\">\"iPhone\"</span>)\n\t\t\t\t.param(<span class=\"hljs-string\">\"appId\"</span>, <span class=\"hljs-string\">\"1001\"</span>); \n\t\t<span class=\"hljs-comment\">//执行请求</span>\n\t\tmockMvc.perform(request) \n\t\t\t\t.andExpect(status().is3xxRedirection())<span class=\"hljs-comment\">//表示页面被重定向</span>\n\t\t\t\t.andExpect(redirectedUrl(<span class=\"hljs-string\">\"https://www.apple.com/cn/itunes/charts/\"</span>))<span class=\"hljs-comment\">//验证处理完请求后重定向的url</span>\n\t\t        .andDo(print());<span class=\"hljs-comment\">//打印结果</span>\n\t\t\n\t&#125;\n\t\n\t<span class=\"hljs-comment\">/**\n\t * 用户通过iPad扫描下载APP，则会重定向至评苹果APP官网\n\t */</span>\n\t<span class=\"hljs-meta\">@Test</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">TestDownloadAppByIPad</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception</span>&#123;\n\t\tRequestBuilder request = <span class=\"hljs-keyword\">null</span>;\n\t\t<span class=\"hljs-comment\">//构造请求</span>\n\t\trequest = get(<span class=\"hljs-string\">\"/appProducer/downloadApp\"</span>)\n\t\t\t\t.header(<span class=\"hljs-string\">\"user-agent\"</span>, <span class=\"hljs-string\">\"iPad\"</span>)\n\t\t\t\t.param(<span class=\"hljs-string\">\"appId\"</span>, <span class=\"hljs-string\">\"1001\"</span>); \n\t\t<span class=\"hljs-comment\">//执行请求</span>\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().is3xxRedirection())<span class=\"hljs-comment\">//表示页面被重定向</span>\n\t\t        .andExpect(redirectedUrl(<span class=\"hljs-string\">\"https://www.apple.com/cn/itunes/charts/\"</span>))<span class=\"hljs-comment\">//验证处理完请求后重定向的url</span>\n\t\t        .andDo(print());<span class=\"hljs-comment\">//打印结果</span>\n\t\t\n\t&#125;\n\t\n\t<span class=\"hljs-comment\">/**\n\t * 用户通过其他方式扫描下载APP，则会提示仅支持的下载方式\n\t */</span>\n\t<span class=\"hljs-meta\">@Test</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">TestDownloadAppByOther</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception</span>&#123;\n\t\tRequestBuilder request = <span class=\"hljs-keyword\">null</span>;\n\t\t<span class=\"hljs-comment\">//构造请求</span>\n\t\trequest = get(<span class=\"hljs-string\">\"/appProducer/downloadApp\"</span>)\n\t\t\t\t.header(<span class=\"hljs-string\">\"user-agent\"</span>, <span class=\"hljs-string\">\"other\"</span>)\n\t\t\t\t.param(<span class=\"hljs-string\">\"appId\"</span>, <span class=\"hljs-string\">\"1001\"</span>); \n\t\t<span class=\"hljs-comment\">//执行请求</span>\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())<span class=\"hljs-comment\">//返回HTTP状态为200</span>\n\t\t        .andExpect(content().string(containsString(<span class=\"hljs-string\">\"&lt;h1&gt;出现该页面可能是以下原因&lt;/h1&gt;\"</span>)))\n\t\t        .andDo(print());<span class=\"hljs-comment\">//打印结果</span>\n\t\t\n\t&#125;\n\t\n\t<span class=\"hljs-comment\">/**\n\t * APP升级\n\t */</span>\n\t<span class=\"hljs-meta\">@Test</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">TestUpgradeApp</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception</span>&#123;\n\t\tRequestBuilder request = <span class=\"hljs-keyword\">null</span>;\n\t\t<span class=\"hljs-comment\">//构造请求</span>\n\t\trequest = get(<span class=\"hljs-string\">\"/appProducer/upgradeApp\"</span>)\n\t\t\t\t.param(<span class=\"hljs-string\">\"appId\"</span>, <span class=\"hljs-string\">\"1001\"</span>); \n\t\t<span class=\"hljs-comment\">//执行请求</span>\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())<span class=\"hljs-comment\">//返回HTTP状态为200</span>\n\t\t        .andDo(print());<span class=\"hljs-comment\">//打印结果</span>\n\t\t\n\t&#125;</code></pre>\n</li>\n</ul>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">controllerTest</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception</span>&#123;\n\n    VoiceData voiceData = <span class=\"hljs-keyword\">new</span> VoiceData();\n    voiceData.setId(<span class=\"hljs-string\">\"123\"</span>);\n    voiceData.setServiceName(<span class=\"hljs-string\">\"jack\"</span>);\n\n    VoiceDataBo voiceDataBo = <span class=\"hljs-keyword\">new</span> VoiceDataBo();\n    voiceDataBo.setCallId(<span class=\"hljs-string\">\"123\"</span>);\n    voiceDataBo.setSeatName(<span class=\"hljs-string\">\"tom\"</span>);\n\n    List dataList = <span class=\"hljs-keyword\">new</span> ArrayList();\n    dataList.add(voiceData);\n\n    <span class=\"hljs-comment\">/*构造一个请求*/</span>\n    RequestBuilder request = <span class=\"hljs-keyword\">null</span>;\n    request = MockMvcRequestBuilders.post(<span class=\"hljs-string\">\"/recordTapImport/voiceData\"</span>)\n            .contentType(MediaType.APPLICATION_JSON).content(JSON.toJSONString(dataList));\n\n    <span class=\"hljs-comment\">/*执行一个请求*/</span>\n    mockMvc.perform(request).andDo(print()).andReturn();\n&#125;</code></pre>\n<ul>\n<li>当发送一个被@ResponceBody标识的参数，遇到400的返回错误。<br>  <code>注意上面contentType需要设置成MediaType.APPLICATION_JSON，即声明是发送“application/json”格式的数据。使用content方法，将转换的json数据放到request的body中。</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SpringBoot单元测试\"><a href=\"#SpringBoot单元测试\" class=\"headerlink\" title=\"SpringBoot单元测试\"></a>SpringBoot单元测试</h1><h2 id=\"Controller层\"><a href=\"#Controller层\" class=\"headerlink\" title=\"Controller层\"></a>Controller层</h2><h3 id=\"登录校验-一般情况不使用\"><a href=\"#登录校验-一般情况不使用\" class=\"headerlink\" title=\"登录校验(一般情况不使用)\"></a>登录校验(一般情况不使用)</h3><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@RunWith</span>(SpringRunner<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)\n@<span class=\"hljs-title\">Transactional</span>//测试结束后<span class=\"hljs-title\">rollback</span>\n@<span class=\"hljs-title\">SpringBootTest</span>\n<span class=\"hljs-title\">public</span> <span class=\"hljs-title\">abstract</span> <span class=\"hljs-title\">class</span> <span class=\"hljs-title\">BaseTest</span> </span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> LoginBean LOGINBEAN;\n    <span class=\"hljs-keyword\">static</span> &#123;\n        LoginBean.Builder builder = <span class=\"hljs-keyword\">new</span> LoginBean.Builder();\n        builder.setAccountID(<span class=\"hljs-string\">\"7f2b815be57541549b7c4cd1e81f2923\"</span>);\n        builder.setCompanyID(<span class=\"hljs-string\">\"08d181119a7b4c0e94ff368942fd4420\"</span>);\n        builder.setLoginName(<span class=\"hljs-string\">\"utry\"</span>);\n        builder.setRealName(<span class=\"hljs-string\">\"远传\"</span>);\n        LOGINBEAN = builder.build();\n        LoginInfo.putSp(LOGINBEAN);\n    &#125;\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">protected</span> ICacheService cache;\n    \n    &#123;\n        init();\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">()</span> </span>&#123;\n        preloadModules();\n        splitMapper();\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">preloadModules</span><span class=\"hljs-params\">()</span> </span>&#123;\n        UtryCloudModuleManager.initModules();\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">splitMapper</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">new</span> MybatisMapperSplitListener(<span class=\"hljs-string\">\"mapper\"</span>).onApplicationEvent(<span class=\"hljs-keyword\">null</span>);\n    &#125;\n\n    <span class=\"hljs-meta\">@Before</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setUp</span><span class=\"hljs-params\">()</span> </span>&#123;\n        LoginInfo.setThreadLocal(cache, LOGINBEAN);\n    &#125;\n&#125;</code></pre>\n<h3 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h3><ul>\n<li><p>测试类注解</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@RunWith</span>(SpringRunner<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)\n@<span class=\"hljs-title\">SpringBootTest</span></span></code></pre>\n</li>\n<li><p>模拟MVC环境注解以及代码</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> MockMVC mockMVC\n<span class=\"hljs-meta\">@Autowired</span>\n<span class=\"hljs-keyword\">private</span> WebApplicationContext webApplicationContext;</code></pre>\n</li>\n<li><p>通过@Before方法，提前准备测试环境</p>\n</li>\n</ul>\n<p><code>注意（此处的MockMvc 实例化是通过手工方式创建，如果想通过spring的bean注入方式的话，在类上加@AutoConfigureMockMvc/@Controller等注解，只要等同于@Component效果即可，然后在上面的第2步中进行注入，即在成员变量mockMvc上加注解@Autowired）</code></p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Before</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setup</span><span class=\"hljs-params\">()</span></span>&#123;\n    <span class=\"hljs-comment\">/*通过bean注入方式\n    mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();\n    */</span>\n\n    <span class=\"hljs-comment\">/*手动指定需要测试controller类*/</span>\n    mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> RecordTapDataImportController()).build();\n&#125;</code></pre>\n<h3 id=\"编写测试方法-Test\"><a href=\"#编写测试方法-Test\" class=\"headerlink\" title=\"编写测试方法@Test\"></a>编写测试方法@Test</h3><ul>\n<li>普通的测试方法<pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**\n     * 获取最新app信息\n     */</span>\n\t<span class=\"hljs-meta\">@Test</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">TestGetAppLatestVersion</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception</span>&#123;\n\t\tRequestBuilder request = <span class=\"hljs-keyword\">null</span>;\n\t\t<span class=\"hljs-comment\">//构造请求</span>\n\t\trequest = post(<span class=\"hljs-string\">\"/appProducer/getAppLatestVersion\"</span>) \n\t\t\t\t.param(<span class=\"hljs-string\">\"appId\"</span>, <span class=\"hljs-string\">\"1001\"</span>); \n\t\t<span class=\"hljs-comment\">//执行请求</span>\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())<span class=\"hljs-comment\">//返回HTTP状态为200</span>\n\t\t        .andExpect(jsonPath(<span class=\"hljs-string\">\"$.status\"</span>, not(<span class=\"hljs-string\">\"E\"</span>)))<span class=\"hljs-comment\">//使用jsonPath解析JSON返回值，判断具体的内容, 此处不希望status返回E</span>\n\t\t        .andDo(print());<span class=\"hljs-comment\">//打印结果</span>\n\t\t        <span class=\"hljs-comment\">//.andReturn();//想要返回结果，使用此方法</span>\n\t\t\n\t&#125;\n\t\n\t<span class=\"hljs-comment\">/**\n\t * 用户通过微信方式扫描下载APP，则会提示使用浏览器打开地址\n\t */</span>\n\t<span class=\"hljs-meta\">@Test</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">TestDownloadAppByMicroMessenger</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception</span>&#123;\n\t\tRequestBuilder request = <span class=\"hljs-keyword\">null</span>;\n\t\t<span class=\"hljs-comment\">//构造请求</span>\n\t\trequest = get(<span class=\"hljs-string\">\"/appProducer/downloadApp\"</span>)\n\t\t\t\t.header(<span class=\"hljs-string\">\"user-agent\"</span>, <span class=\"hljs-string\">\"MicroMessenger\"</span>)\n\t\t\t\t.param(<span class=\"hljs-string\">\"appId\"</span>, <span class=\"hljs-string\">\"1001\"</span>); \n\t\t<span class=\"hljs-comment\">//执行请求</span>\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())<span class=\"hljs-comment\">//返回HTTP状态为200</span>\n\t\t        .andExpect(content().string(containsString(<span class=\"hljs-string\">\"选择浏览器打开即可\"</span>)))<span class=\"hljs-comment\">//返回结果中需包含的文字</span>\n\t\t        .andDo(print());<span class=\"hljs-comment\">//打印结果</span>\n\t\t\n\t&#125;\n\t\n\t<span class=\"hljs-comment\">/**\n\t * 用户通过Android扫描下载APP\n\t */</span>\n\t<span class=\"hljs-meta\">@Test</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">TestDownloadAppByAndroid</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception</span>&#123;\n\t\tRequestBuilder request = <span class=\"hljs-keyword\">null</span>;\n\t\t<span class=\"hljs-comment\">//构造请求</span>\n\t\trequest = get(<span class=\"hljs-string\">\"/appProducer/downloadApp\"</span>)\n\t\t\t\t.header(<span class=\"hljs-string\">\"user-agent\"</span>, <span class=\"hljs-string\">\"Android\"</span>)\n\t\t\t\t.param(<span class=\"hljs-string\">\"appId\"</span>, <span class=\"hljs-string\">\"1001\"</span>); \n\t\t<span class=\"hljs-comment\">//执行请求</span>\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())<span class=\"hljs-comment\">//返回HTTP状态为200</span>\n\t\t        .andDo(print());<span class=\"hljs-comment\">//打印结果</span>\n\t\t\n\t&#125;\n\t\n\t<span class=\"hljs-comment\">/**\n\t * 用户通过iPhone扫描下载APP，则会重定向至评苹果APP官网\n\t */</span>\n\t<span class=\"hljs-meta\">@Test</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">TestDownloadAppByIphone</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception</span>&#123;\n\t\tRequestBuilder request = <span class=\"hljs-keyword\">null</span>;\n\t\t<span class=\"hljs-comment\">//构造请求</span>\n\t\trequest = get(<span class=\"hljs-string\">\"/appProducer/downloadApp\"</span>)\n\t\t\t\t.header(<span class=\"hljs-string\">\"user-agent\"</span>, <span class=\"hljs-string\">\"iPhone\"</span>)\n\t\t\t\t.param(<span class=\"hljs-string\">\"appId\"</span>, <span class=\"hljs-string\">\"1001\"</span>); \n\t\t<span class=\"hljs-comment\">//执行请求</span>\n\t\tmockMvc.perform(request) \n\t\t\t\t.andExpect(status().is3xxRedirection())<span class=\"hljs-comment\">//表示页面被重定向</span>\n\t\t\t\t.andExpect(redirectedUrl(<span class=\"hljs-string\">\"https://www.apple.com/cn/itunes/charts/\"</span>))<span class=\"hljs-comment\">//验证处理完请求后重定向的url</span>\n\t\t        .andDo(print());<span class=\"hljs-comment\">//打印结果</span>\n\t\t\n\t&#125;\n\t\n\t<span class=\"hljs-comment\">/**\n\t * 用户通过iPad扫描下载APP，则会重定向至评苹果APP官网\n\t */</span>\n\t<span class=\"hljs-meta\">@Test</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">TestDownloadAppByIPad</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception</span>&#123;\n\t\tRequestBuilder request = <span class=\"hljs-keyword\">null</span>;\n\t\t<span class=\"hljs-comment\">//构造请求</span>\n\t\trequest = get(<span class=\"hljs-string\">\"/appProducer/downloadApp\"</span>)\n\t\t\t\t.header(<span class=\"hljs-string\">\"user-agent\"</span>, <span class=\"hljs-string\">\"iPad\"</span>)\n\t\t\t\t.param(<span class=\"hljs-string\">\"appId\"</span>, <span class=\"hljs-string\">\"1001\"</span>); \n\t\t<span class=\"hljs-comment\">//执行请求</span>\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().is3xxRedirection())<span class=\"hljs-comment\">//表示页面被重定向</span>\n\t\t        .andExpect(redirectedUrl(<span class=\"hljs-string\">\"https://www.apple.com/cn/itunes/charts/\"</span>))<span class=\"hljs-comment\">//验证处理完请求后重定向的url</span>\n\t\t        .andDo(print());<span class=\"hljs-comment\">//打印结果</span>\n\t\t\n\t&#125;\n\t\n\t<span class=\"hljs-comment\">/**\n\t * 用户通过其他方式扫描下载APP，则会提示仅支持的下载方式\n\t */</span>\n\t<span class=\"hljs-meta\">@Test</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">TestDownloadAppByOther</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception</span>&#123;\n\t\tRequestBuilder request = <span class=\"hljs-keyword\">null</span>;\n\t\t<span class=\"hljs-comment\">//构造请求</span>\n\t\trequest = get(<span class=\"hljs-string\">\"/appProducer/downloadApp\"</span>)\n\t\t\t\t.header(<span class=\"hljs-string\">\"user-agent\"</span>, <span class=\"hljs-string\">\"other\"</span>)\n\t\t\t\t.param(<span class=\"hljs-string\">\"appId\"</span>, <span class=\"hljs-string\">\"1001\"</span>); \n\t\t<span class=\"hljs-comment\">//执行请求</span>\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())<span class=\"hljs-comment\">//返回HTTP状态为200</span>\n\t\t        .andExpect(content().string(containsString(<span class=\"hljs-string\">\"&lt;h1&gt;出现该页面可能是以下原因&lt;/h1&gt;\"</span>)))\n\t\t        .andDo(print());<span class=\"hljs-comment\">//打印结果</span>\n\t\t\n\t&#125;\n\t\n\t<span class=\"hljs-comment\">/**\n\t * APP升级\n\t */</span>\n\t<span class=\"hljs-meta\">@Test</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">TestUpgradeApp</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception</span>&#123;\n\t\tRequestBuilder request = <span class=\"hljs-keyword\">null</span>;\n\t\t<span class=\"hljs-comment\">//构造请求</span>\n\t\trequest = get(<span class=\"hljs-string\">\"/appProducer/upgradeApp\"</span>)\n\t\t\t\t.param(<span class=\"hljs-string\">\"appId\"</span>, <span class=\"hljs-string\">\"1001\"</span>); \n\t\t<span class=\"hljs-comment\">//执行请求</span>\n\t\tmockMvc.perform(request) \n\t\t        .andExpect(status().isOk())<span class=\"hljs-comment\">//返回HTTP状态为200</span>\n\t\t        .andDo(print());<span class=\"hljs-comment\">//打印结果</span>\n\t\t\n\t&#125;</code></pre>\n</li>\n</ul>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">controllerTest</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception</span>&#123;\n\n    VoiceData voiceData = <span class=\"hljs-keyword\">new</span> VoiceData();\n    voiceData.setId(<span class=\"hljs-string\">\"123\"</span>);\n    voiceData.setServiceName(<span class=\"hljs-string\">\"jack\"</span>);\n\n    VoiceDataBo voiceDataBo = <span class=\"hljs-keyword\">new</span> VoiceDataBo();\n    voiceDataBo.setCallId(<span class=\"hljs-string\">\"123\"</span>);\n    voiceDataBo.setSeatName(<span class=\"hljs-string\">\"tom\"</span>);\n\n    List dataList = <span class=\"hljs-keyword\">new</span> ArrayList();\n    dataList.add(voiceData);\n\n    <span class=\"hljs-comment\">/*构造一个请求*/</span>\n    RequestBuilder request = <span class=\"hljs-keyword\">null</span>;\n    request = MockMvcRequestBuilders.post(<span class=\"hljs-string\">\"/recordTapImport/voiceData\"</span>)\n            .contentType(MediaType.APPLICATION_JSON).content(JSON.toJSONString(dataList));\n\n    <span class=\"hljs-comment\">/*执行一个请求*/</span>\n    mockMvc.perform(request).andDo(print()).andReturn();\n&#125;</code></pre>\n<ul>\n<li>当发送一个被@ResponceBody标识的参数，遇到400的返回错误。<br>  <code>注意上面contentType需要设置成MediaType.APPLICATION_JSON，即声明是发送“application/json”格式的数据。使用content方法，将转换的json数据放到request的body中。</code></li>\n</ul>\n"},{"title":"Tomcat开放远程链接权限","date":"2019-05-12T04:53:35.000Z","banner_img":null,"index_img":null,"_content":"\n# Tomcat8及以上版本开放远程连接权限\n\n在使用jenkins进行自动化部署的过程中，发现无法连接到目标的tomcat。经过查阅后整理一下文档：\n\n## 测试权限是否已开放\n\n尝试能否进入容器下的manger地址\n\n\n    http://yourIP:8080/manger\n\n\n\n## 添加一些权限以及一个连接使用的用户\n\n对/usr/local/apache-tomcat-8.5.33/conf文件夹下的tomcat-users.xml进行编辑，添加一下内容：\n\n\n    <role rolename=\"manager\"/>\n    <role rolename=\"manager\"/>\n    <role rolename=\"manager-gui\"/>\n    <role rolename=\"admin\"/>\n    <role rolename=\"admin-gui\"/>\n    <role rolename=\"manager-script\"/>  \n    <user username=\"tomcat\" password=\"tomcat\" roles=\"admin-gui,admin,manager-gui,manager,manager-script\"/>\n\n\n## 配置允许连入的IP\n\n在`/usr/local/apache-tomcat-8.5.33/webapps/manager/META-INF`目录下编辑content.xml文件配置允许连接的ip地址(`将allow值改成\"^.*$\"表示所有ip都可以访问`)：\n\n修改以前：\n\n    <Valve className=\"org.apache.catalina.valves.RemoteAddrValve\" allow=\"127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1\" />\n\n\n修改以后：\n\n\n    <Valve className=\"org.apache.catalina.valves.RemoteAddrValve\"allow=\"^.*$\" />\n\n\n","source":"_posts/Tomcat开放远程链接权限.md","raw":"---\ntitle: Tomcat开放远程链接权限\ndate: 2019-05-12 12:53:35\ncategories:\n- Code\ntags:\n- 运维\n- Tomcat\nbanner_img: \nindex_img: \n---\n\n# Tomcat8及以上版本开放远程连接权限\n\n在使用jenkins进行自动化部署的过程中，发现无法连接到目标的tomcat。经过查阅后整理一下文档：\n\n## 测试权限是否已开放\n\n尝试能否进入容器下的manger地址\n\n\n    http://yourIP:8080/manger\n\n\n\n## 添加一些权限以及一个连接使用的用户\n\n对/usr/local/apache-tomcat-8.5.33/conf文件夹下的tomcat-users.xml进行编辑，添加一下内容：\n\n\n    <role rolename=\"manager\"/>\n    <role rolename=\"manager\"/>\n    <role rolename=\"manager-gui\"/>\n    <role rolename=\"admin\"/>\n    <role rolename=\"admin-gui\"/>\n    <role rolename=\"manager-script\"/>  \n    <user username=\"tomcat\" password=\"tomcat\" roles=\"admin-gui,admin,manager-gui,manager,manager-script\"/>\n\n\n## 配置允许连入的IP\n\n在`/usr/local/apache-tomcat-8.5.33/webapps/manager/META-INF`目录下编辑content.xml文件配置允许连接的ip地址(`将allow值改成\"^.*$\"表示所有ip都可以访问`)：\n\n修改以前：\n\n    <Valve className=\"org.apache.catalina.valves.RemoteAddrValve\" allow=\"127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1\" />\n\n\n修改以后：\n\n\n    <Valve className=\"org.apache.catalina.valves.RemoteAddrValve\"allow=\"^.*$\" />\n\n\n","slug":"Tomcat开放远程链接权限","published":1,"updated":"2019-12-30T06:40:13.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9m4gt7w000bupqefmt4729f","content":"<h1 id=\"Tomcat8及以上版本开放远程连接权限\"><a href=\"#Tomcat8及以上版本开放远程连接权限\" class=\"headerlink\" title=\"Tomcat8及以上版本开放远程连接权限\"></a>Tomcat8及以上版本开放远程连接权限</h1><p>在使用jenkins进行自动化部署的过程中，发现无法连接到目标的tomcat。经过查阅后整理一下文档：</p>\n<h2 id=\"测试权限是否已开放\"><a href=\"#测试权限是否已开放\" class=\"headerlink\" title=\"测试权限是否已开放\"></a>测试权限是否已开放</h2><p>尝试能否进入容器下的manger地址</p>\n<pre><code>http://yourIP:8080/manger\n</code></pre><h2 id=\"添加一些权限以及一个连接使用的用户\"><a href=\"#添加一些权限以及一个连接使用的用户\" class=\"headerlink\" title=\"添加一些权限以及一个连接使用的用户\"></a>添加一些权限以及一个连接使用的用户</h2><p>对/usr/local/apache-tomcat-8.5.33/conf文件夹下的tomcat-users.xml进行编辑，添加一下内容：</p>\n<pre><code>&lt;role rolename=&quot;manager&quot;/&gt;\n&lt;role rolename=&quot;manager&quot;/&gt;\n&lt;role rolename=&quot;manager-gui&quot;/&gt;\n&lt;role rolename=&quot;admin&quot;/&gt;\n&lt;role rolename=&quot;admin-gui&quot;/&gt;\n&lt;role rolename=&quot;manager-script&quot;/&gt;  \n&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;admin-gui,admin,manager-gui,manager,manager-script&quot;/&gt;\n</code></pre><h2 id=\"配置允许连入的IP\"><a href=\"#配置允许连入的IP\" class=\"headerlink\" title=\"配置允许连入的IP\"></a>配置允许连入的IP</h2><p>在<code>/usr/local/apache-tomcat-8.5.33/webapps/manager/META-INF</code>目录下编辑content.xml文件配置允许连接的ip地址(<code>将allow值改成&quot;^.*$&quot;表示所有ip都可以访问</code>)：</p>\n<p>修改以前：</p>\n<pre><code>&lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1&quot; /&gt;\n</code></pre><p>修改以后：</p>\n<pre><code>&lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;allow=&quot;^.*$&quot; /&gt;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Tomcat8及以上版本开放远程连接权限\"><a href=\"#Tomcat8及以上版本开放远程连接权限\" class=\"headerlink\" title=\"Tomcat8及以上版本开放远程连接权限\"></a>Tomcat8及以上版本开放远程连接权限</h1><p>在使用jenkins进行自动化部署的过程中，发现无法连接到目标的tomcat。经过查阅后整理一下文档：</p>\n<h2 id=\"测试权限是否已开放\"><a href=\"#测试权限是否已开放\" class=\"headerlink\" title=\"测试权限是否已开放\"></a>测试权限是否已开放</h2><p>尝试能否进入容器下的manger地址</p>\n<pre><code>http://yourIP:8080/manger\n</code></pre><h2 id=\"添加一些权限以及一个连接使用的用户\"><a href=\"#添加一些权限以及一个连接使用的用户\" class=\"headerlink\" title=\"添加一些权限以及一个连接使用的用户\"></a>添加一些权限以及一个连接使用的用户</h2><p>对/usr/local/apache-tomcat-8.5.33/conf文件夹下的tomcat-users.xml进行编辑，添加一下内容：</p>\n<pre><code>&lt;role rolename=&quot;manager&quot;/&gt;\n&lt;role rolename=&quot;manager&quot;/&gt;\n&lt;role rolename=&quot;manager-gui&quot;/&gt;\n&lt;role rolename=&quot;admin&quot;/&gt;\n&lt;role rolename=&quot;admin-gui&quot;/&gt;\n&lt;role rolename=&quot;manager-script&quot;/&gt;  \n&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;admin-gui,admin,manager-gui,manager,manager-script&quot;/&gt;\n</code></pre><h2 id=\"配置允许连入的IP\"><a href=\"#配置允许连入的IP\" class=\"headerlink\" title=\"配置允许连入的IP\"></a>配置允许连入的IP</h2><p>在<code>/usr/local/apache-tomcat-8.5.33/webapps/manager/META-INF</code>目录下编辑content.xml文件配置允许连接的ip地址(<code>将allow值改成&quot;^.*$&quot;表示所有ip都可以访问</code>)：</p>\n<p>修改以前：</p>\n<pre><code>&lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1&quot; /&gt;\n</code></pre><p>修改以后：</p>\n<pre><code>&lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;allow=&quot;^.*$&quot; /&gt;\n</code></pre>"},{"title":"springMVC项目使用AOP日志记录","date":"2019-07-30T11:08:27.000Z","_content":"# \n","source":"_posts/springMVC项目使用AOP日志记录.md","raw":"---\ntitle: springMVC项目使用AOP日志记录\ndate: 2019-07-30 19:08:27\ntags: \n- SpringMVC\n- AOP\n- 日志处理\n---\n# \n","slug":"springMVC项目使用AOP日志记录","published":1,"updated":"2019-12-30T06:40:13.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9m4gt7y000dupqeqppml485","content":"<p># </p>\n","site":{"data":{}},"excerpt":"","more":"<p># </p>\n"},{"title":"Vuex语法集合","date":"2019-05-11T17:18:04.000Z","banner_img":null,"index_img":null,"_content":"\n# 使用Vuex\n记录了关于vuex的一些简单使用（解决平常毕设以及工作中遇到的问题——刷新单页面导致其中链接到某些的数据的地址丢失）\n\n## State\n用来存储属性，一些公共的数据（`一个页面改变该数据，别的页面引用的该数据也会发生改变`）\n\n\tstate:{ \n\t    products: [\n\t    {name: '鼠标', price: 120},\n\t    {name: '键盘', price: 40},\n\t    {name: '耳机', price: 60},\n\t    {name: '显示屏', price: 80}\n\t    ],\n\t    user: {},\n\t    token: null,\n\t},\n\n使用：\n\n1. 在页面中引入\n\n\n        import testStore from '../store/testStore'\n\n\n2. 在data的相应属性上调用\n\n        data () {\n            return {\n                products: testStore.state.products\n            }\n        },\n\n\n3. 页面上使用\n\n        {{ product.name }}\n\n\n## Getters\n类似Java的get方法，能够通过某种公式或者直接返回值\n\n    getters:{\n        saleProducts: (state) => {\n            let saleProducts = state.products.map(\n                products => {\n                    return{\n                        name: products.name,\n                        price: products.price / 2\n                    }\n                }\n            )\n            return saleProducts;\n        }\n    },\n\n\n\n\n\n\n使用：\n\n1. 在页面中引入\n\n2. 在data的相应属性上调用\n\n        data () {\n                return {\n                    products: testStore.getters.saleProducts\n                }\n            },\n\n\n3. 页面上使用\n\n## Mutations\n类似method方法，保存着更改数据的回调函数`第一个参数是state(应该是定死的), 第二参数是payload, 也就是自定义的参数.`\n\n\tmutations: {\n\t    minusPrice (state,payload) {\n\t        let newPrice = state.products.forEach(\n\t            products =>{\n\t                products.price -= payload\n\t            }\n\t        )\n\t    }\n\t}\n\n使用：\n\n1. 通过commit调用在store中名为`minusPrice`的方法，`2`为自定义参数\n\n\n        testStore.commit('minusPrice',2);\n\n\n2. 可以将它写成一个函数来调用\n\n\n        <button @click=\"minusPrice\">减价2美元</button>\n  \n        methods: {\n            minusPrice(){\n                testStore.commit('minusPrice',2);\n            }\n        }\n\n\n## Actions\nActions 类似于 mutations，不同在于：\n\n- actions提交的是mutations而不是直接变更状态\n- actions中可以包含异步操作, mutations中绝对不允许出现异步\n- actions中的回调函数的第一个参数是context, 是一个与store实例具有相同属性和方法的对象\n- 此时,我们在store中添加actions属性, 其中minusPriceAsync采用setTimeout来模拟异步操作,延迟2s执行 该方法用于异步改变我们刚才在mutaions中定义的minusPrice\n\n`个人见解：action是一个调用mutations里面的方法的一个方法`\n\n\n\tactions:{\n\t    minusPriceAsync(context, payload){\n\t        setTimeout(\n\t            ()=>{\n\t                context.commit('minusPrice',payload);\n\t            },2000\n\t        )\n\t    }\n\t}\n\n使用：\n\n1. 通过dispatch调用在store中名为`minusPrice`的方法\n\n\n        testStore.dispatch('minusPriceAsync',5);\n\n\n2. 可以将它写成一个函数来调用\n\n        <button @click=\"minusPriceAsync\">减价5美元</button>\n  \n\n        methods: {\n            minusPriceAsync(){\n                testStore.dispatch('minusPriceAsync',5);\n            }\n        }\n\n","source":"_posts/Vuex语法集合.md","raw":"---\ntitle: Vuex语法集合\ndate: 2019-05-12 01:18:04\ncategories:\n- Code\ntags:\n- 前端\n- Vue\nbanner_img: \nindex_img: \n---\n\n# 使用Vuex\n记录了关于vuex的一些简单使用（解决平常毕设以及工作中遇到的问题——刷新单页面导致其中链接到某些的数据的地址丢失）\n\n## State\n用来存储属性，一些公共的数据（`一个页面改变该数据，别的页面引用的该数据也会发生改变`）\n\n\tstate:{ \n\t    products: [\n\t    {name: '鼠标', price: 120},\n\t    {name: '键盘', price: 40},\n\t    {name: '耳机', price: 60},\n\t    {name: '显示屏', price: 80}\n\t    ],\n\t    user: {},\n\t    token: null,\n\t},\n\n使用：\n\n1. 在页面中引入\n\n\n        import testStore from '../store/testStore'\n\n\n2. 在data的相应属性上调用\n\n        data () {\n            return {\n                products: testStore.state.products\n            }\n        },\n\n\n3. 页面上使用\n\n        {{ product.name }}\n\n\n## Getters\n类似Java的get方法，能够通过某种公式或者直接返回值\n\n    getters:{\n        saleProducts: (state) => {\n            let saleProducts = state.products.map(\n                products => {\n                    return{\n                        name: products.name,\n                        price: products.price / 2\n                    }\n                }\n            )\n            return saleProducts;\n        }\n    },\n\n\n\n\n\n\n使用：\n\n1. 在页面中引入\n\n2. 在data的相应属性上调用\n\n        data () {\n                return {\n                    products: testStore.getters.saleProducts\n                }\n            },\n\n\n3. 页面上使用\n\n## Mutations\n类似method方法，保存着更改数据的回调函数`第一个参数是state(应该是定死的), 第二参数是payload, 也就是自定义的参数.`\n\n\tmutations: {\n\t    minusPrice (state,payload) {\n\t        let newPrice = state.products.forEach(\n\t            products =>{\n\t                products.price -= payload\n\t            }\n\t        )\n\t    }\n\t}\n\n使用：\n\n1. 通过commit调用在store中名为`minusPrice`的方法，`2`为自定义参数\n\n\n        testStore.commit('minusPrice',2);\n\n\n2. 可以将它写成一个函数来调用\n\n\n        <button @click=\"minusPrice\">减价2美元</button>\n  \n        methods: {\n            minusPrice(){\n                testStore.commit('minusPrice',2);\n            }\n        }\n\n\n## Actions\nActions 类似于 mutations，不同在于：\n\n- actions提交的是mutations而不是直接变更状态\n- actions中可以包含异步操作, mutations中绝对不允许出现异步\n- actions中的回调函数的第一个参数是context, 是一个与store实例具有相同属性和方法的对象\n- 此时,我们在store中添加actions属性, 其中minusPriceAsync采用setTimeout来模拟异步操作,延迟2s执行 该方法用于异步改变我们刚才在mutaions中定义的minusPrice\n\n`个人见解：action是一个调用mutations里面的方法的一个方法`\n\n\n\tactions:{\n\t    minusPriceAsync(context, payload){\n\t        setTimeout(\n\t            ()=>{\n\t                context.commit('minusPrice',payload);\n\t            },2000\n\t        )\n\t    }\n\t}\n\n使用：\n\n1. 通过dispatch调用在store中名为`minusPrice`的方法\n\n\n        testStore.dispatch('minusPriceAsync',5);\n\n\n2. 可以将它写成一个函数来调用\n\n        <button @click=\"minusPriceAsync\">减价5美元</button>\n  \n\n        methods: {\n            minusPriceAsync(){\n                testStore.dispatch('minusPriceAsync',5);\n            }\n        }\n\n","slug":"Vuex语法集合","published":1,"updated":"2019-12-30T06:40:13.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9m4gt7z000hupqejngo799l","content":"<h1 id=\"使用Vuex\"><a href=\"#使用Vuex\" class=\"headerlink\" title=\"使用Vuex\"></a>使用Vuex</h1><p>记录了关于vuex的一些简单使用（解决平常毕设以及工作中遇到的问题——刷新单页面导致其中链接到某些的数据的地址丢失）</p>\n<h2 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h2><p>用来存储属性，一些公共的数据（<code>一个页面改变该数据，别的页面引用的该数据也会发生改变</code>）</p>\n<pre><code>state:{ \n    products: [\n    {name: &apos;鼠标&apos;, price: 120},\n    {name: &apos;键盘&apos;, price: 40},\n    {name: &apos;耳机&apos;, price: 60},\n    {name: &apos;显示屏&apos;, price: 80}\n    ],\n    user: {},\n    token: null,\n},\n</code></pre><p>使用：</p>\n<ol>\n<li>在页面中引入</li>\n</ol>\n<pre><code>import testStore from &apos;../store/testStore&apos;\n</code></pre><ol start=\"2\">\n<li><p>在data的相应属性上调用</p>\n<pre><code>data () {\n    return {\n        products: testStore.state.products\n    }\n},\n</code></pre></li>\n</ol>\n<ol start=\"3\">\n<li><p>页面上使用</p>\n<pre><code>{{ product.name }}\n</code></pre></li>\n</ol>\n<h2 id=\"Getters\"><a href=\"#Getters\" class=\"headerlink\" title=\"Getters\"></a>Getters</h2><p>类似Java的get方法，能够通过某种公式或者直接返回值</p>\n<pre><code>getters:{\n    saleProducts: (state) =&gt; {\n        let saleProducts = state.products.map(\n            products =&gt; {\n                return{\n                    name: products.name,\n                    price: products.price / 2\n                }\n            }\n        )\n        return saleProducts;\n    }\n},\n</code></pre><p>使用：</p>\n<ol>\n<li><p>在页面中引入</p>\n</li>\n<li><p>在data的相应属性上调用</p>\n<pre><code>data () {\n        return {\n            products: testStore.getters.saleProducts\n        }\n    },\n</code></pre></li>\n</ol>\n<ol start=\"3\">\n<li>页面上使用</li>\n</ol>\n<h2 id=\"Mutations\"><a href=\"#Mutations\" class=\"headerlink\" title=\"Mutations\"></a>Mutations</h2><p>类似method方法，保存着更改数据的回调函数<code>第一个参数是state(应该是定死的), 第二参数是payload, 也就是自定义的参数.</code></p>\n<pre><code>mutations: {\n    minusPrice (state,payload) {\n        let newPrice = state.products.forEach(\n            products =&gt;{\n                products.price -= payload\n            }\n        )\n    }\n}\n</code></pre><p>使用：</p>\n<ol>\n<li>通过commit调用在store中名为<code>minusPrice</code>的方法，<code>2</code>为自定义参数</li>\n</ol>\n<pre><code>testStore.commit(&apos;minusPrice&apos;,2);\n</code></pre><ol start=\"2\">\n<li>可以将它写成一个函数来调用</li>\n</ol>\n<pre><code>&lt;button @click=&quot;minusPrice&quot;&gt;减价2美元&lt;/button&gt;\n\nmethods: {\n    minusPrice(){\n        testStore.commit(&apos;minusPrice&apos;,2);\n    }\n}\n</code></pre><h2 id=\"Actions\"><a href=\"#Actions\" class=\"headerlink\" title=\"Actions\"></a>Actions</h2><p>Actions 类似于 mutations，不同在于：</p>\n<ul>\n<li>actions提交的是mutations而不是直接变更状态</li>\n<li>actions中可以包含异步操作, mutations中绝对不允许出现异步</li>\n<li>actions中的回调函数的第一个参数是context, 是一个与store实例具有相同属性和方法的对象</li>\n<li>此时,我们在store中添加actions属性, 其中minusPriceAsync采用setTimeout来模拟异步操作,延迟2s执行 该方法用于异步改变我们刚才在mutaions中定义的minusPrice</li>\n</ul>\n<p><code>个人见解：action是一个调用mutations里面的方法的一个方法</code></p>\n<pre><code>actions:{\n    minusPriceAsync(context, payload){\n        setTimeout(\n            ()=&gt;{\n                context.commit(&apos;minusPrice&apos;,payload);\n            },2000\n        )\n    }\n}\n</code></pre><p>使用：</p>\n<ol>\n<li>通过dispatch调用在store中名为<code>minusPrice</code>的方法</li>\n</ol>\n<pre><code>testStore.dispatch(&apos;minusPriceAsync&apos;,5);\n</code></pre><ol start=\"2\">\n<li><p>可以将它写成一个函数来调用</p>\n<pre><code>&lt;button @click=&quot;minusPriceAsync&quot;&gt;减价5美元&lt;/button&gt;\n</code></pre></li>\n</ol>\n<pre><code>methods: {\n    minusPriceAsync(){\n        testStore.dispatch(&apos;minusPriceAsync&apos;,5);\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用Vuex\"><a href=\"#使用Vuex\" class=\"headerlink\" title=\"使用Vuex\"></a>使用Vuex</h1><p>记录了关于vuex的一些简单使用（解决平常毕设以及工作中遇到的问题——刷新单页面导致其中链接到某些的数据的地址丢失）</p>\n<h2 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h2><p>用来存储属性，一些公共的数据（<code>一个页面改变该数据，别的页面引用的该数据也会发生改变</code>）</p>\n<pre><code>state:{ \n    products: [\n    {name: &apos;鼠标&apos;, price: 120},\n    {name: &apos;键盘&apos;, price: 40},\n    {name: &apos;耳机&apos;, price: 60},\n    {name: &apos;显示屏&apos;, price: 80}\n    ],\n    user: {},\n    token: null,\n},\n</code></pre><p>使用：</p>\n<ol>\n<li>在页面中引入</li>\n</ol>\n<pre><code>import testStore from &apos;../store/testStore&apos;\n</code></pre><ol start=\"2\">\n<li><p>在data的相应属性上调用</p>\n<pre><code>data () {\n    return {\n        products: testStore.state.products\n    }\n},\n</code></pre></li>\n</ol>\n<ol start=\"3\">\n<li><p>页面上使用</p>\n<pre><code>{{ product.name }}\n</code></pre></li>\n</ol>\n<h2 id=\"Getters\"><a href=\"#Getters\" class=\"headerlink\" title=\"Getters\"></a>Getters</h2><p>类似Java的get方法，能够通过某种公式或者直接返回值</p>\n<pre><code>getters:{\n    saleProducts: (state) =&gt; {\n        let saleProducts = state.products.map(\n            products =&gt; {\n                return{\n                    name: products.name,\n                    price: products.price / 2\n                }\n            }\n        )\n        return saleProducts;\n    }\n},\n</code></pre><p>使用：</p>\n<ol>\n<li><p>在页面中引入</p>\n</li>\n<li><p>在data的相应属性上调用</p>\n<pre><code>data () {\n        return {\n            products: testStore.getters.saleProducts\n        }\n    },\n</code></pre></li>\n</ol>\n<ol start=\"3\">\n<li>页面上使用</li>\n</ol>\n<h2 id=\"Mutations\"><a href=\"#Mutations\" class=\"headerlink\" title=\"Mutations\"></a>Mutations</h2><p>类似method方法，保存着更改数据的回调函数<code>第一个参数是state(应该是定死的), 第二参数是payload, 也就是自定义的参数.</code></p>\n<pre><code>mutations: {\n    minusPrice (state,payload) {\n        let newPrice = state.products.forEach(\n            products =&gt;{\n                products.price -= payload\n            }\n        )\n    }\n}\n</code></pre><p>使用：</p>\n<ol>\n<li>通过commit调用在store中名为<code>minusPrice</code>的方法，<code>2</code>为自定义参数</li>\n</ol>\n<pre><code>testStore.commit(&apos;minusPrice&apos;,2);\n</code></pre><ol start=\"2\">\n<li>可以将它写成一个函数来调用</li>\n</ol>\n<pre><code>&lt;button @click=&quot;minusPrice&quot;&gt;减价2美元&lt;/button&gt;\n\nmethods: {\n    minusPrice(){\n        testStore.commit(&apos;minusPrice&apos;,2);\n    }\n}\n</code></pre><h2 id=\"Actions\"><a href=\"#Actions\" class=\"headerlink\" title=\"Actions\"></a>Actions</h2><p>Actions 类似于 mutations，不同在于：</p>\n<ul>\n<li>actions提交的是mutations而不是直接变更状态</li>\n<li>actions中可以包含异步操作, mutations中绝对不允许出现异步</li>\n<li>actions中的回调函数的第一个参数是context, 是一个与store实例具有相同属性和方法的对象</li>\n<li>此时,我们在store中添加actions属性, 其中minusPriceAsync采用setTimeout来模拟异步操作,延迟2s执行 该方法用于异步改变我们刚才在mutaions中定义的minusPrice</li>\n</ul>\n<p><code>个人见解：action是一个调用mutations里面的方法的一个方法</code></p>\n<pre><code>actions:{\n    minusPriceAsync(context, payload){\n        setTimeout(\n            ()=&gt;{\n                context.commit(&apos;minusPrice&apos;,payload);\n            },2000\n        )\n    }\n}\n</code></pre><p>使用：</p>\n<ol>\n<li>通过dispatch调用在store中名为<code>minusPrice</code>的方法</li>\n</ol>\n<pre><code>testStore.dispatch(&apos;minusPriceAsync&apos;,5);\n</code></pre><ol start=\"2\">\n<li><p>可以将它写成一个函数来调用</p>\n<pre><code>&lt;button @click=&quot;minusPriceAsync&quot;&gt;减价5美元&lt;/button&gt;\n</code></pre></li>\n</ol>\n<pre><code>methods: {\n    minusPriceAsync(){\n        testStore.dispatch(&apos;minusPriceAsync&apos;,5);\n    }\n}\n</code></pre>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n\n    $ hexo new \"My New Post\"\n\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n\n    $ hexo server\n\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n\n    $ hexo generate\n\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n\n    $ hexo deploy\n\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n\n    $ hexo new \"My New Post\"\n\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n\n    $ hexo server\n\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n\n    $ hexo generate\n\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n\n    $ hexo deploy\n\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n","slug":"hello-world","published":1,"date":"2019-12-30T06:40:13.313Z","updated":"2019-12-30T06:40:13.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9m4gt80000iupqeyl8ffih6","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code>$ hexo new &quot;My New Post&quot;\n</code></pre><p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code>$ hexo server\n</code></pre><p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code>$ hexo generate\n</code></pre><p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code>$ hexo deploy\n</code></pre><p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code>$ hexo new &quot;My New Post&quot;\n</code></pre><p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code>$ hexo server\n</code></pre><p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code>$ hexo generate\n</code></pre><p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code>$ hexo deploy\n</code></pre><p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"云服务器加快Tomcat启动速度","date":"2019-05-28T08:31:42.000Z","_content":"解决阿里云服务器上的Tomcat启动巨慢的问题\n<!-- more -->\n### 配置\n- 阿里云学生套餐\n- Tomcat8.0\n- CentOS7\n\n### 问题现象\n- 启动过程会停留在：\n`Deplopying web application directory...`\n需要等待很久才能完成\n\n### 问题分析\n- 借助strace工具（跟踪系统调用），利用代码`strace -f -o strace.out ./catalina.sh run`\n- 分析过程请参照 [原文](https://www.jianshu.com/p/576d356dc163)\n\n### 主要原因\n- Tocmat在启动过程中的Session ID是通过SHA1算法计算得到的，计算Session ID的时候必须有一个密钥。\n- 为了提高安全性Tomcat在启动的时候回通过随机生成一个密钥。\n- 而随机数的生成是通过/dev/random（Linux下的随机函数生成器）来实现的。\n- 然而，/dev/random会根据噪音产生随机数，如果噪音不够它就会阻塞。Linux是通过I/O，键盘终端、内存使用量、CPU利用率等方式来收集噪音的，如果噪音不够生成随机数的时候就会被阻塞。（源自wiki百科）\n\n### 解决方案\n- `用伪随机函数生成器(/dev/urandom)来替代随机函数生成器(/dev/random)`，可以有一下两种办法：\n    1. 通过修改JRE中的java.security（/usr/java/jdk1.8.0_121/jre/lib/security/java.security）文件securerandom.source=file:/dev/urandom\n    2. java程序启动参数中添加：-Djava.security.egd=file:/dev/urandom，使用/dev/urandom生成随机数。\n\n- `增大/dev/random的熵池`\n    - 通过cat /proc/sys/kernel/random/entropy_avail我们可以查看现在的熵池大小\n    - 通过at /proc/cpuinfo | grep rdrand查看CPU是否支持DRNG特性\n    - 1. 支持DRNG特性：\n        \n                yum install rngd-tools（yum install rng-tools）\n                /*安装rngd服务（熵服务）*/\n                systemctl start rngd\n\n    - 2. 不支持DRNG特性或者使用虚拟机，可以使用/dev/unrandom来模拟：\n\n                cp /usr/lib/systemd/system/rngd.service /etc/systemd/system\n                编辑/etc/systemd/system/rngd.service\n                修改ExecStart参数为/sbin/rngd -f -r /dev/urandom\n                systemctl daemon-reload\n                重新载入服务\n                systemctl restart rngd\n                重启服务\n\n    - 再次查看熵池大小，可以利用watch -n 1 cat /proc/sys/kernel/random/entropy_avail测试随机数生成速度\n","source":"_posts/云服务器Tomcat启动加速.md","raw":"---\ntitle: 云服务器加快Tomcat启动速度\ndate: 2019-05-28 16:31:42\ntags:\n- Tomcat\n- 运维\n- 云服务器\n---\n解决阿里云服务器上的Tomcat启动巨慢的问题\n<!-- more -->\n### 配置\n- 阿里云学生套餐\n- Tomcat8.0\n- CentOS7\n\n### 问题现象\n- 启动过程会停留在：\n`Deplopying web application directory...`\n需要等待很久才能完成\n\n### 问题分析\n- 借助strace工具（跟踪系统调用），利用代码`strace -f -o strace.out ./catalina.sh run`\n- 分析过程请参照 [原文](https://www.jianshu.com/p/576d356dc163)\n\n### 主要原因\n- Tocmat在启动过程中的Session ID是通过SHA1算法计算得到的，计算Session ID的时候必须有一个密钥。\n- 为了提高安全性Tomcat在启动的时候回通过随机生成一个密钥。\n- 而随机数的生成是通过/dev/random（Linux下的随机函数生成器）来实现的。\n- 然而，/dev/random会根据噪音产生随机数，如果噪音不够它就会阻塞。Linux是通过I/O，键盘终端、内存使用量、CPU利用率等方式来收集噪音的，如果噪音不够生成随机数的时候就会被阻塞。（源自wiki百科）\n\n### 解决方案\n- `用伪随机函数生成器(/dev/urandom)来替代随机函数生成器(/dev/random)`，可以有一下两种办法：\n    1. 通过修改JRE中的java.security（/usr/java/jdk1.8.0_121/jre/lib/security/java.security）文件securerandom.source=file:/dev/urandom\n    2. java程序启动参数中添加：-Djava.security.egd=file:/dev/urandom，使用/dev/urandom生成随机数。\n\n- `增大/dev/random的熵池`\n    - 通过cat /proc/sys/kernel/random/entropy_avail我们可以查看现在的熵池大小\n    - 通过at /proc/cpuinfo | grep rdrand查看CPU是否支持DRNG特性\n    - 1. 支持DRNG特性：\n        \n                yum install rngd-tools（yum install rng-tools）\n                /*安装rngd服务（熵服务）*/\n                systemctl start rngd\n\n    - 2. 不支持DRNG特性或者使用虚拟机，可以使用/dev/unrandom来模拟：\n\n                cp /usr/lib/systemd/system/rngd.service /etc/systemd/system\n                编辑/etc/systemd/system/rngd.service\n                修改ExecStart参数为/sbin/rngd -f -r /dev/urandom\n                systemctl daemon-reload\n                重新载入服务\n                systemctl restart rngd\n                重启服务\n\n    - 再次查看熵池大小，可以利用watch -n 1 cat /proc/sys/kernel/random/entropy_avail测试随机数生成速度\n","slug":"云服务器Tomcat启动加速","published":1,"updated":"2019-12-30T06:40:13.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9m4gt82000kupqe3hxnt6bi","content":"<p>解决阿里云服务器上的Tomcat启动巨慢的问题<br><a id=\"more\"></a></p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><ul>\n<li>阿里云学生套餐</li>\n<li>Tomcat8.0</li>\n<li>CentOS7</li>\n</ul>\n<h3 id=\"问题现象\"><a href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"></a>问题现象</h3><ul>\n<li>启动过程会停留在：<br><code>Deplopying web application directory...</code><br>需要等待很久才能完成</li>\n</ul>\n<h3 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h3><ul>\n<li>借助strace工具（跟踪系统调用），利用代码<code>strace -f -o strace.out ./catalina.sh run</code></li>\n<li>分析过程请参照 <a href=\"https://www.jianshu.com/p/576d356dc163\" target=\"_blank\" rel=\"noopener\">原文</a></li>\n</ul>\n<h3 id=\"主要原因\"><a href=\"#主要原因\" class=\"headerlink\" title=\"主要原因\"></a>主要原因</h3><ul>\n<li>Tocmat在启动过程中的Session ID是通过SHA1算法计算得到的，计算Session ID的时候必须有一个密钥。</li>\n<li>为了提高安全性Tomcat在启动的时候回通过随机生成一个密钥。</li>\n<li>而随机数的生成是通过/dev/random（Linux下的随机函数生成器）来实现的。</li>\n<li>然而，/dev/random会根据噪音产生随机数，如果噪音不够它就会阻塞。Linux是通过I/O，键盘终端、内存使用量、CPU利用率等方式来收集噪音的，如果噪音不够生成随机数的时候就会被阻塞。（源自wiki百科）</li>\n</ul>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><ul>\n<li><p><code>用伪随机函数生成器(/dev/urandom)来替代随机函数生成器(/dev/random)</code>，可以有一下两种办法：</p>\n<ol>\n<li>通过修改JRE中的java.security（/usr/java/jdk1.8.0_121/jre/lib/security/java.security）文件securerandom.source=file:/dev/urandom</li>\n<li>java程序启动参数中添加：-Djava.security.egd=file:/dev/urandom，使用/dev/urandom生成随机数。</li>\n</ol>\n</li>\n<li><p><code>增大/dev/random的熵池</code></p>\n<ul>\n<li>通过cat /proc/sys/kernel/random/entropy_avail我们可以查看现在的熵池大小</li>\n<li>通过at /proc/cpuinfo | grep rdrand查看CPU是否支持DRNG特性</li>\n<li><ol>\n<li><p>支持DRNG特性：</p>\n<pre><code>yum install rngd-tools（yum install rng-tools）\n/*安装rngd服务（熵服务）*/\nsystemctl start rngd\n</code></pre></li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li><p>不支持DRNG特性或者使用虚拟机，可以使用/dev/unrandom来模拟：</p>\n<pre><code>cp /usr/lib/systemd/system/rngd.service /etc/systemd/system\n编辑/etc/systemd/system/rngd.service\n修改ExecStart参数为/sbin/rngd -f -r /dev/urandom\nsystemctl daemon-reload\n重新载入服务\nsystemctl restart rngd\n重启服务\n</code></pre></li>\n</ol>\n</li>\n<li><p>再次查看熵池大小，可以利用watch -n 1 cat /proc/sys/kernel/random/entropy_avail测试随机数生成速度</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>解决阿里云服务器上的Tomcat启动巨慢的问题<br>","more":"</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><ul>\n<li>阿里云学生套餐</li>\n<li>Tomcat8.0</li>\n<li>CentOS7</li>\n</ul>\n<h3 id=\"问题现象\"><a href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"></a>问题现象</h3><ul>\n<li>启动过程会停留在：<br><code>Deplopying web application directory...</code><br>需要等待很久才能完成</li>\n</ul>\n<h3 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h3><ul>\n<li>借助strace工具（跟踪系统调用），利用代码<code>strace -f -o strace.out ./catalina.sh run</code></li>\n<li>分析过程请参照 <a href=\"https://www.jianshu.com/p/576d356dc163\" target=\"_blank\" rel=\"noopener\">原文</a></li>\n</ul>\n<h3 id=\"主要原因\"><a href=\"#主要原因\" class=\"headerlink\" title=\"主要原因\"></a>主要原因</h3><ul>\n<li>Tocmat在启动过程中的Session ID是通过SHA1算法计算得到的，计算Session ID的时候必须有一个密钥。</li>\n<li>为了提高安全性Tomcat在启动的时候回通过随机生成一个密钥。</li>\n<li>而随机数的生成是通过/dev/random（Linux下的随机函数生成器）来实现的。</li>\n<li>然而，/dev/random会根据噪音产生随机数，如果噪音不够它就会阻塞。Linux是通过I/O，键盘终端、内存使用量、CPU利用率等方式来收集噪音的，如果噪音不够生成随机数的时候就会被阻塞。（源自wiki百科）</li>\n</ul>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><ul>\n<li><p><code>用伪随机函数生成器(/dev/urandom)来替代随机函数生成器(/dev/random)</code>，可以有一下两种办法：</p>\n<ol>\n<li>通过修改JRE中的java.security（/usr/java/jdk1.8.0_121/jre/lib/security/java.security）文件securerandom.source=file:/dev/urandom</li>\n<li>java程序启动参数中添加：-Djava.security.egd=file:/dev/urandom，使用/dev/urandom生成随机数。</li>\n</ol>\n</li>\n<li><p><code>增大/dev/random的熵池</code></p>\n<ul>\n<li>通过cat /proc/sys/kernel/random/entropy_avail我们可以查看现在的熵池大小</li>\n<li>通过at /proc/cpuinfo | grep rdrand查看CPU是否支持DRNG特性</li>\n<li><ol>\n<li><p>支持DRNG特性：</p>\n<pre><code>yum install rngd-tools（yum install rng-tools）\n/*安装rngd服务（熵服务）*/\nsystemctl start rngd\n</code></pre></li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li><p>不支持DRNG特性或者使用虚拟机，可以使用/dev/unrandom来模拟：</p>\n<pre><code>cp /usr/lib/systemd/system/rngd.service /etc/systemd/system\n编辑/etc/systemd/system/rngd.service\n修改ExecStart参数为/sbin/rngd -f -r /dev/urandom\nsystemctl daemon-reload\n重新载入服务\nsystemctl restart rngd\n重启服务\n</code></pre></li>\n</ol>\n</li>\n<li><p>再次查看熵池大小，可以利用watch -n 1 cat /proc/sys/kernel/random/entropy_avail测试随机数生成速度</p>\n</li>\n</ul>\n</li>\n</ul>"},{"title":"Tomcat进程守护脚本","date":"2020-02-24T05:46:30.000Z","_content":"# Tomcat进程守护脚本\n\n迫于公司测试服务器上的几个子站经常时不时的挂掉，又查不明原因。\n谷歌了以后说要把jdbc移出来放到tomcat的lib目录下，让tomcat进行管理。可是怎么实验都没有，恰巧正式服务器上的进程又是好的，于是，有了一下的进程守护脚本。\n\n## 使用环境\n- 操作系统:CentOS7.2\n- JDK版本:Java HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode)\n- Tomcat版本:apache-tomcat-7.0.70\n\n## 监控脚本\n\n\t#!/bin/bash\n\t#\n\t# mail：zhouhaibin@utry.cn\n\t# 定时检查tomcat状态\n\t# 当在进程中查询不到该tomcat则进行重启\n\t# \n\t# 需要添加至定时任务crontab中\n\t# 1. crontab -e\n\t# 2. */3 * * * * \"/home/test/deamon2tomcat.sh\" > /dev/null 2>&1\n\t# 注：每3分钟检查一次(可修改)，加“> /dev/null 2>&1 ”是为了不让它发邮件。\n\n\texport PATH=$PATH:/sbin:/bin:/usr/sbin:/usr/bin;\n\ttomcat_base_dir=\"/home/tomservices\";\n\tlog_file=\"/home/tomservices/tomcat_protect_log.log\";\n\td=$(date +%F\" \"%T);\n\n\t# 初始化日志文件\n\ttouch ${log_file}\n\n\tdo_restart_tomcat() {\n\t\t# 不管是否再运行中先关闭服务\n\t\t${tomcat_base_dir}/$1/bin/shutdown.sh\n\t\t\n\t\t# 在进程中检查当前当tomcat是否正在运行并杀死该进程（为了防止shotdown.sh失败）\n\t\tif ps -ef | grep $1 | grep -v grep\n\t\tthen\n\t\t\tkill -9 $(ps -ef | grep $1 | grep -v grep | awk '{print $2}')\n\t\tfi\n\t\t\n\t\t# 重启tomcat\n\t\t${tomcat_base_dir}/$1/bin/startup.sh\n\t\t# 输出进程号\n\t\techo \"$d success restart $1, the new pid is \" >> ${log_file}\n\t\tps -ef | grep $1 | grep -v grep | awk '{print $2}' >> ${log_file}\n\t\techo >> ${log_file}\n\t}\n\n\techo \"$d start check the three server:\" >> ${log_file}\n\t# 循环检查一下三个子站\b是否正在运行并输出相应日志\n\tfor n in \"tomcat_devback\" \"tomcat_hsipccweb\" \"tomcat_ccweb\"\n\tdo\n\techo \"$d checking the $n...\" >> ${log_file}\n\t\tif ps -ef | grep $n | grep -v grep\n\t\tthen\n\t\t\techo \"$d finished the check of the $n\" >> ${log_file}\n\t\telse\n\t\t\techo \"$d can not found $n, try to restart it ......\" >> ${log_file}\n\t\t\tdo_restart_tomcat $n\n\t\tfi\n\tdone\n\n## 加入定时任务crontab\n### 编辑任务\n```\ncrontab -e\n```\n进入编辑crontab的vi界面，按i键进入插入模式，将如下代码复制到输入界面\n```\n*/20 * * * * \"/home/test/deamon2tomcat.sh\" > /dev/null 2>&1\n```\n`注：每20分钟检查一次(可修改)，加“> /dev/null 2>&1 ”是为了不让它发邮件。`\n### 保存退出\n### 查看任务\n最后查看任务，确认是否编辑成功。\n```\ncrontab -l\n```\n","source":"_posts/Tomcat进程守护脚本.md","raw":"---\ntitle: Tomcat进程守护脚本\ndate: 2020-02-24 13:46:30\ntags: \n- TOMCAT \n- SHELL\n---\n# Tomcat进程守护脚本\n\n迫于公司测试服务器上的几个子站经常时不时的挂掉，又查不明原因。\n谷歌了以后说要把jdbc移出来放到tomcat的lib目录下，让tomcat进行管理。可是怎么实验都没有，恰巧正式服务器上的进程又是好的，于是，有了一下的进程守护脚本。\n\n## 使用环境\n- 操作系统:CentOS7.2\n- JDK版本:Java HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode)\n- Tomcat版本:apache-tomcat-7.0.70\n\n## 监控脚本\n\n\t#!/bin/bash\n\t#\n\t# mail：zhouhaibin@utry.cn\n\t# 定时检查tomcat状态\n\t# 当在进程中查询不到该tomcat则进行重启\n\t# \n\t# 需要添加至定时任务crontab中\n\t# 1. crontab -e\n\t# 2. */3 * * * * \"/home/test/deamon2tomcat.sh\" > /dev/null 2>&1\n\t# 注：每3分钟检查一次(可修改)，加“> /dev/null 2>&1 ”是为了不让它发邮件。\n\n\texport PATH=$PATH:/sbin:/bin:/usr/sbin:/usr/bin;\n\ttomcat_base_dir=\"/home/tomservices\";\n\tlog_file=\"/home/tomservices/tomcat_protect_log.log\";\n\td=$(date +%F\" \"%T);\n\n\t# 初始化日志文件\n\ttouch ${log_file}\n\n\tdo_restart_tomcat() {\n\t\t# 不管是否再运行中先关闭服务\n\t\t${tomcat_base_dir}/$1/bin/shutdown.sh\n\t\t\n\t\t# 在进程中检查当前当tomcat是否正在运行并杀死该进程（为了防止shotdown.sh失败）\n\t\tif ps -ef | grep $1 | grep -v grep\n\t\tthen\n\t\t\tkill -9 $(ps -ef | grep $1 | grep -v grep | awk '{print $2}')\n\t\tfi\n\t\t\n\t\t# 重启tomcat\n\t\t${tomcat_base_dir}/$1/bin/startup.sh\n\t\t# 输出进程号\n\t\techo \"$d success restart $1, the new pid is \" >> ${log_file}\n\t\tps -ef | grep $1 | grep -v grep | awk '{print $2}' >> ${log_file}\n\t\techo >> ${log_file}\n\t}\n\n\techo \"$d start check the three server:\" >> ${log_file}\n\t# 循环检查一下三个子站\b是否正在运行并输出相应日志\n\tfor n in \"tomcat_devback\" \"tomcat_hsipccweb\" \"tomcat_ccweb\"\n\tdo\n\techo \"$d checking the $n...\" >> ${log_file}\n\t\tif ps -ef | grep $n | grep -v grep\n\t\tthen\n\t\t\techo \"$d finished the check of the $n\" >> ${log_file}\n\t\telse\n\t\t\techo \"$d can not found $n, try to restart it ......\" >> ${log_file}\n\t\t\tdo_restart_tomcat $n\n\t\tfi\n\tdone\n\n## 加入定时任务crontab\n### 编辑任务\n```\ncrontab -e\n```\n进入编辑crontab的vi界面，按i键进入插入模式，将如下代码复制到输入界面\n```\n*/20 * * * * \"/home/test/deamon2tomcat.sh\" > /dev/null 2>&1\n```\n`注：每20分钟检查一次(可修改)，加“> /dev/null 2>&1 ”是为了不让它发邮件。`\n### 保存退出\n### 查看任务\n最后查看任务，确认是否编辑成功。\n```\ncrontab -l\n```\n","slug":"Tomcat进程守护脚本","published":1,"updated":"2020-04-07T05:53:54.817Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9m4gt84000mupqe39gu5ycs","content":"<h1 id=\"Tomcat进程守护脚本\"><a href=\"#Tomcat进程守护脚本\" class=\"headerlink\" title=\"Tomcat进程守护脚本\"></a>Tomcat进程守护脚本</h1><p>迫于公司测试服务器上的几个子站经常时不时的挂掉，又查不明原因。<br>谷歌了以后说要把jdbc移出来放到tomcat的lib目录下，让tomcat进行管理。可是怎么实验都没有，恰巧正式服务器上的进程又是好的，于是，有了一下的进程守护脚本。</p>\n<h2 id=\"使用环境\"><a href=\"#使用环境\" class=\"headerlink\" title=\"使用环境\"></a>使用环境</h2><ul>\n<li>操作系统:CentOS7.2</li>\n<li>JDK版本:Java HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode)</li>\n<li>Tomcat版本:apache-tomcat-7.0.70</li>\n</ul>\n<h2 id=\"监控脚本\"><a href=\"#监控脚本\" class=\"headerlink\" title=\"监控脚本\"></a>监控脚本</h2><pre><code>#!/bin/bash\n#\n# mail：zhouhaibin@utry.cn\n# 定时检查tomcat状态\n# 当在进程中查询不到该tomcat则进行重启\n# \n# 需要添加至定时任务crontab中\n# 1. crontab -e\n# 2. */3 * * * * &quot;/home/test/deamon2tomcat.sh&quot; &gt; /dev/null 2&gt;&amp;1\n# 注：每3分钟检查一次(可修改)，加“&gt; /dev/null 2&gt;&amp;1 ”是为了不让它发邮件。\n\nexport PATH=$PATH:/sbin:/bin:/usr/sbin:/usr/bin;\ntomcat_base_dir=&quot;/home/tomservices&quot;;\nlog_file=&quot;/home/tomservices/tomcat_protect_log.log&quot;;\nd=$(date +%F&quot; &quot;%T);\n\n# 初始化日志文件\ntouch ${log_file}\n\ndo_restart_tomcat() {\n    # 不管是否再运行中先关闭服务\n    ${tomcat_base_dir}/$1/bin/shutdown.sh\n\n    # 在进程中检查当前当tomcat是否正在运行并杀死该进程（为了防止shotdown.sh失败）\n    if ps -ef | grep $1 | grep -v grep\n    then\n        kill -9 $(ps -ef | grep $1 | grep -v grep | awk &apos;{print $2}&apos;)\n    fi\n\n    # 重启tomcat\n    ${tomcat_base_dir}/$1/bin/startup.sh\n    # 输出进程号\n    echo &quot;$d success restart $1, the new pid is &quot; &gt;&gt; ${log_file}\n    ps -ef | grep $1 | grep -v grep | awk &apos;{print $2}&apos; &gt;&gt; ${log_file}\n    echo &gt;&gt; ${log_file}\n}\n\necho &quot;$d start check the three server:&quot; &gt;&gt; ${log_file}\n# 循环检查一下三个子站\b是否正在运行并输出相应日志\nfor n in &quot;tomcat_devback&quot; &quot;tomcat_hsipccweb&quot; &quot;tomcat_ccweb&quot;\ndo\necho &quot;$d checking the $n...&quot; &gt;&gt; ${log_file}\n    if ps -ef | grep $n | grep -v grep\n    then\n        echo &quot;$d finished the check of the $n&quot; &gt;&gt; ${log_file}\n    else\n        echo &quot;$d can not found $n, try to restart it ......&quot; &gt;&gt; ${log_file}\n        do_restart_tomcat $n\n    fi\ndone\n</code></pre><h2 id=\"加入定时任务crontab\"><a href=\"#加入定时任务crontab\" class=\"headerlink\" title=\"加入定时任务crontab\"></a>加入定时任务crontab</h2><h3 id=\"编辑任务\"><a href=\"#编辑任务\" class=\"headerlink\" title=\"编辑任务\"></a>编辑任务</h3><pre><code class=\"hljs undefined\">crontab -e</code></pre>\n<p>进入编辑crontab的vi界面，按i键进入插入模式，将如下代码复制到输入界面<br><pre><code class=\"hljs undefined\">*/20 * * * * &quot;/home/test/deamon2tomcat.sh&quot; &gt; /dev/null 2&gt;&amp;1</code></pre></p>\n<p><code>注：每20分钟检查一次(可修改)，加“&gt; /dev/null 2&gt;&amp;1 ”是为了不让它发邮件。</code></p>\n<h3 id=\"保存退出\"><a href=\"#保存退出\" class=\"headerlink\" title=\"保存退出\"></a>保存退出</h3><h3 id=\"查看任务\"><a href=\"#查看任务\" class=\"headerlink\" title=\"查看任务\"></a>查看任务</h3><p>最后查看任务，确认是否编辑成功。<br><pre><code class=\"hljs undefined\">crontab -l</code></pre></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Tomcat进程守护脚本\"><a href=\"#Tomcat进程守护脚本\" class=\"headerlink\" title=\"Tomcat进程守护脚本\"></a>Tomcat进程守护脚本</h1><p>迫于公司测试服务器上的几个子站经常时不时的挂掉，又查不明原因。<br>谷歌了以后说要把jdbc移出来放到tomcat的lib目录下，让tomcat进行管理。可是怎么实验都没有，恰巧正式服务器上的进程又是好的，于是，有了一下的进程守护脚本。</p>\n<h2 id=\"使用环境\"><a href=\"#使用环境\" class=\"headerlink\" title=\"使用环境\"></a>使用环境</h2><ul>\n<li>操作系统:CentOS7.2</li>\n<li>JDK版本:Java HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode)</li>\n<li>Tomcat版本:apache-tomcat-7.0.70</li>\n</ul>\n<h2 id=\"监控脚本\"><a href=\"#监控脚本\" class=\"headerlink\" title=\"监控脚本\"></a>监控脚本</h2><pre><code>#!/bin/bash\n#\n# mail：zhouhaibin@utry.cn\n# 定时检查tomcat状态\n# 当在进程中查询不到该tomcat则进行重启\n# \n# 需要添加至定时任务crontab中\n# 1. crontab -e\n# 2. */3 * * * * &quot;/home/test/deamon2tomcat.sh&quot; &gt; /dev/null 2&gt;&amp;1\n# 注：每3分钟检查一次(可修改)，加“&gt; /dev/null 2&gt;&amp;1 ”是为了不让它发邮件。\n\nexport PATH=$PATH:/sbin:/bin:/usr/sbin:/usr/bin;\ntomcat_base_dir=&quot;/home/tomservices&quot;;\nlog_file=&quot;/home/tomservices/tomcat_protect_log.log&quot;;\nd=$(date +%F&quot; &quot;%T);\n\n# 初始化日志文件\ntouch ${log_file}\n\ndo_restart_tomcat() {\n    # 不管是否再运行中先关闭服务\n    ${tomcat_base_dir}/$1/bin/shutdown.sh\n\n    # 在进程中检查当前当tomcat是否正在运行并杀死该进程（为了防止shotdown.sh失败）\n    if ps -ef | grep $1 | grep -v grep\n    then\n        kill -9 $(ps -ef | grep $1 | grep -v grep | awk &apos;{print $2}&apos;)\n    fi\n\n    # 重启tomcat\n    ${tomcat_base_dir}/$1/bin/startup.sh\n    # 输出进程号\n    echo &quot;$d success restart $1, the new pid is &quot; &gt;&gt; ${log_file}\n    ps -ef | grep $1 | grep -v grep | awk &apos;{print $2}&apos; &gt;&gt; ${log_file}\n    echo &gt;&gt; ${log_file}\n}\n\necho &quot;$d start check the three server:&quot; &gt;&gt; ${log_file}\n# 循环检查一下三个子站\b是否正在运行并输出相应日志\nfor n in &quot;tomcat_devback&quot; &quot;tomcat_hsipccweb&quot; &quot;tomcat_ccweb&quot;\ndo\necho &quot;$d checking the $n...&quot; &gt;&gt; ${log_file}\n    if ps -ef | grep $n | grep -v grep\n    then\n        echo &quot;$d finished the check of the $n&quot; &gt;&gt; ${log_file}\n    else\n        echo &quot;$d can not found $n, try to restart it ......&quot; &gt;&gt; ${log_file}\n        do_restart_tomcat $n\n    fi\ndone\n</code></pre><h2 id=\"加入定时任务crontab\"><a href=\"#加入定时任务crontab\" class=\"headerlink\" title=\"加入定时任务crontab\"></a>加入定时任务crontab</h2><h3 id=\"编辑任务\"><a href=\"#编辑任务\" class=\"headerlink\" title=\"编辑任务\"></a>编辑任务</h3><pre><code class=\"hljs undefined\">crontab -e</code></pre>\n<p>进入编辑crontab的vi界面，按i键进入插入模式，将如下代码复制到输入界面<br><pre><code class=\"hljs undefined\">*/20 * * * * &quot;/home/test/deamon2tomcat.sh&quot; &gt; /dev/null 2&gt;&amp;1</code></pre></p>\n<p><code>注：每20分钟检查一次(可修改)，加“&gt; /dev/null 2&gt;&amp;1 ”是为了不让它发邮件。</code></p>\n<h3 id=\"保存退出\"><a href=\"#保存退出\" class=\"headerlink\" title=\"保存退出\"></a>保存退出</h3><h3 id=\"查看任务\"><a href=\"#查看任务\" class=\"headerlink\" title=\"查看任务\"></a>查看任务</h3><p>最后查看任务，确认是否编辑成功。<br><pre><code class=\"hljs undefined\">crontab -l</code></pre></p>\n"},{"title":"关闭MAC系统下AnyDesk开机自启","date":"2019-06-29T06:54:07.000Z","_content":"## 视图内关闭开机自动启动\n`系统偏好设置->用户与组->登陆项`中进行检查，检查应用是否有勾选\n\n## 通过命令行进行关闭开机自启\n以AnyDesk为例：\n\n### 检查plist文件\n分别在以下6个目录中检查是否有与anydesk相关的plist文件\n1. /Library/Preferences/  – （当前用户设置的进程）\n2. /Library/LaunchAgents/  – （当前用户的守护进程）\n3. /Library/LaunchAgents/  – （管理员设置的用户进程）\n4. /Library/LaunchDaemons/  – （管理员提供的系统守护进程）\n5. /System/Library/LaunchAgents/ – （Mac操作系统提供的用户进程）\n6. /System/Library/LaunchDaemons/   – （Mac操作系统提供的系统守护进程）\n\n### 修改plist文件\n按要求检查出以下三个与anydesk相关的plist文件，分别修改以下三个文件中的内容并保存。\n1. /Library/LaunchAgents/com.philandro.anydesk.Tray.plist\n\n        <key>KeepAlive</key>\n        <false/>\n        ...\n        <key>RunAtLoad</key>\n        <false>\n\n\n2. /Library/LaunchDaemons/com.philandro.anydesk.Helper.plist\n\n        <key>com.philandro.anydesk.Helper</key> #关闭应用相关的工具\n        <false>\n\n3. /Library/LaunchDaemons/com.philandro.anydesk.service.plist\n\n        <key>RunAtLoad</key>\n        <false/>\n        <key>KeepAlive</key>\n        <false>\n\n### 关闭服务\n打开命令行终端（Terminal）执行以下命令：\n\n    # 查看anydesk服务名\n    launchctl list | grep anydesk\n    # 停止服务\n    launchctl stop com.philandro.anydesk\n    # 移除服务\n    launchctl unload com.philandro.anydesk","source":"_posts/关闭MAC系统下AnyDesk开机自启.md","raw":"---\ntitle: 关闭MAC系统下AnyDesk开机自启\ndate: 2019-06-29 14:54:07\ntags:\n- 运维\n- MAC系统\n---\n## 视图内关闭开机自动启动\n`系统偏好设置->用户与组->登陆项`中进行检查，检查应用是否有勾选\n\n## 通过命令行进行关闭开机自启\n以AnyDesk为例：\n\n### 检查plist文件\n分别在以下6个目录中检查是否有与anydesk相关的plist文件\n1. /Library/Preferences/  – （当前用户设置的进程）\n2. /Library/LaunchAgents/  – （当前用户的守护进程）\n3. /Library/LaunchAgents/  – （管理员设置的用户进程）\n4. /Library/LaunchDaemons/  – （管理员提供的系统守护进程）\n5. /System/Library/LaunchAgents/ – （Mac操作系统提供的用户进程）\n6. /System/Library/LaunchDaemons/   – （Mac操作系统提供的系统守护进程）\n\n### 修改plist文件\n按要求检查出以下三个与anydesk相关的plist文件，分别修改以下三个文件中的内容并保存。\n1. /Library/LaunchAgents/com.philandro.anydesk.Tray.plist\n\n        <key>KeepAlive</key>\n        <false/>\n        ...\n        <key>RunAtLoad</key>\n        <false>\n\n\n2. /Library/LaunchDaemons/com.philandro.anydesk.Helper.plist\n\n        <key>com.philandro.anydesk.Helper</key> #关闭应用相关的工具\n        <false>\n\n3. /Library/LaunchDaemons/com.philandro.anydesk.service.plist\n\n        <key>RunAtLoad</key>\n        <false/>\n        <key>KeepAlive</key>\n        <false>\n\n### 关闭服务\n打开命令行终端（Terminal）执行以下命令：\n\n    # 查看anydesk服务名\n    launchctl list | grep anydesk\n    # 停止服务\n    launchctl stop com.philandro.anydesk\n    # 移除服务\n    launchctl unload com.philandro.anydesk","slug":"关闭MAC系统下AnyDesk开机自启","published":1,"updated":"2019-12-30T06:40:13.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9m4gt85000nupqep62tjr1a","content":"<h2 id=\"视图内关闭开机自动启动\"><a href=\"#视图内关闭开机自动启动\" class=\"headerlink\" title=\"视图内关闭开机自动启动\"></a>视图内关闭开机自动启动</h2><p><code>系统偏好设置-&gt;用户与组-&gt;登陆项</code>中进行检查，检查应用是否有勾选</p>\n<h2 id=\"通过命令行进行关闭开机自启\"><a href=\"#通过命令行进行关闭开机自启\" class=\"headerlink\" title=\"通过命令行进行关闭开机自启\"></a>通过命令行进行关闭开机自启</h2><p>以AnyDesk为例：</p>\n<h3 id=\"检查plist文件\"><a href=\"#检查plist文件\" class=\"headerlink\" title=\"检查plist文件\"></a>检查plist文件</h3><p>分别在以下6个目录中检查是否有与anydesk相关的plist文件</p>\n<ol>\n<li>/Library/Preferences/  – （当前用户设置的进程）</li>\n<li>/Library/LaunchAgents/  – （当前用户的守护进程）</li>\n<li>/Library/LaunchAgents/  – （管理员设置的用户进程）</li>\n<li>/Library/LaunchDaemons/  – （管理员提供的系统守护进程）</li>\n<li>/System/Library/LaunchAgents/ – （Mac操作系统提供的用户进程）</li>\n<li>/System/Library/LaunchDaemons/   – （Mac操作系统提供的系统守护进程）</li>\n</ol>\n<h3 id=\"修改plist文件\"><a href=\"#修改plist文件\" class=\"headerlink\" title=\"修改plist文件\"></a>修改plist文件</h3><p>按要求检查出以下三个与anydesk相关的plist文件，分别修改以下三个文件中的内容并保存。</p>\n<ol>\n<li><p>/Library/LaunchAgents/com.philandro.anydesk.Tray.plist</p>\n<pre><code>&lt;key&gt;KeepAlive&lt;/key&gt;\n&lt;false/&gt;\n...\n&lt;key&gt;RunAtLoad&lt;/key&gt;\n&lt;false&gt;\n</code></pre></li>\n</ol>\n<ol start=\"2\">\n<li><p>/Library/LaunchDaemons/com.philandro.anydesk.Helper.plist</p>\n<pre><code>&lt;key&gt;com.philandro.anydesk.Helper&lt;/key&gt; #关闭应用相关的工具\n&lt;false&gt;\n</code></pre></li>\n<li><p>/Library/LaunchDaemons/com.philandro.anydesk.service.plist</p>\n<pre><code>&lt;key&gt;RunAtLoad&lt;/key&gt;\n&lt;false/&gt;\n&lt;key&gt;KeepAlive&lt;/key&gt;\n&lt;false&gt;\n</code></pre></li>\n</ol>\n<h3 id=\"关闭服务\"><a href=\"#关闭服务\" class=\"headerlink\" title=\"关闭服务\"></a>关闭服务</h3><p>打开命令行终端（Terminal）执行以下命令：</p>\n<pre><code># 查看anydesk服务名\nlaunchctl list | grep anydesk\n# 停止服务\nlaunchctl stop com.philandro.anydesk\n# 移除服务\nlaunchctl unload com.philandro.anydesk\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"视图内关闭开机自动启动\"><a href=\"#视图内关闭开机自动启动\" class=\"headerlink\" title=\"视图内关闭开机自动启动\"></a>视图内关闭开机自动启动</h2><p><code>系统偏好设置-&gt;用户与组-&gt;登陆项</code>中进行检查，检查应用是否有勾选</p>\n<h2 id=\"通过命令行进行关闭开机自启\"><a href=\"#通过命令行进行关闭开机自启\" class=\"headerlink\" title=\"通过命令行进行关闭开机自启\"></a>通过命令行进行关闭开机自启</h2><p>以AnyDesk为例：</p>\n<h3 id=\"检查plist文件\"><a href=\"#检查plist文件\" class=\"headerlink\" title=\"检查plist文件\"></a>检查plist文件</h3><p>分别在以下6个目录中检查是否有与anydesk相关的plist文件</p>\n<ol>\n<li>/Library/Preferences/  – （当前用户设置的进程）</li>\n<li>/Library/LaunchAgents/  – （当前用户的守护进程）</li>\n<li>/Library/LaunchAgents/  – （管理员设置的用户进程）</li>\n<li>/Library/LaunchDaemons/  – （管理员提供的系统守护进程）</li>\n<li>/System/Library/LaunchAgents/ – （Mac操作系统提供的用户进程）</li>\n<li>/System/Library/LaunchDaemons/   – （Mac操作系统提供的系统守护进程）</li>\n</ol>\n<h3 id=\"修改plist文件\"><a href=\"#修改plist文件\" class=\"headerlink\" title=\"修改plist文件\"></a>修改plist文件</h3><p>按要求检查出以下三个与anydesk相关的plist文件，分别修改以下三个文件中的内容并保存。</p>\n<ol>\n<li><p>/Library/LaunchAgents/com.philandro.anydesk.Tray.plist</p>\n<pre><code>&lt;key&gt;KeepAlive&lt;/key&gt;\n&lt;false/&gt;\n...\n&lt;key&gt;RunAtLoad&lt;/key&gt;\n&lt;false&gt;\n</code></pre></li>\n</ol>\n<ol start=\"2\">\n<li><p>/Library/LaunchDaemons/com.philandro.anydesk.Helper.plist</p>\n<pre><code>&lt;key&gt;com.philandro.anydesk.Helper&lt;/key&gt; #关闭应用相关的工具\n&lt;false&gt;\n</code></pre></li>\n<li><p>/Library/LaunchDaemons/com.philandro.anydesk.service.plist</p>\n<pre><code>&lt;key&gt;RunAtLoad&lt;/key&gt;\n&lt;false/&gt;\n&lt;key&gt;KeepAlive&lt;/key&gt;\n&lt;false&gt;\n</code></pre></li>\n</ol>\n<h3 id=\"关闭服务\"><a href=\"#关闭服务\" class=\"headerlink\" title=\"关闭服务\"></a>关闭服务</h3><p>打开命令行终端（Terminal）执行以下命令：</p>\n<pre><code># 查看anydesk服务名\nlaunchctl list | grep anydesk\n# 停止服务\nlaunchctl stop com.philandro.anydesk\n# 移除服务\nlaunchctl unload com.philandro.anydesk\n</code></pre>"},{"title":"存储过程","date":"2019-08-05T02:58:11.000Z","_content":"\n# 存储过程与存储函数\n\n## 解释\n\n储存程序 (Stored Procedure)，又可称预储程序或者存储过程，是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象，它可以视为数据库中的一种函数或子程序。\n\n`存储在数据库中，供所有用户程序调用的子程序`\n\n- 优点\n    1. 重复使用。存储过程可以重复使用，从而可以减少数据库开发人员的工作量。\n    2. 减少网络流量。存储过程位于服务器上，调用的时候只需要传递存储过程的名称以及参数就可以了，因此降低了网络传输的数据量。\n    3. 安全性。参数化的存储过程可以防止SQL注入式攻击，而且可以将Grant、Deny以及Revoke权限应用于存储过程。\n    4. 效率高。由于数据库执行动作时，是先编译后执行的。然而存储过程是一个编译过的代码块，所以执行效率要比T-SQL语句高。\n\n- 缺点\n    1. 调试麻烦。\n    2. 移植性差。不同数据库支持的语言不一样，其存储过程的编写规则也不一样，所以存储过程无法移植到另一类数据库。\n    3. 重新编译问题。因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。\n    4. 不能大量使用。如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是非常难、而且代价是空前的，维护起来更麻烦。\n\n## 存储过程语法\n\n\n### 语法\n    create [or replace] procedure  <过程名>(<参数列表,无参时忽略>)\n    as/is\n    变量声明、初始化\n    begin\n    业务处理、逻辑代码\n    exception\n    异常捕获、容错处理\n    end  <过程名>;\n\n    参数:\n    <参数名> in|out|in out  <参数类型，无长度说明> ，如：v_name  varchar2\n    in：入参\n    out：出参\n    in out：出入参\n\n    调用语法：\n        1)、exec  <过程名>;\n        2)、execute  <过程名>;\n        3)、在PL/SQL语句块中直接调用。\n\n    异常捕获：\n        when others then/raise;\n### 示例\n\n    create or replace procedure \"TEST_SWAP\"(v_param1 in out varchar2,v_param2 in out varchar2)\n    is\n        v_temp varchar2(20);\n    begin\n        dbms_output.put_line('交换前参数1：'||v_param1||'  参数2：'||v_param2);\n        v_temp:=v_param1;\n        v_param1:=v_param2;\n        v_param2:=v_temp;\n        dbms_output.put_line('交换后参数1：'||v_param1||'  参数2：'||v_param2);\n    exception\n        when others then dbms_output.put_line('There is a error when the procedure up_wap executing!');\n    end \"TEST_SWAP\";\n\n### 常用语法\n\n    -- INSERT\n    SELECT INTO table1 (name1, name2...) SELECT (name1, name2..) FROM table2 WHERE exprss\n\n    -- 转换为两位小数\n    SELECT to_char('1111','FM990.00') FROM hau_dm_b6c_import;\n\n    -- NVL(E1, E2)的功能为：如果E1为NULL，则函数返回E2，否则返回E1本身。\n    SELECT NVL('1233', '123') FROM HAU_DM_B6C_IMPORT;\n\n\n## 存储函数语法\n\n    -- 语法\n    create [or replace] function 函数名(参数列表)\n    return 函数值类型\n    as\n    PLSQL子程序体;\n\n\n## 使用原则\n如果只有一个返回值,用存储函数;否则,就用存储过程.\n\n\n# HiAgent 报表\n\n## 配置数据源管理\n\n视作一个在页面上定义一个存储过程\n\n1. 位置：系统配置中心->报表->数据源管理\n\n2. 添加数据源：\n   - 存储过程名称：数据库中对应的名称\n   - 数据源名称：\n   - 数据源描述：\n\n3. 配置输入和输出参数\n\n## 配置模版管理\n\n定义其展现模式\n\n1. 位置：系统配置中心->报表->模版管理\n\n2. 添加模版：（前端使用echart控件）\n    - 模版名称：\n    - 模版描述：\n    - 模版类：\n    - 存储过程：上一级定义的过程\n    - 模版类型：\n        - 图表：需要配置模版样式\n        - 网格：要求展现的字段为num\n\n## 配置报表管理\n\n定义其具体的输入内容和暂时内容\n\n1. 位置：系统配置中心->报表->报表管理\n\n2. 添加报表：\n    - 报表标题：\n    - 模版子标题：\n    - 报表类：同上一级配置的模版类型（无法更改）\n    - 报表模版：\n\n## 配置权限管理\n\n定义什么角色可以查看\n\nBUG：全选按钮会导致无法查看报表，需要逐个勾选\n\n\n\n\n","source":"_posts/存储过程.md","raw":"---\ntitle: 存储过程\ndate: 2019-08-05 10:58:11\ntags:\n- ORACLE\n- 存储过程\n---\n\n# 存储过程与存储函数\n\n## 解释\n\n储存程序 (Stored Procedure)，又可称预储程序或者存储过程，是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象，它可以视为数据库中的一种函数或子程序。\n\n`存储在数据库中，供所有用户程序调用的子程序`\n\n- 优点\n    1. 重复使用。存储过程可以重复使用，从而可以减少数据库开发人员的工作量。\n    2. 减少网络流量。存储过程位于服务器上，调用的时候只需要传递存储过程的名称以及参数就可以了，因此降低了网络传输的数据量。\n    3. 安全性。参数化的存储过程可以防止SQL注入式攻击，而且可以将Grant、Deny以及Revoke权限应用于存储过程。\n    4. 效率高。由于数据库执行动作时，是先编译后执行的。然而存储过程是一个编译过的代码块，所以执行效率要比T-SQL语句高。\n\n- 缺点\n    1. 调试麻烦。\n    2. 移植性差。不同数据库支持的语言不一样，其存储过程的编写规则也不一样，所以存储过程无法移植到另一类数据库。\n    3. 重新编译问题。因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。\n    4. 不能大量使用。如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是非常难、而且代价是空前的，维护起来更麻烦。\n\n## 存储过程语法\n\n\n### 语法\n    create [or replace] procedure  <过程名>(<参数列表,无参时忽略>)\n    as/is\n    变量声明、初始化\n    begin\n    业务处理、逻辑代码\n    exception\n    异常捕获、容错处理\n    end  <过程名>;\n\n    参数:\n    <参数名> in|out|in out  <参数类型，无长度说明> ，如：v_name  varchar2\n    in：入参\n    out：出参\n    in out：出入参\n\n    调用语法：\n        1)、exec  <过程名>;\n        2)、execute  <过程名>;\n        3)、在PL/SQL语句块中直接调用。\n\n    异常捕获：\n        when others then/raise;\n### 示例\n\n    create or replace procedure \"TEST_SWAP\"(v_param1 in out varchar2,v_param2 in out varchar2)\n    is\n        v_temp varchar2(20);\n    begin\n        dbms_output.put_line('交换前参数1：'||v_param1||'  参数2：'||v_param2);\n        v_temp:=v_param1;\n        v_param1:=v_param2;\n        v_param2:=v_temp;\n        dbms_output.put_line('交换后参数1：'||v_param1||'  参数2：'||v_param2);\n    exception\n        when others then dbms_output.put_line('There is a error when the procedure up_wap executing!');\n    end \"TEST_SWAP\";\n\n### 常用语法\n\n    -- INSERT\n    SELECT INTO table1 (name1, name2...) SELECT (name1, name2..) FROM table2 WHERE exprss\n\n    -- 转换为两位小数\n    SELECT to_char('1111','FM990.00') FROM hau_dm_b6c_import;\n\n    -- NVL(E1, E2)的功能为：如果E1为NULL，则函数返回E2，否则返回E1本身。\n    SELECT NVL('1233', '123') FROM HAU_DM_B6C_IMPORT;\n\n\n## 存储函数语法\n\n    -- 语法\n    create [or replace] function 函数名(参数列表)\n    return 函数值类型\n    as\n    PLSQL子程序体;\n\n\n## 使用原则\n如果只有一个返回值,用存储函数;否则,就用存储过程.\n\n\n# HiAgent 报表\n\n## 配置数据源管理\n\n视作一个在页面上定义一个存储过程\n\n1. 位置：系统配置中心->报表->数据源管理\n\n2. 添加数据源：\n   - 存储过程名称：数据库中对应的名称\n   - 数据源名称：\n   - 数据源描述：\n\n3. 配置输入和输出参数\n\n## 配置模版管理\n\n定义其展现模式\n\n1. 位置：系统配置中心->报表->模版管理\n\n2. 添加模版：（前端使用echart控件）\n    - 模版名称：\n    - 模版描述：\n    - 模版类：\n    - 存储过程：上一级定义的过程\n    - 模版类型：\n        - 图表：需要配置模版样式\n        - 网格：要求展现的字段为num\n\n## 配置报表管理\n\n定义其具体的输入内容和暂时内容\n\n1. 位置：系统配置中心->报表->报表管理\n\n2. 添加报表：\n    - 报表标题：\n    - 模版子标题：\n    - 报表类：同上一级配置的模版类型（无法更改）\n    - 报表模版：\n\n## 配置权限管理\n\n定义什么角色可以查看\n\nBUG：全选按钮会导致无法查看报表，需要逐个勾选\n\n\n\n\n","slug":"存储过程","published":1,"updated":"2019-12-30T06:40:13.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9m4gt86000rupqejsuum9vr","content":"<h1 id=\"存储过程与存储函数\"><a href=\"#存储过程与存储函数\" class=\"headerlink\" title=\"存储过程与存储函数\"></a>存储过程与存储函数</h1><h2 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h2><p>储存程序 (Stored Procedure)，又可称预储程序或者存储过程，是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象，它可以视为数据库中的一种函数或子程序。</p>\n<p><code>存储在数据库中，供所有用户程序调用的子程序</code></p>\n<ul>\n<li><p>优点</p>\n<ol>\n<li>重复使用。存储过程可以重复使用，从而可以减少数据库开发人员的工作量。</li>\n<li>减少网络流量。存储过程位于服务器上，调用的时候只需要传递存储过程的名称以及参数就可以了，因此降低了网络传输的数据量。</li>\n<li>安全性。参数化的存储过程可以防止SQL注入式攻击，而且可以将Grant、Deny以及Revoke权限应用于存储过程。</li>\n<li>效率高。由于数据库执行动作时，是先编译后执行的。然而存储过程是一个编译过的代码块，所以执行效率要比T-SQL语句高。</li>\n</ol>\n</li>\n<li><p>缺点</p>\n<ol>\n<li>调试麻烦。</li>\n<li>移植性差。不同数据库支持的语言不一样，其存储过程的编写规则也不一样，所以存储过程无法移植到另一类数据库。</li>\n<li>重新编译问题。因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</li>\n<li>不能大量使用。如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是非常难、而且代价是空前的，维护起来更麻烦。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"存储过程语法\"><a href=\"#存储过程语法\" class=\"headerlink\" title=\"存储过程语法\"></a>存储过程语法</h2><h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre><code>create [or replace] procedure  &lt;过程名&gt;(&lt;参数列表,无参时忽略&gt;)\nas/is\n变量声明、初始化\nbegin\n业务处理、逻辑代码\nexception\n异常捕获、容错处理\nend  &lt;过程名&gt;;\n\n参数:\n&lt;参数名&gt; in|out|in out  &lt;参数类型，无长度说明&gt; ，如：v_name  varchar2\nin：入参\nout：出参\nin out：出入参\n\n调用语法：\n    1)、exec  &lt;过程名&gt;;\n    2)、execute  &lt;过程名&gt;;\n    3)、在PL/SQL语句块中直接调用。\n\n异常捕获：\n    when others then/raise;\n</code></pre><h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><pre><code>create or replace procedure &quot;TEST_SWAP&quot;(v_param1 in out varchar2,v_param2 in out varchar2)\nis\n    v_temp varchar2(20);\nbegin\n    dbms_output.put_line(&apos;交换前参数1：&apos;||v_param1||&apos;  参数2：&apos;||v_param2);\n    v_temp:=v_param1;\n    v_param1:=v_param2;\n    v_param2:=v_temp;\n    dbms_output.put_line(&apos;交换后参数1：&apos;||v_param1||&apos;  参数2：&apos;||v_param2);\nexception\n    when others then dbms_output.put_line(&apos;There is a error when the procedure up_wap executing!&apos;);\nend &quot;TEST_SWAP&quot;;\n</code></pre><h3 id=\"常用语法\"><a href=\"#常用语法\" class=\"headerlink\" title=\"常用语法\"></a>常用语法</h3><pre><code>-- INSERT\nSELECT INTO table1 (name1, name2...) SELECT (name1, name2..) FROM table2 WHERE exprss\n\n-- 转换为两位小数\nSELECT to_char(&apos;1111&apos;,&apos;FM990.00&apos;) FROM hau_dm_b6c_import;\n\n-- NVL(E1, E2)的功能为：如果E1为NULL，则函数返回E2，否则返回E1本身。\nSELECT NVL(&apos;1233&apos;, &apos;123&apos;) FROM HAU_DM_B6C_IMPORT;\n</code></pre><h2 id=\"存储函数语法\"><a href=\"#存储函数语法\" class=\"headerlink\" title=\"存储函数语法\"></a>存储函数语法</h2><pre><code>-- 语法\ncreate [or replace] function 函数名(参数列表)\nreturn 函数值类型\nas\nPLSQL子程序体;\n</code></pre><h2 id=\"使用原则\"><a href=\"#使用原则\" class=\"headerlink\" title=\"使用原则\"></a>使用原则</h2><p>如果只有一个返回值,用存储函数;否则,就用存储过程.</p>\n<h1 id=\"HiAgent-报表\"><a href=\"#HiAgent-报表\" class=\"headerlink\" title=\"HiAgent 报表\"></a>HiAgent 报表</h1><h2 id=\"配置数据源管理\"><a href=\"#配置数据源管理\" class=\"headerlink\" title=\"配置数据源管理\"></a>配置数据源管理</h2><p>视作一个在页面上定义一个存储过程</p>\n<ol>\n<li><p>位置：系统配置中心-&gt;报表-&gt;数据源管理</p>\n</li>\n<li><p>添加数据源：</p>\n<ul>\n<li>存储过程名称：数据库中对应的名称</li>\n<li>数据源名称：</li>\n<li>数据源描述：</li>\n</ul>\n</li>\n<li><p>配置输入和输出参数</p>\n</li>\n</ol>\n<h2 id=\"配置模版管理\"><a href=\"#配置模版管理\" class=\"headerlink\" title=\"配置模版管理\"></a>配置模版管理</h2><p>定义其展现模式</p>\n<ol>\n<li><p>位置：系统配置中心-&gt;报表-&gt;模版管理</p>\n</li>\n<li><p>添加模版：（前端使用echart控件）</p>\n<ul>\n<li>模版名称：</li>\n<li>模版描述：</li>\n<li>模版类：</li>\n<li>存储过程：上一级定义的过程</li>\n<li>模版类型：<ul>\n<li>图表：需要配置模版样式</li>\n<li>网格：要求展现的字段为num</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"配置报表管理\"><a href=\"#配置报表管理\" class=\"headerlink\" title=\"配置报表管理\"></a>配置报表管理</h2><p>定义其具体的输入内容和暂时内容</p>\n<ol>\n<li><p>位置：系统配置中心-&gt;报表-&gt;报表管理</p>\n</li>\n<li><p>添加报表：</p>\n<ul>\n<li>报表标题：</li>\n<li>模版子标题：</li>\n<li>报表类：同上一级配置的模版类型（无法更改）</li>\n<li>报表模版：</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"配置权限管理\"><a href=\"#配置权限管理\" class=\"headerlink\" title=\"配置权限管理\"></a>配置权限管理</h2><p>定义什么角色可以查看</p>\n<p>BUG：全选按钮会导致无法查看报表，需要逐个勾选</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"存储过程与存储函数\"><a href=\"#存储过程与存储函数\" class=\"headerlink\" title=\"存储过程与存储函数\"></a>存储过程与存储函数</h1><h2 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h2><p>储存程序 (Stored Procedure)，又可称预储程序或者存储过程，是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象，它可以视为数据库中的一种函数或子程序。</p>\n<p><code>存储在数据库中，供所有用户程序调用的子程序</code></p>\n<ul>\n<li><p>优点</p>\n<ol>\n<li>重复使用。存储过程可以重复使用，从而可以减少数据库开发人员的工作量。</li>\n<li>减少网络流量。存储过程位于服务器上，调用的时候只需要传递存储过程的名称以及参数就可以了，因此降低了网络传输的数据量。</li>\n<li>安全性。参数化的存储过程可以防止SQL注入式攻击，而且可以将Grant、Deny以及Revoke权限应用于存储过程。</li>\n<li>效率高。由于数据库执行动作时，是先编译后执行的。然而存储过程是一个编译过的代码块，所以执行效率要比T-SQL语句高。</li>\n</ol>\n</li>\n<li><p>缺点</p>\n<ol>\n<li>调试麻烦。</li>\n<li>移植性差。不同数据库支持的语言不一样，其存储过程的编写规则也不一样，所以存储过程无法移植到另一类数据库。</li>\n<li>重新编译问题。因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</li>\n<li>不能大量使用。如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是非常难、而且代价是空前的，维护起来更麻烦。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"存储过程语法\"><a href=\"#存储过程语法\" class=\"headerlink\" title=\"存储过程语法\"></a>存储过程语法</h2><h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre><code>create [or replace] procedure  &lt;过程名&gt;(&lt;参数列表,无参时忽略&gt;)\nas/is\n变量声明、初始化\nbegin\n业务处理、逻辑代码\nexception\n异常捕获、容错处理\nend  &lt;过程名&gt;;\n\n参数:\n&lt;参数名&gt; in|out|in out  &lt;参数类型，无长度说明&gt; ，如：v_name  varchar2\nin：入参\nout：出参\nin out：出入参\n\n调用语法：\n    1)、exec  &lt;过程名&gt;;\n    2)、execute  &lt;过程名&gt;;\n    3)、在PL/SQL语句块中直接调用。\n\n异常捕获：\n    when others then/raise;\n</code></pre><h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><pre><code>create or replace procedure &quot;TEST_SWAP&quot;(v_param1 in out varchar2,v_param2 in out varchar2)\nis\n    v_temp varchar2(20);\nbegin\n    dbms_output.put_line(&apos;交换前参数1：&apos;||v_param1||&apos;  参数2：&apos;||v_param2);\n    v_temp:=v_param1;\n    v_param1:=v_param2;\n    v_param2:=v_temp;\n    dbms_output.put_line(&apos;交换后参数1：&apos;||v_param1||&apos;  参数2：&apos;||v_param2);\nexception\n    when others then dbms_output.put_line(&apos;There is a error when the procedure up_wap executing!&apos;);\nend &quot;TEST_SWAP&quot;;\n</code></pre><h3 id=\"常用语法\"><a href=\"#常用语法\" class=\"headerlink\" title=\"常用语法\"></a>常用语法</h3><pre><code>-- INSERT\nSELECT INTO table1 (name1, name2...) SELECT (name1, name2..) FROM table2 WHERE exprss\n\n-- 转换为两位小数\nSELECT to_char(&apos;1111&apos;,&apos;FM990.00&apos;) FROM hau_dm_b6c_import;\n\n-- NVL(E1, E2)的功能为：如果E1为NULL，则函数返回E2，否则返回E1本身。\nSELECT NVL(&apos;1233&apos;, &apos;123&apos;) FROM HAU_DM_B6C_IMPORT;\n</code></pre><h2 id=\"存储函数语法\"><a href=\"#存储函数语法\" class=\"headerlink\" title=\"存储函数语法\"></a>存储函数语法</h2><pre><code>-- 语法\ncreate [or replace] function 函数名(参数列表)\nreturn 函数值类型\nas\nPLSQL子程序体;\n</code></pre><h2 id=\"使用原则\"><a href=\"#使用原则\" class=\"headerlink\" title=\"使用原则\"></a>使用原则</h2><p>如果只有一个返回值,用存储函数;否则,就用存储过程.</p>\n<h1 id=\"HiAgent-报表\"><a href=\"#HiAgent-报表\" class=\"headerlink\" title=\"HiAgent 报表\"></a>HiAgent 报表</h1><h2 id=\"配置数据源管理\"><a href=\"#配置数据源管理\" class=\"headerlink\" title=\"配置数据源管理\"></a>配置数据源管理</h2><p>视作一个在页面上定义一个存储过程</p>\n<ol>\n<li><p>位置：系统配置中心-&gt;报表-&gt;数据源管理</p>\n</li>\n<li><p>添加数据源：</p>\n<ul>\n<li>存储过程名称：数据库中对应的名称</li>\n<li>数据源名称：</li>\n<li>数据源描述：</li>\n</ul>\n</li>\n<li><p>配置输入和输出参数</p>\n</li>\n</ol>\n<h2 id=\"配置模版管理\"><a href=\"#配置模版管理\" class=\"headerlink\" title=\"配置模版管理\"></a>配置模版管理</h2><p>定义其展现模式</p>\n<ol>\n<li><p>位置：系统配置中心-&gt;报表-&gt;模版管理</p>\n</li>\n<li><p>添加模版：（前端使用echart控件）</p>\n<ul>\n<li>模版名称：</li>\n<li>模版描述：</li>\n<li>模版类：</li>\n<li>存储过程：上一级定义的过程</li>\n<li>模版类型：<ul>\n<li>图表：需要配置模版样式</li>\n<li>网格：要求展现的字段为num</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"配置报表管理\"><a href=\"#配置报表管理\" class=\"headerlink\" title=\"配置报表管理\"></a>配置报表管理</h2><p>定义其具体的输入内容和暂时内容</p>\n<ol>\n<li><p>位置：系统配置中心-&gt;报表-&gt;报表管理</p>\n</li>\n<li><p>添加报表：</p>\n<ul>\n<li>报表标题：</li>\n<li>模版子标题：</li>\n<li>报表类：同上一级配置的模版类型（无法更改）</li>\n<li>报表模版：</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"配置权限管理\"><a href=\"#配置权限管理\" class=\"headerlink\" title=\"配置权限管理\"></a>配置权限管理</h2><p>定义什么角色可以查看</p>\n<p>BUG：全选按钮会导致无法查看报表，需要逐个勾选</p>\n"},{"title":"利用脚本统一管理网络代理","date":"2019-06-01T14:16:14.000Z","_content":"# 通过shell脚本改变代理\n\n## 背景\n\nmac系统下，用ssr能够自动设置socks的代理，但是发现google云盘等应用必须要设置https或者http代理才能够使用。\n\n每次进行手动在```系统便好设置->网络->高级->代理```设置ssr等代理地址比较繁琐，并且网络环境一发生改变就需要重新设置。\n\n## Shell脚本编写\n\n### 列出网络环境\n\n\n    >>>networksetup -listallnetworkservices\n\n    USB 10/100/1000 LAN\n    Wi-Fi\n    Bluetooth PAN\n    Thunderbolt Bridge\n\n\n显示当前使用的是4种，其中常用的为usb和wifi两种\n\n### 通过命令控制代理\n\n    sudo networksetup -setwebproxy \"Wi-Fi\" 127.0.0.1 12333\n\n__Wi-Fi为网络类型名称，127.0.0.1为代理ip，12333为代理端口 (代理ip和端口可以从ssr\"_复制http代理设置_\"中获取)__\n\n通过图形窗口发现代码生效\n\n### Shell实现自动化\n\n由于sudo每次都要输入密码，可以使用：\n\n    echo \"password\" |sudo networksetup -setwebproxy \"Wi-Fi\" 127.0.0.1 12333\n\n将前面输出的信息，给后面的代码\n\n于是有了下面的代码：\n\n\n    !/bin/bash\n\n    echo \"🤓 Hello Boy! \\nI have changed the PROXY for you\"\n\n    proxy_http_on(){\n        echo \"password\" | sudo -S networksetup -setwebproxy \"Wi-Fi\" 127.0.0.1 12333\n    }\n\n    proxy_https_on(){\n        echo \"password\" | sudo -S networksetup -setsecurewebproxy \"Wi-Fi\" 127.0.0.1 12333\n    }\n\n    proxy_all_on(){\n        echo \"password\" | sudo -S networksetup -setwebproxy \"Wi-Fi\" 127.0.0.1 12333 && sudo -S networksetup -setsecurewebproxy \"Wi-Fi\" 127.0.0.1 12333\n    }\n\n    proxy_http_off(){\n        echo \"password\" | sudo -S networksetup -setwebproxystate \"Wi-Fi\" off\n    }\n\n    proxy_https_off(){\n        echo \"password\" | sudo -S networksetup -setsecurewebproxystate \"Wi-Fi\" off\n    }\n\n    proxy_all_off(){\n        echo \"password\" | sudo -S networksetup -setwebproxystate \"Wi-Fi\" off && sudo -S networksetup -setsecurewebproxystate \"Wi-Fi\" off\n    }\n\n    proxy_lan_on(){\n        echo \"password\" | sudo -S networksetup -setwebproxy \"USB 10/100/1000 LAN\" 127.0.0.1 12333 && sudo -S networksetup -setsecurewebproxy \"USB 10/100/1000 LAN\" 127.0.0.1 12333\n    }\n\n    proxy_lan_off(){\n        echo \"password\" | sudo -S networksetup -setwebproxystate \"USB 10/100/1000 LAN\" off && sudo -S networksetup -setsecurewebproxystate \"USB 10/100/1000 LAN\" off\n    }\n\n    if [ \"$1\" = \"httpon\" ];then\n        proxy_http_on\n    elif [ \"$1\" = \"httpson\" ];then\n        proxy_https_on\n    elif [ \"$1\" = \"allon\" ];then\n        proxy_all_on\n    elif [ \"$1\" = \"httpoff\" ];then\n        proxy_http_off\n    elif [ \"$1\" = \"httpsoff\" ];then\n        proxy_https_off\n    elif [ \"$1\" = \"alloff\" ];then\n        proxy_all_off\n    elif [ \"$1\" = \"lanon\" ];then\n        proxy_lan_on\n    elif [ \"$1\" = \"lanoff\" ];then\n        proxy_lan_off\n    else\n        printf \"Usage: sh fileName.sh {httpon | httpson | allon | httpoff | httpsoff | alloff | lanon | lanoff}\\n\"\n    fi\n\n\n## 更加便捷\n\n使用.bash_profile文件设置一个别名可以更加方便的使用，为了便捷只设置了`proxy_all_on/off`和`proxy_lan_on/off`：\n\n\n    alias wifipon=\"sudo sh ~/Documents/Configs/proxyChange.sh allon\"\n    alias wifipoff=\"sudo sh ~/Documents/Configs/proxyChange.sh alloff\"\n    alias lanpon=\"sudo sh ~/Documents/Configs/proxyChange.sh lanon\"\n    alias lanpoff=\"sudo sh ~/Documents/Configs/proxyChange.sh lanoff\"\n\n\n","source":"_posts/利用脚本统一管理网络代理.md","raw":"---\ntitle: 利用脚本统一管理网络代理\ndate: 2019-06-01 22:16:14\ntags:\n- 运维\n- MAC系统\n- 脚本\n---\n# 通过shell脚本改变代理\n\n## 背景\n\nmac系统下，用ssr能够自动设置socks的代理，但是发现google云盘等应用必须要设置https或者http代理才能够使用。\n\n每次进行手动在```系统便好设置->网络->高级->代理```设置ssr等代理地址比较繁琐，并且网络环境一发生改变就需要重新设置。\n\n## Shell脚本编写\n\n### 列出网络环境\n\n\n    >>>networksetup -listallnetworkservices\n\n    USB 10/100/1000 LAN\n    Wi-Fi\n    Bluetooth PAN\n    Thunderbolt Bridge\n\n\n显示当前使用的是4种，其中常用的为usb和wifi两种\n\n### 通过命令控制代理\n\n    sudo networksetup -setwebproxy \"Wi-Fi\" 127.0.0.1 12333\n\n__Wi-Fi为网络类型名称，127.0.0.1为代理ip，12333为代理端口 (代理ip和端口可以从ssr\"_复制http代理设置_\"中获取)__\n\n通过图形窗口发现代码生效\n\n### Shell实现自动化\n\n由于sudo每次都要输入密码，可以使用：\n\n    echo \"password\" |sudo networksetup -setwebproxy \"Wi-Fi\" 127.0.0.1 12333\n\n将前面输出的信息，给后面的代码\n\n于是有了下面的代码：\n\n\n    !/bin/bash\n\n    echo \"🤓 Hello Boy! \\nI have changed the PROXY for you\"\n\n    proxy_http_on(){\n        echo \"password\" | sudo -S networksetup -setwebproxy \"Wi-Fi\" 127.0.0.1 12333\n    }\n\n    proxy_https_on(){\n        echo \"password\" | sudo -S networksetup -setsecurewebproxy \"Wi-Fi\" 127.0.0.1 12333\n    }\n\n    proxy_all_on(){\n        echo \"password\" | sudo -S networksetup -setwebproxy \"Wi-Fi\" 127.0.0.1 12333 && sudo -S networksetup -setsecurewebproxy \"Wi-Fi\" 127.0.0.1 12333\n    }\n\n    proxy_http_off(){\n        echo \"password\" | sudo -S networksetup -setwebproxystate \"Wi-Fi\" off\n    }\n\n    proxy_https_off(){\n        echo \"password\" | sudo -S networksetup -setsecurewebproxystate \"Wi-Fi\" off\n    }\n\n    proxy_all_off(){\n        echo \"password\" | sudo -S networksetup -setwebproxystate \"Wi-Fi\" off && sudo -S networksetup -setsecurewebproxystate \"Wi-Fi\" off\n    }\n\n    proxy_lan_on(){\n        echo \"password\" | sudo -S networksetup -setwebproxy \"USB 10/100/1000 LAN\" 127.0.0.1 12333 && sudo -S networksetup -setsecurewebproxy \"USB 10/100/1000 LAN\" 127.0.0.1 12333\n    }\n\n    proxy_lan_off(){\n        echo \"password\" | sudo -S networksetup -setwebproxystate \"USB 10/100/1000 LAN\" off && sudo -S networksetup -setsecurewebproxystate \"USB 10/100/1000 LAN\" off\n    }\n\n    if [ \"$1\" = \"httpon\" ];then\n        proxy_http_on\n    elif [ \"$1\" = \"httpson\" ];then\n        proxy_https_on\n    elif [ \"$1\" = \"allon\" ];then\n        proxy_all_on\n    elif [ \"$1\" = \"httpoff\" ];then\n        proxy_http_off\n    elif [ \"$1\" = \"httpsoff\" ];then\n        proxy_https_off\n    elif [ \"$1\" = \"alloff\" ];then\n        proxy_all_off\n    elif [ \"$1\" = \"lanon\" ];then\n        proxy_lan_on\n    elif [ \"$1\" = \"lanoff\" ];then\n        proxy_lan_off\n    else\n        printf \"Usage: sh fileName.sh {httpon | httpson | allon | httpoff | httpsoff | alloff | lanon | lanoff}\\n\"\n    fi\n\n\n## 更加便捷\n\n使用.bash_profile文件设置一个别名可以更加方便的使用，为了便捷只设置了`proxy_all_on/off`和`proxy_lan_on/off`：\n\n\n    alias wifipon=\"sudo sh ~/Documents/Configs/proxyChange.sh allon\"\n    alias wifipoff=\"sudo sh ~/Documents/Configs/proxyChange.sh alloff\"\n    alias lanpon=\"sudo sh ~/Documents/Configs/proxyChange.sh lanon\"\n    alias lanpoff=\"sudo sh ~/Documents/Configs/proxyChange.sh lanoff\"\n\n\n","slug":"利用脚本统一管理网络代理","published":1,"updated":"2019-12-30T06:40:13.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9m4gt87000tupqeady8hfwv","content":"<h1 id=\"通过shell脚本改变代理\"><a href=\"#通过shell脚本改变代理\" class=\"headerlink\" title=\"通过shell脚本改变代理\"></a>通过shell脚本改变代理</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>mac系统下，用ssr能够自动设置socks的代理，但是发现google云盘等应用必须要设置https或者http代理才能够使用。</p>\n<p>每次进行手动在<code>系统便好设置-&gt;网络-&gt;高级-&gt;代理</code>设置ssr等代理地址比较繁琐，并且网络环境一发生改变就需要重新设置。</p>\n<h2 id=\"Shell脚本编写\"><a href=\"#Shell脚本编写\" class=\"headerlink\" title=\"Shell脚本编写\"></a>Shell脚本编写</h2><h3 id=\"列出网络环境\"><a href=\"#列出网络环境\" class=\"headerlink\" title=\"列出网络环境\"></a>列出网络环境</h3><pre><code>&gt;&gt;&gt;networksetup -listallnetworkservices\n\nUSB 10/100/1000 LAN\nWi-Fi\nBluetooth PAN\nThunderbolt Bridge\n</code></pre><p>显示当前使用的是4种，其中常用的为usb和wifi两种</p>\n<h3 id=\"通过命令控制代理\"><a href=\"#通过命令控制代理\" class=\"headerlink\" title=\"通过命令控制代理\"></a>通过命令控制代理</h3><pre><code>sudo networksetup -setwebproxy &quot;Wi-Fi&quot; 127.0.0.1 12333\n</code></pre><p><strong>Wi-Fi为网络类型名称，127.0.0.1为代理ip，12333为代理端口 (代理ip和端口可以从ssr”<em>复制http代理设置</em>“中获取)</strong></p>\n<p>通过图形窗口发现代码生效</p>\n<h3 id=\"Shell实现自动化\"><a href=\"#Shell实现自动化\" class=\"headerlink\" title=\"Shell实现自动化\"></a>Shell实现自动化</h3><p>由于sudo每次都要输入密码，可以使用：</p>\n<pre><code>echo &quot;password&quot; |sudo networksetup -setwebproxy &quot;Wi-Fi&quot; 127.0.0.1 12333\n</code></pre><p>将前面输出的信息，给后面的代码</p>\n<p>于是有了下面的代码：</p>\n<pre><code>!/bin/bash\n\necho &quot;🤓 Hello Boy! \\nI have changed the PROXY for you&quot;\n\nproxy_http_on(){\n    echo &quot;password&quot; | sudo -S networksetup -setwebproxy &quot;Wi-Fi&quot; 127.0.0.1 12333\n}\n\nproxy_https_on(){\n    echo &quot;password&quot; | sudo -S networksetup -setsecurewebproxy &quot;Wi-Fi&quot; 127.0.0.1 12333\n}\n\nproxy_all_on(){\n    echo &quot;password&quot; | sudo -S networksetup -setwebproxy &quot;Wi-Fi&quot; 127.0.0.1 12333 &amp;&amp; sudo -S networksetup -setsecurewebproxy &quot;Wi-Fi&quot; 127.0.0.1 12333\n}\n\nproxy_http_off(){\n    echo &quot;password&quot; | sudo -S networksetup -setwebproxystate &quot;Wi-Fi&quot; off\n}\n\nproxy_https_off(){\n    echo &quot;password&quot; | sudo -S networksetup -setsecurewebproxystate &quot;Wi-Fi&quot; off\n}\n\nproxy_all_off(){\n    echo &quot;password&quot; | sudo -S networksetup -setwebproxystate &quot;Wi-Fi&quot; off &amp;&amp; sudo -S networksetup -setsecurewebproxystate &quot;Wi-Fi&quot; off\n}\n\nproxy_lan_on(){\n    echo &quot;password&quot; | sudo -S networksetup -setwebproxy &quot;USB 10/100/1000 LAN&quot; 127.0.0.1 12333 &amp;&amp; sudo -S networksetup -setsecurewebproxy &quot;USB 10/100/1000 LAN&quot; 127.0.0.1 12333\n}\n\nproxy_lan_off(){\n    echo &quot;password&quot; | sudo -S networksetup -setwebproxystate &quot;USB 10/100/1000 LAN&quot; off &amp;&amp; sudo -S networksetup -setsecurewebproxystate &quot;USB 10/100/1000 LAN&quot; off\n}\n\nif [ &quot;$1&quot; = &quot;httpon&quot; ];then\n    proxy_http_on\nelif [ &quot;$1&quot; = &quot;httpson&quot; ];then\n    proxy_https_on\nelif [ &quot;$1&quot; = &quot;allon&quot; ];then\n    proxy_all_on\nelif [ &quot;$1&quot; = &quot;httpoff&quot; ];then\n    proxy_http_off\nelif [ &quot;$1&quot; = &quot;httpsoff&quot; ];then\n    proxy_https_off\nelif [ &quot;$1&quot; = &quot;alloff&quot; ];then\n    proxy_all_off\nelif [ &quot;$1&quot; = &quot;lanon&quot; ];then\n    proxy_lan_on\nelif [ &quot;$1&quot; = &quot;lanoff&quot; ];then\n    proxy_lan_off\nelse\n    printf &quot;Usage: sh fileName.sh {httpon | httpson | allon | httpoff | httpsoff | alloff | lanon | lanoff}\\n&quot;\nfi\n</code></pre><h2 id=\"更加便捷\"><a href=\"#更加便捷\" class=\"headerlink\" title=\"更加便捷\"></a>更加便捷</h2><p>使用.bash_profile文件设置一个别名可以更加方便的使用，为了便捷只设置了<code>proxy_all_on/off</code>和<code>proxy_lan_on/off</code>：</p>\n<pre><code>alias wifipon=&quot;sudo sh ~/Documents/Configs/proxyChange.sh allon&quot;\nalias wifipoff=&quot;sudo sh ~/Documents/Configs/proxyChange.sh alloff&quot;\nalias lanpon=&quot;sudo sh ~/Documents/Configs/proxyChange.sh lanon&quot;\nalias lanpoff=&quot;sudo sh ~/Documents/Configs/proxyChange.sh lanoff&quot;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"通过shell脚本改变代理\"><a href=\"#通过shell脚本改变代理\" class=\"headerlink\" title=\"通过shell脚本改变代理\"></a>通过shell脚本改变代理</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>mac系统下，用ssr能够自动设置socks的代理，但是发现google云盘等应用必须要设置https或者http代理才能够使用。</p>\n<p>每次进行手动在<code>系统便好设置-&gt;网络-&gt;高级-&gt;代理</code>设置ssr等代理地址比较繁琐，并且网络环境一发生改变就需要重新设置。</p>\n<h2 id=\"Shell脚本编写\"><a href=\"#Shell脚本编写\" class=\"headerlink\" title=\"Shell脚本编写\"></a>Shell脚本编写</h2><h3 id=\"列出网络环境\"><a href=\"#列出网络环境\" class=\"headerlink\" title=\"列出网络环境\"></a>列出网络环境</h3><pre><code>&gt;&gt;&gt;networksetup -listallnetworkservices\n\nUSB 10/100/1000 LAN\nWi-Fi\nBluetooth PAN\nThunderbolt Bridge\n</code></pre><p>显示当前使用的是4种，其中常用的为usb和wifi两种</p>\n<h3 id=\"通过命令控制代理\"><a href=\"#通过命令控制代理\" class=\"headerlink\" title=\"通过命令控制代理\"></a>通过命令控制代理</h3><pre><code>sudo networksetup -setwebproxy &quot;Wi-Fi&quot; 127.0.0.1 12333\n</code></pre><p><strong>Wi-Fi为网络类型名称，127.0.0.1为代理ip，12333为代理端口 (代理ip和端口可以从ssr”<em>复制http代理设置</em>“中获取)</strong></p>\n<p>通过图形窗口发现代码生效</p>\n<h3 id=\"Shell实现自动化\"><a href=\"#Shell实现自动化\" class=\"headerlink\" title=\"Shell实现自动化\"></a>Shell实现自动化</h3><p>由于sudo每次都要输入密码，可以使用：</p>\n<pre><code>echo &quot;password&quot; |sudo networksetup -setwebproxy &quot;Wi-Fi&quot; 127.0.0.1 12333\n</code></pre><p>将前面输出的信息，给后面的代码</p>\n<p>于是有了下面的代码：</p>\n<pre><code>!/bin/bash\n\necho &quot;🤓 Hello Boy! \\nI have changed the PROXY for you&quot;\n\nproxy_http_on(){\n    echo &quot;password&quot; | sudo -S networksetup -setwebproxy &quot;Wi-Fi&quot; 127.0.0.1 12333\n}\n\nproxy_https_on(){\n    echo &quot;password&quot; | sudo -S networksetup -setsecurewebproxy &quot;Wi-Fi&quot; 127.0.0.1 12333\n}\n\nproxy_all_on(){\n    echo &quot;password&quot; | sudo -S networksetup -setwebproxy &quot;Wi-Fi&quot; 127.0.0.1 12333 &amp;&amp; sudo -S networksetup -setsecurewebproxy &quot;Wi-Fi&quot; 127.0.0.1 12333\n}\n\nproxy_http_off(){\n    echo &quot;password&quot; | sudo -S networksetup -setwebproxystate &quot;Wi-Fi&quot; off\n}\n\nproxy_https_off(){\n    echo &quot;password&quot; | sudo -S networksetup -setsecurewebproxystate &quot;Wi-Fi&quot; off\n}\n\nproxy_all_off(){\n    echo &quot;password&quot; | sudo -S networksetup -setwebproxystate &quot;Wi-Fi&quot; off &amp;&amp; sudo -S networksetup -setsecurewebproxystate &quot;Wi-Fi&quot; off\n}\n\nproxy_lan_on(){\n    echo &quot;password&quot; | sudo -S networksetup -setwebproxy &quot;USB 10/100/1000 LAN&quot; 127.0.0.1 12333 &amp;&amp; sudo -S networksetup -setsecurewebproxy &quot;USB 10/100/1000 LAN&quot; 127.0.0.1 12333\n}\n\nproxy_lan_off(){\n    echo &quot;password&quot; | sudo -S networksetup -setwebproxystate &quot;USB 10/100/1000 LAN&quot; off &amp;&amp; sudo -S networksetup -setsecurewebproxystate &quot;USB 10/100/1000 LAN&quot; off\n}\n\nif [ &quot;$1&quot; = &quot;httpon&quot; ];then\n    proxy_http_on\nelif [ &quot;$1&quot; = &quot;httpson&quot; ];then\n    proxy_https_on\nelif [ &quot;$1&quot; = &quot;allon&quot; ];then\n    proxy_all_on\nelif [ &quot;$1&quot; = &quot;httpoff&quot; ];then\n    proxy_http_off\nelif [ &quot;$1&quot; = &quot;httpsoff&quot; ];then\n    proxy_https_off\nelif [ &quot;$1&quot; = &quot;alloff&quot; ];then\n    proxy_all_off\nelif [ &quot;$1&quot; = &quot;lanon&quot; ];then\n    proxy_lan_on\nelif [ &quot;$1&quot; = &quot;lanoff&quot; ];then\n    proxy_lan_off\nelse\n    printf &quot;Usage: sh fileName.sh {httpon | httpson | allon | httpoff | httpsoff | alloff | lanon | lanoff}\\n&quot;\nfi\n</code></pre><h2 id=\"更加便捷\"><a href=\"#更加便捷\" class=\"headerlink\" title=\"更加便捷\"></a>更加便捷</h2><p>使用.bash_profile文件设置一个别名可以更加方便的使用，为了便捷只设置了<code>proxy_all_on/off</code>和<code>proxy_lan_on/off</code>：</p>\n<pre><code>alias wifipon=&quot;sudo sh ~/Documents/Configs/proxyChange.sh allon&quot;\nalias wifipoff=&quot;sudo sh ~/Documents/Configs/proxyChange.sh alloff&quot;\nalias lanpon=&quot;sudo sh ~/Documents/Configs/proxyChange.sh lanon&quot;\nalias lanpoff=&quot;sudo sh ~/Documents/Configs/proxyChange.sh lanoff&quot;\n</code></pre>"},{"title":"Redis底层数据笔记","date":"2019-07-02T02:54:47.000Z","_content":"\n# redis底层数据结构以及对象系统\n\n## 底层数据结构\n## SDS（simple dynamic string，简单动态字符串）\n\n    /* 保存字符串对象的结构 */\n    struct sdshdr {\n        int len;       // buf 中已占用空间的长度\n        int free;      // buf 中剩余可用空间的长度\n        char buf[];    // 数据空间\n    };\n\n### SDS空间预分配：\n对SDS字符串进行扩展，如果free值大于扩展值则直接存储，否则重新分配空间：\n- 如果对SDS进行修改后字符串长度（len值）小于1MB，则额外分配len大小相同的空间（free值）；\n- 若SDS修改后len大于1MB，则额外分配1MB的空间（free值）。\n\n### SDS惰性空间释放：\n对SDS字符串进行缩短操作，并不会重新分配内存回收缩短的字节，而是使用free属性将这些字节的数量记录起来。\n\nredis保存的是SDS中的buf的二进制数据。SDS的API都是二进制安全的。\n\n\n![](http://ww3.sinaimg.cn/large/006tNc79ly1g4l9uj0wp9j30k305x0v2.jpg)\n### 链表\n双向链表\n\n    /* 双端链表节点 */\n    typedef struct listNode {\n        struct listNode *prev;      // 前置节点\n        struct listNode *next;      // 后置节点  \n        void *value;                // 节点的值\n    } listNode;\n\n![](http://ww3.sinaimg.cn/large/006tNc79ly1g4l9wbhheaj30j309042e.jpg)\n### 字典\n\n    /* 哈希表节点 */\n    typedef struct dictEntry {    \n        void *key;                // 键\n        union {                   // 值\n            void *val;\n            uint64_t u64;\n            int64_t s64;\n        } v;\n        struct dictEntry *next;   // 指向下个哈希表节点，形成链表\n\n    } dictEntry;\n\n    /*  字典类型特定函数 */\n    typedef struct dictType {\n        unsigned int (*hashFunction)(const void *key); \n        // 计算哈希值的函数\n        void *(*keyDup)(void *privdata, const void *key);  \n        // 复制键的函数\n        void *(*valDup)(void *privdata, const void *obj);               \n        // 复制值的函数\n        int (*keyCompare)(void *privdata, const void *key1, const void *key2);   \n        // 对比键的函数\n        void (*keyDestructor)(void *privdata, void *key);   \n        // 销毁键的函数\n        void (*valDestructor)(void *privdata, void *obj);       \n        // 销毁值的函数\n    } dictType;\n\n\n    /* This is our hash table structure. Every dictionary has two of this as we\n    * implement incremental rehashing, for the old to the new table. */\n    /* 哈希表\n    * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。\n    */\n    typedef struct dictht {\n        dictEntry **table;      // 哈希表数组，用链表方式解决冲突问题\n        unsigned long size;     // 哈希表大小\n        unsigned long sizemask; // 哈希表大小掩码，用于计算索引值，总是等于 size - 1\n        unsigned long used;     // 该哈希表已有节点的数量\n    } dictht;\n\n    /* 字典 */\n    typedef struct dict {\n        dictType *type;      // 类型特定函数\n        void *privdata;      // 私有数据\n        dictht ht[2];        // 哈希表\n        int rehashidx;       // rehash 索引，当 rehash 不在进行时，值为 -1\n        int iterators;       // 目前正在运行的安全迭代器的数量\n    } dict;\n\n\n![](http://ww2.sinaimg.cn/large/006tNc79ly1g4l9xmgd3oj312e0mejwm.jpg)\n哈希算法：\n    redis使用MurmurHash算法来计算键的哈希值。目前使用的是Murmurhash2。\n\n哈希冲突：\n    使用链地址法解决键冲突，为了速度考虑，总是将新节点添加到链表的表头位置。如下，k2插在k1前面。\n\n![](http://ww2.sinaimg.cn/large/006tNc79ly1g4l9zhs22lj31000u010z.jpg)\nrehash：\n    负载因子：load_factor = ht[0].used / ht[0].size\n\n哈希表的扩展：\n- 服务器没执行BGSAVE或BGREWRITEAOF命令，并且负载因子大于等于1.\n- 服务器正执行BGSAVE或BGREWRITEAOF命令，并且负载因子大于等于5.\n- 哈希表的收缩：当哈希表的负载因子小于0.1时，会自动收缩。\n\n- 步骤：\n    - 为字典的ht[1]分配空间，大小为：\n        - 若是扩展操作，则大小为第一个大于等于ht[0}.used*2的2^n;\n        - 若是收缩操作，则大小为第一个大于等于ht[0].used的2^n.\n    - 将保存在ht[0]中的所有键值rehash到ht[1]中（重新计算哈希值和索引值);\n    - 释放ht[0]中的所有键值对，将ht[1]设为ht[0]，并在ht[1]上创建一个空白的哈希表。\n\n渐进式rehash：\n- 若是键值对数量太大，那么若一次性rehash可能会导致服务器在一段时间内停止服务。因此可以采用分多次渐进式地将ht[0]的键值对慢慢地rehash到ht[1]中。\n\n- 步骤：\n    - 为ht[1]分配空间，让字典同时拥有ht[0]和ht[1]两个哈希表；\n    - 将rehashidx设为0，表示rehash正式开始；\n        - 在rehash期间，每次对字典进行添加、删除、查找或者更新操作时，除了执行指定操作外，还会顺带将ht[0]在rehashidx索引上的所有键值对rehash到ht[1]中，然后将rehashidx加1；\n        - 当ht[0]中所有的键值对全部rehash到ht[1]后，将rehashidx设为-1，rehash完成。\n\n在rehash期间，对字典进行增删查找操作时需要在ht[0]和ht[1]上操作。如查找要现在ht[0]查找，查不到再到ht[1]查找；如增加键值对，一律在ht[1]中增加，这样保证ht[0]中的键值对数量只减少不增加。\n\n### 跳跃表（zset）\n在跳跃表中，节点是按分数从小到大排序的。各个节点保存的成员对象必须是唯一的，但不同节点的分数可以相同，分数相同的节点按照成员对象在字典序中的大小来排序。\n\n    /* ZSETs use a specialized version of Skiplists */\n    /*  跳跃表节点 */\n    typedef struct zskiplistNode {\n        robj *obj;                         // 成员对象\n        double score;                      // 分值\n        struct zskiplistNode *backward;    // 后退指针\n        struct zskiplistLevel {            // 层\n            struct zskiplistNode *forward; // 前进指针\n            unsigned int span;             // 跨度\n        } level[];\n    } zskiplistNode;\n\n    /* 跳跃表 */\n    typedef struct zskiplist {\n        struct zskiplistNode *header, *tail; // 表头节点和表尾节点\n        unsigned long length;                // 表中节点的数量\n        int level;                           // 表中层数最大的节点的层数\n    } zskiplist;\n\n![](http://ww2.sinaimg.cn/large/006tNc79ly1g4la16rsynj31160fyafs.jpg)\n\n    /* 有序集合 */\n    typedef struct zset {\n        dict *dict; \n        // 字典，键为成员，值为分值， 用于支持 O(1) 复杂度的按成员取分值操作\n        zskiplist *zsl;\n        // 跳跃表，按分值排序成员，用于支持平均复杂度为 O(log N) 的按分值定位成员操作， 以及范围操作\n    } zset;\n\n### 整数集合（intset）\n\n    typedef struct intset {\n        uint32_t encoding;   // 编码方式\n        uint32_t length;     // 集合包含的元素数量\n        int8_t contents[];   // 保存元素的数组，从小到大排序，无重复\n    } intset;\n升级：若要添加一个新元素到整数集合中，并且新元素类型比整数集合元素的类型长，则整数集合需要先升级，才能将新元素放进集合中。\n\n步骤：\n\n- 根据新元素的类型，扩展整数集合底层数组（contents）的空间大小，并为新元素分配空间；\n- 将底层数组现有的所有元素都转换成与新元素相同的类型，并有序地放到正确的位置上；\n- 将新元素添加到底层数组中。\n\n    因为引发升级的新元素的长度总是比整数集合现有的所有元素的长度都大，所以该元素要么就大于所有现有元素，要不就小于现有所有元素，因此新元素要不就放在最开头要不就放在最末尾。\n    \n    不支持降级！\n\n### 压缩列表（ziplist）\n压缩列表是由一系列特殊编码的连续内存块组成的顺序型数据结构。\n\n压缩列表组成：\n\n![](http://ww4.sinaimg.cn/large/006tNc79ly1g4la3fjr3mj31800l8nbi.jpg)\n\n压缩节点构成：\n\n![](http://ww2.sinaimg.cn/large/006tNc79ly1g4la3q4w6zj30oc04q75l.jpg)\n\nprevious_entry_length：记录了压缩列表中前一个节点的长度（1或5字节）：\n- 若前一节点长度小于254字节，那么previous_entry_length长度为1字节；\n- 若前一节点长度大于等于254字节，那么previous_entry_length长度为5字节，其中第一字节为0xFE，后四个字节为长度。\nencoding：记录了节点content属性所保存的数据类型以及长度；\n\n![](http://ww1.sinaimg.cn/large/006tNc79ly1g4la4ar43zj31820o07hl.jpg)\n\ncontent：保存节点的值，可以是一个字节数组或者整数。\n\n### 对象\nredis基于之前介绍的数据结构，创建了一个对象系统，包括字符串对象、列表对象、哈希对象、集合对象以及有序集合对象这五类。\n\n    typedef struct redisObject {  \n        unsigned type:4;              // 类型\n        unsigned encoding:4;          // 编码\n        unsigned lru:REDIS_LRU_BITS;  // 对象最后一次被访问的时间\n        int refcount;                 // 引用计数\n        void *ptr;                    // 指向实际值的指针\n    } robj;\n\ntype：对象的类型\n\n![](http://ww3.sinaimg.cn/large/006tNc79ly1g4la53wfmjj30gy0cgwhk.jpg)\n\nredis会根据键对象的type属性进行类型检查，判断该键对象是否能执行指定的命令；如果可以则执行，否则拒绝执行并向客户端返回一个类型错误。\n\n若键能执行指定的指令，还会根据值对象的编码（encoding属性）方式，选择正确的命令实现代码执行命令。\n\nencoding：对象的编码，确定底层数据结构\n\n![](http://ww1.sinaimg.cn/large/006tNc79ly1g4la5mfswxj317m0fs0zt.jpg)\n\n\n每个类型的对象都有多种不同编码：\n\n![](http://ww4.sinaimg.cn/large/006tNc79ly1g4la64fp7dj316q0ks4dm.jpg)\n\nrefcount：引用计数，用于内存回收和共享内存。\n\n- 内存回收：一个对象被多个程序使用时，引用计数会增加；程序不再使用时引用计数会减少，当减少到为0时，释放对象所占内存。\n\n- 共享内存：redis服务器初始化时，会创建从0到9999共一万个字符串对象，当需要用到这些对象则共享对象而不是创建对象。\n\n    - 字符串对象\n\n        - 编码：int（整数）、raw（redisObject+SDS）或embstr（redisObject+embstr编码的SDS）\n\n        - 若是整数值，并且该整数值可以用long类型表示，则编码为int；若是字符串值，并且字符串长度大于32字节，那么将使用SDS保存字符串值，编码为raw；若是字符串值，并且字符串长度小于等于32字节，则编码为embstr。\n\n        - 注意：\n            - long double类型的浮点数是用字符串保存的，对其操作会先转化为浮点型进行操作再转化为字符串保存。\n            - 对int型操作（如APPEND一个字符串），会把int转化为raw。\n            embstr字符串为只读，若要对其修改会先转化为raw。\n\n    - 列表对象\n\n        - 编码：ziplist（压缩列表）或linkedlist（双端链表）\n\n        - 当列表对象保存的字符串元素都小于64字节，并且元素数量小于512个时，使用ziplist；否则使用linkedlist，每个节点保存一个字符串对象。\n    - 哈希对象\n\n        - 编码：ziplist（压缩列表）或hashtable（字典）\n\n        - 哈希对象中保存的所有键值对的键和值的字符串长度都小于64字节，并且键值对数量小于512个，使用ziplist；否则使用hashtable，键和值都为字符串对象。\n    - 集合对象\n        - 编码：intset（整数集合）或hashtable（字典）\n\n        - 集合对象保存的所有元素都是整数值，并且数量不超过512个时，使用intset；否则使用hashtable，若使用hashtable，每个键都为一个字符串对象，值为NULL。\n    - 有序集合对象\n        - 编码：ziplist（压缩列表）或skiplist（zset）\n\n        - 有序结合保存的元素数量小于128个，并且元素成员长度小于64字节，使用ziplist，每个结合元素使用两个压缩列表节点保存，第一个保存成员，第二个保存分数，集合元素按分值从小到大排序；\n        - 否则使用skiplist编码，底层为zset结构，包含一个字典和一个跳跃表，其中跳跃表按分值进行排序，实现了范围查询；而字典创建了从成员到分数的映射，键为集合元素，值为分数；字典和跳跃表都使用指针指向成员和分数，因此不会","source":"_posts/Redis底层数据笔记.md","raw":"---\ntitle: Redis底层数据笔记\ndate: 2019-07-02 10:54:47\ntags:\n- Redis\n---\n\n# redis底层数据结构以及对象系统\n\n## 底层数据结构\n## SDS（simple dynamic string，简单动态字符串）\n\n    /* 保存字符串对象的结构 */\n    struct sdshdr {\n        int len;       // buf 中已占用空间的长度\n        int free;      // buf 中剩余可用空间的长度\n        char buf[];    // 数据空间\n    };\n\n### SDS空间预分配：\n对SDS字符串进行扩展，如果free值大于扩展值则直接存储，否则重新分配空间：\n- 如果对SDS进行修改后字符串长度（len值）小于1MB，则额外分配len大小相同的空间（free值）；\n- 若SDS修改后len大于1MB，则额外分配1MB的空间（free值）。\n\n### SDS惰性空间释放：\n对SDS字符串进行缩短操作，并不会重新分配内存回收缩短的字节，而是使用free属性将这些字节的数量记录起来。\n\nredis保存的是SDS中的buf的二进制数据。SDS的API都是二进制安全的。\n\n\n![](http://ww3.sinaimg.cn/large/006tNc79ly1g4l9uj0wp9j30k305x0v2.jpg)\n### 链表\n双向链表\n\n    /* 双端链表节点 */\n    typedef struct listNode {\n        struct listNode *prev;      // 前置节点\n        struct listNode *next;      // 后置节点  \n        void *value;                // 节点的值\n    } listNode;\n\n![](http://ww3.sinaimg.cn/large/006tNc79ly1g4l9wbhheaj30j309042e.jpg)\n### 字典\n\n    /* 哈希表节点 */\n    typedef struct dictEntry {    \n        void *key;                // 键\n        union {                   // 值\n            void *val;\n            uint64_t u64;\n            int64_t s64;\n        } v;\n        struct dictEntry *next;   // 指向下个哈希表节点，形成链表\n\n    } dictEntry;\n\n    /*  字典类型特定函数 */\n    typedef struct dictType {\n        unsigned int (*hashFunction)(const void *key); \n        // 计算哈希值的函数\n        void *(*keyDup)(void *privdata, const void *key);  \n        // 复制键的函数\n        void *(*valDup)(void *privdata, const void *obj);               \n        // 复制值的函数\n        int (*keyCompare)(void *privdata, const void *key1, const void *key2);   \n        // 对比键的函数\n        void (*keyDestructor)(void *privdata, void *key);   \n        // 销毁键的函数\n        void (*valDestructor)(void *privdata, void *obj);       \n        // 销毁值的函数\n    } dictType;\n\n\n    /* This is our hash table structure. Every dictionary has two of this as we\n    * implement incremental rehashing, for the old to the new table. */\n    /* 哈希表\n    * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。\n    */\n    typedef struct dictht {\n        dictEntry **table;      // 哈希表数组，用链表方式解决冲突问题\n        unsigned long size;     // 哈希表大小\n        unsigned long sizemask; // 哈希表大小掩码，用于计算索引值，总是等于 size - 1\n        unsigned long used;     // 该哈希表已有节点的数量\n    } dictht;\n\n    /* 字典 */\n    typedef struct dict {\n        dictType *type;      // 类型特定函数\n        void *privdata;      // 私有数据\n        dictht ht[2];        // 哈希表\n        int rehashidx;       // rehash 索引，当 rehash 不在进行时，值为 -1\n        int iterators;       // 目前正在运行的安全迭代器的数量\n    } dict;\n\n\n![](http://ww2.sinaimg.cn/large/006tNc79ly1g4l9xmgd3oj312e0mejwm.jpg)\n哈希算法：\n    redis使用MurmurHash算法来计算键的哈希值。目前使用的是Murmurhash2。\n\n哈希冲突：\n    使用链地址法解决键冲突，为了速度考虑，总是将新节点添加到链表的表头位置。如下，k2插在k1前面。\n\n![](http://ww2.sinaimg.cn/large/006tNc79ly1g4l9zhs22lj31000u010z.jpg)\nrehash：\n    负载因子：load_factor = ht[0].used / ht[0].size\n\n哈希表的扩展：\n- 服务器没执行BGSAVE或BGREWRITEAOF命令，并且负载因子大于等于1.\n- 服务器正执行BGSAVE或BGREWRITEAOF命令，并且负载因子大于等于5.\n- 哈希表的收缩：当哈希表的负载因子小于0.1时，会自动收缩。\n\n- 步骤：\n    - 为字典的ht[1]分配空间，大小为：\n        - 若是扩展操作，则大小为第一个大于等于ht[0}.used*2的2^n;\n        - 若是收缩操作，则大小为第一个大于等于ht[0].used的2^n.\n    - 将保存在ht[0]中的所有键值rehash到ht[1]中（重新计算哈希值和索引值);\n    - 释放ht[0]中的所有键值对，将ht[1]设为ht[0]，并在ht[1]上创建一个空白的哈希表。\n\n渐进式rehash：\n- 若是键值对数量太大，那么若一次性rehash可能会导致服务器在一段时间内停止服务。因此可以采用分多次渐进式地将ht[0]的键值对慢慢地rehash到ht[1]中。\n\n- 步骤：\n    - 为ht[1]分配空间，让字典同时拥有ht[0]和ht[1]两个哈希表；\n    - 将rehashidx设为0，表示rehash正式开始；\n        - 在rehash期间，每次对字典进行添加、删除、查找或者更新操作时，除了执行指定操作外，还会顺带将ht[0]在rehashidx索引上的所有键值对rehash到ht[1]中，然后将rehashidx加1；\n        - 当ht[0]中所有的键值对全部rehash到ht[1]后，将rehashidx设为-1，rehash完成。\n\n在rehash期间，对字典进行增删查找操作时需要在ht[0]和ht[1]上操作。如查找要现在ht[0]查找，查不到再到ht[1]查找；如增加键值对，一律在ht[1]中增加，这样保证ht[0]中的键值对数量只减少不增加。\n\n### 跳跃表（zset）\n在跳跃表中，节点是按分数从小到大排序的。各个节点保存的成员对象必须是唯一的，但不同节点的分数可以相同，分数相同的节点按照成员对象在字典序中的大小来排序。\n\n    /* ZSETs use a specialized version of Skiplists */\n    /*  跳跃表节点 */\n    typedef struct zskiplistNode {\n        robj *obj;                         // 成员对象\n        double score;                      // 分值\n        struct zskiplistNode *backward;    // 后退指针\n        struct zskiplistLevel {            // 层\n            struct zskiplistNode *forward; // 前进指针\n            unsigned int span;             // 跨度\n        } level[];\n    } zskiplistNode;\n\n    /* 跳跃表 */\n    typedef struct zskiplist {\n        struct zskiplistNode *header, *tail; // 表头节点和表尾节点\n        unsigned long length;                // 表中节点的数量\n        int level;                           // 表中层数最大的节点的层数\n    } zskiplist;\n\n![](http://ww2.sinaimg.cn/large/006tNc79ly1g4la16rsynj31160fyafs.jpg)\n\n    /* 有序集合 */\n    typedef struct zset {\n        dict *dict; \n        // 字典，键为成员，值为分值， 用于支持 O(1) 复杂度的按成员取分值操作\n        zskiplist *zsl;\n        // 跳跃表，按分值排序成员，用于支持平均复杂度为 O(log N) 的按分值定位成员操作， 以及范围操作\n    } zset;\n\n### 整数集合（intset）\n\n    typedef struct intset {\n        uint32_t encoding;   // 编码方式\n        uint32_t length;     // 集合包含的元素数量\n        int8_t contents[];   // 保存元素的数组，从小到大排序，无重复\n    } intset;\n升级：若要添加一个新元素到整数集合中，并且新元素类型比整数集合元素的类型长，则整数集合需要先升级，才能将新元素放进集合中。\n\n步骤：\n\n- 根据新元素的类型，扩展整数集合底层数组（contents）的空间大小，并为新元素分配空间；\n- 将底层数组现有的所有元素都转换成与新元素相同的类型，并有序地放到正确的位置上；\n- 将新元素添加到底层数组中。\n\n    因为引发升级的新元素的长度总是比整数集合现有的所有元素的长度都大，所以该元素要么就大于所有现有元素，要不就小于现有所有元素，因此新元素要不就放在最开头要不就放在最末尾。\n    \n    不支持降级！\n\n### 压缩列表（ziplist）\n压缩列表是由一系列特殊编码的连续内存块组成的顺序型数据结构。\n\n压缩列表组成：\n\n![](http://ww4.sinaimg.cn/large/006tNc79ly1g4la3fjr3mj31800l8nbi.jpg)\n\n压缩节点构成：\n\n![](http://ww2.sinaimg.cn/large/006tNc79ly1g4la3q4w6zj30oc04q75l.jpg)\n\nprevious_entry_length：记录了压缩列表中前一个节点的长度（1或5字节）：\n- 若前一节点长度小于254字节，那么previous_entry_length长度为1字节；\n- 若前一节点长度大于等于254字节，那么previous_entry_length长度为5字节，其中第一字节为0xFE，后四个字节为长度。\nencoding：记录了节点content属性所保存的数据类型以及长度；\n\n![](http://ww1.sinaimg.cn/large/006tNc79ly1g4la4ar43zj31820o07hl.jpg)\n\ncontent：保存节点的值，可以是一个字节数组或者整数。\n\n### 对象\nredis基于之前介绍的数据结构，创建了一个对象系统，包括字符串对象、列表对象、哈希对象、集合对象以及有序集合对象这五类。\n\n    typedef struct redisObject {  \n        unsigned type:4;              // 类型\n        unsigned encoding:4;          // 编码\n        unsigned lru:REDIS_LRU_BITS;  // 对象最后一次被访问的时间\n        int refcount;                 // 引用计数\n        void *ptr;                    // 指向实际值的指针\n    } robj;\n\ntype：对象的类型\n\n![](http://ww3.sinaimg.cn/large/006tNc79ly1g4la53wfmjj30gy0cgwhk.jpg)\n\nredis会根据键对象的type属性进行类型检查，判断该键对象是否能执行指定的命令；如果可以则执行，否则拒绝执行并向客户端返回一个类型错误。\n\n若键能执行指定的指令，还会根据值对象的编码（encoding属性）方式，选择正确的命令实现代码执行命令。\n\nencoding：对象的编码，确定底层数据结构\n\n![](http://ww1.sinaimg.cn/large/006tNc79ly1g4la5mfswxj317m0fs0zt.jpg)\n\n\n每个类型的对象都有多种不同编码：\n\n![](http://ww4.sinaimg.cn/large/006tNc79ly1g4la64fp7dj316q0ks4dm.jpg)\n\nrefcount：引用计数，用于内存回收和共享内存。\n\n- 内存回收：一个对象被多个程序使用时，引用计数会增加；程序不再使用时引用计数会减少，当减少到为0时，释放对象所占内存。\n\n- 共享内存：redis服务器初始化时，会创建从0到9999共一万个字符串对象，当需要用到这些对象则共享对象而不是创建对象。\n\n    - 字符串对象\n\n        - 编码：int（整数）、raw（redisObject+SDS）或embstr（redisObject+embstr编码的SDS）\n\n        - 若是整数值，并且该整数值可以用long类型表示，则编码为int；若是字符串值，并且字符串长度大于32字节，那么将使用SDS保存字符串值，编码为raw；若是字符串值，并且字符串长度小于等于32字节，则编码为embstr。\n\n        - 注意：\n            - long double类型的浮点数是用字符串保存的，对其操作会先转化为浮点型进行操作再转化为字符串保存。\n            - 对int型操作（如APPEND一个字符串），会把int转化为raw。\n            embstr字符串为只读，若要对其修改会先转化为raw。\n\n    - 列表对象\n\n        - 编码：ziplist（压缩列表）或linkedlist（双端链表）\n\n        - 当列表对象保存的字符串元素都小于64字节，并且元素数量小于512个时，使用ziplist；否则使用linkedlist，每个节点保存一个字符串对象。\n    - 哈希对象\n\n        - 编码：ziplist（压缩列表）或hashtable（字典）\n\n        - 哈希对象中保存的所有键值对的键和值的字符串长度都小于64字节，并且键值对数量小于512个，使用ziplist；否则使用hashtable，键和值都为字符串对象。\n    - 集合对象\n        - 编码：intset（整数集合）或hashtable（字典）\n\n        - 集合对象保存的所有元素都是整数值，并且数量不超过512个时，使用intset；否则使用hashtable，若使用hashtable，每个键都为一个字符串对象，值为NULL。\n    - 有序集合对象\n        - 编码：ziplist（压缩列表）或skiplist（zset）\n\n        - 有序结合保存的元素数量小于128个，并且元素成员长度小于64字节，使用ziplist，每个结合元素使用两个压缩列表节点保存，第一个保存成员，第二个保存分数，集合元素按分值从小到大排序；\n        - 否则使用skiplist编码，底层为zset结构，包含一个字典和一个跳跃表，其中跳跃表按分值进行排序，实现了范围查询；而字典创建了从成员到分数的映射，键为集合元素，值为分数；字典和跳跃表都使用指针指向成员和分数，因此不会","slug":"Redis底层数据笔记","published":1,"updated":"2019-12-30T06:40:13.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9m4gt8m002dupqe2tnk3rls","content":"<h1 id=\"redis底层数据结构以及对象系统\"><a href=\"#redis底层数据结构以及对象系统\" class=\"headerlink\" title=\"redis底层数据结构以及对象系统\"></a>redis底层数据结构以及对象系统</h1><h2 id=\"底层数据结构\"><a href=\"#底层数据结构\" class=\"headerlink\" title=\"底层数据结构\"></a>底层数据结构</h2><h2 id=\"SDS（simple-dynamic-string，简单动态字符串）\"><a href=\"#SDS（simple-dynamic-string，简单动态字符串）\" class=\"headerlink\" title=\"SDS（simple dynamic string，简单动态字符串）\"></a>SDS（simple dynamic string，简单动态字符串）</h2><pre><code>/* 保存字符串对象的结构 */\nstruct sdshdr {\n    int len;       // buf 中已占用空间的长度\n    int free;      // buf 中剩余可用空间的长度\n    char buf[];    // 数据空间\n};\n</code></pre><h3 id=\"SDS空间预分配：\"><a href=\"#SDS空间预分配：\" class=\"headerlink\" title=\"SDS空间预分配：\"></a>SDS空间预分配：</h3><p>对SDS字符串进行扩展，如果free值大于扩展值则直接存储，否则重新分配空间：</p>\n<ul>\n<li>如果对SDS进行修改后字符串长度（len值）小于1MB，则额外分配len大小相同的空间（free值）；</li>\n<li>若SDS修改后len大于1MB，则额外分配1MB的空间（free值）。</li>\n</ul>\n<h3 id=\"SDS惰性空间释放：\"><a href=\"#SDS惰性空间释放：\" class=\"headerlink\" title=\"SDS惰性空间释放：\"></a>SDS惰性空间释放：</h3><p>对SDS字符串进行缩短操作，并不会重新分配内存回收缩短的字节，而是使用free属性将这些字节的数量记录起来。</p>\n<p>redis保存的是SDS中的buf的二进制数据。SDS的API都是二进制安全的。</p>\n<p><img src=\"http://ww3.sinaimg.cn/large/006tNc79ly1g4l9uj0wp9j30k305x0v2.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><p>双向链表</p>\n<pre><code>/* 双端链表节点 */\ntypedef struct listNode {\n    struct listNode *prev;      // 前置节点\n    struct listNode *next;      // 后置节点  \n    void *value;                // 节点的值\n} listNode;\n</code></pre><p><img src=\"http://ww3.sinaimg.cn/large/006tNc79ly1g4l9wbhheaj30j309042e.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h3><pre><code>/* 哈希表节点 */\ntypedef struct dictEntry {    \n    void *key;                // 键\n    union {                   // 值\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n    } v;\n    struct dictEntry *next;   // 指向下个哈希表节点，形成链表\n\n} dictEntry;\n\n/*  字典类型特定函数 */\ntypedef struct dictType {\n    unsigned int (*hashFunction)(const void *key); \n    // 计算哈希值的函数\n    void *(*keyDup)(void *privdata, const void *key);  \n    // 复制键的函数\n    void *(*valDup)(void *privdata, const void *obj);               \n    // 复制值的函数\n    int (*keyCompare)(void *privdata, const void *key1, const void *key2);   \n    // 对比键的函数\n    void (*keyDestructor)(void *privdata, void *key);   \n    // 销毁键的函数\n    void (*valDestructor)(void *privdata, void *obj);       \n    // 销毁值的函数\n} dictType;\n\n\n/* This is our hash table structure. Every dictionary has two of this as we\n* implement incremental rehashing, for the old to the new table. */\n/* 哈希表\n* 每个字典都使用两个哈希表，从而实现渐进式 rehash 。\n*/\ntypedef struct dictht {\n    dictEntry **table;      // 哈希表数组，用链表方式解决冲突问题\n    unsigned long size;     // 哈希表大小\n    unsigned long sizemask; // 哈希表大小掩码，用于计算索引值，总是等于 size - 1\n    unsigned long used;     // 该哈希表已有节点的数量\n} dictht;\n\n/* 字典 */\ntypedef struct dict {\n    dictType *type;      // 类型特定函数\n    void *privdata;      // 私有数据\n    dictht ht[2];        // 哈希表\n    int rehashidx;       // rehash 索引，当 rehash 不在进行时，值为 -1\n    int iterators;       // 目前正在运行的安全迭代器的数量\n} dict;\n</code></pre><p><img src=\"http://ww2.sinaimg.cn/large/006tNc79ly1g4l9xmgd3oj312e0mejwm.jpg\" srcset=\"/img/loading.gif\" alt><br>哈希算法：<br>    redis使用MurmurHash算法来计算键的哈希值。目前使用的是Murmurhash2。</p>\n<p>哈希冲突：<br>    使用链地址法解决键冲突，为了速度考虑，总是将新节点添加到链表的表头位置。如下，k2插在k1前面。</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/006tNc79ly1g4l9zhs22lj31000u010z.jpg\" srcset=\"/img/loading.gif\" alt><br>rehash：<br>    负载因子：load_factor = ht[0].used / ht[0].size</p>\n<p>哈希表的扩展：</p>\n<ul>\n<li>服务器没执行BGSAVE或BGREWRITEAOF命令，并且负载因子大于等于1.</li>\n<li>服务器正执行BGSAVE或BGREWRITEAOF命令，并且负载因子大于等于5.</li>\n<li><p>哈希表的收缩：当哈希表的负载因子小于0.1时，会自动收缩。</p>\n</li>\n<li><p>步骤：</p>\n<ul>\n<li>为字典的ht[1]分配空间，大小为：<ul>\n<li>若是扩展操作，则大小为第一个大于等于ht[0}.used*2的2^n;</li>\n<li>若是收缩操作，则大小为第一个大于等于ht[0].used的2^n.</li>\n</ul>\n</li>\n<li>将保存在ht[0]中的所有键值rehash到ht[1]中（重新计算哈希值和索引值);</li>\n<li>释放ht[0]中的所有键值对，将ht[1]设为ht[0]，并在ht[1]上创建一个空白的哈希表。</li>\n</ul>\n</li>\n</ul>\n<p>渐进式rehash：</p>\n<ul>\n<li><p>若是键值对数量太大，那么若一次性rehash可能会导致服务器在一段时间内停止服务。因此可以采用分多次渐进式地将ht[0]的键值对慢慢地rehash到ht[1]中。</p>\n</li>\n<li><p>步骤：</p>\n<ul>\n<li>为ht[1]分配空间，让字典同时拥有ht[0]和ht[1]两个哈希表；</li>\n<li>将rehashidx设为0，表示rehash正式开始；<ul>\n<li>在rehash期间，每次对字典进行添加、删除、查找或者更新操作时，除了执行指定操作外，还会顺带将ht[0]在rehashidx索引上的所有键值对rehash到ht[1]中，然后将rehashidx加1；</li>\n<li>当ht[0]中所有的键值对全部rehash到ht[1]后，将rehashidx设为-1，rehash完成。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>在rehash期间，对字典进行增删查找操作时需要在ht[0]和ht[1]上操作。如查找要现在ht[0]查找，查不到再到ht[1]查找；如增加键值对，一律在ht[1]中增加，这样保证ht[0]中的键值对数量只减少不增加。</p>\n<h3 id=\"跳跃表（zset）\"><a href=\"#跳跃表（zset）\" class=\"headerlink\" title=\"跳跃表（zset）\"></a>跳跃表（zset）</h3><p>在跳跃表中，节点是按分数从小到大排序的。各个节点保存的成员对象必须是唯一的，但不同节点的分数可以相同，分数相同的节点按照成员对象在字典序中的大小来排序。</p>\n<pre><code>/* ZSETs use a specialized version of Skiplists */\n/*  跳跃表节点 */\ntypedef struct zskiplistNode {\n    robj *obj;                         // 成员对象\n    double score;                      // 分值\n    struct zskiplistNode *backward;    // 后退指针\n    struct zskiplistLevel {            // 层\n        struct zskiplistNode *forward; // 前进指针\n        unsigned int span;             // 跨度\n    } level[];\n} zskiplistNode;\n\n/* 跳跃表 */\ntypedef struct zskiplist {\n    struct zskiplistNode *header, *tail; // 表头节点和表尾节点\n    unsigned long length;                // 表中节点的数量\n    int level;                           // 表中层数最大的节点的层数\n} zskiplist;\n</code></pre><p><img src=\"http://ww2.sinaimg.cn/large/006tNc79ly1g4la16rsynj31160fyafs.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<pre><code>/* 有序集合 */\ntypedef struct zset {\n    dict *dict; \n    // 字典，键为成员，值为分值， 用于支持 O(1) 复杂度的按成员取分值操作\n    zskiplist *zsl;\n    // 跳跃表，按分值排序成员，用于支持平均复杂度为 O(log N) 的按分值定位成员操作， 以及范围操作\n} zset;\n</code></pre><h3 id=\"整数集合（intset）\"><a href=\"#整数集合（intset）\" class=\"headerlink\" title=\"整数集合（intset）\"></a>整数集合（intset）</h3><pre><code>typedef struct intset {\n    uint32_t encoding;   // 编码方式\n    uint32_t length;     // 集合包含的元素数量\n    int8_t contents[];   // 保存元素的数组，从小到大排序，无重复\n} intset;\n</code></pre><p>升级：若要添加一个新元素到整数集合中，并且新元素类型比整数集合元素的类型长，则整数集合需要先升级，才能将新元素放进集合中。</p>\n<p>步骤：</p>\n<ul>\n<li>根据新元素的类型，扩展整数集合底层数组（contents）的空间大小，并为新元素分配空间；</li>\n<li>将底层数组现有的所有元素都转换成与新元素相同的类型，并有序地放到正确的位置上；</li>\n<li><p>将新元素添加到底层数组中。</p>\n<p>  因为引发升级的新元素的长度总是比整数集合现有的所有元素的长度都大，所以该元素要么就大于所有现有元素，要不就小于现有所有元素，因此新元素要不就放在最开头要不就放在最末尾。</p>\n<p>  不支持降级！</p>\n</li>\n</ul>\n<h3 id=\"压缩列表（ziplist）\"><a href=\"#压缩列表（ziplist）\" class=\"headerlink\" title=\"压缩列表（ziplist）\"></a>压缩列表（ziplist）</h3><p>压缩列表是由一系列特殊编码的连续内存块组成的顺序型数据结构。</p>\n<p>压缩列表组成：</p>\n<p><img src=\"http://ww4.sinaimg.cn/large/006tNc79ly1g4la3fjr3mj31800l8nbi.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<p>压缩节点构成：</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/006tNc79ly1g4la3q4w6zj30oc04q75l.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<p>previous_entry_length：记录了压缩列表中前一个节点的长度（1或5字节）：</p>\n<ul>\n<li>若前一节点长度小于254字节，那么previous_entry_length长度为1字节；</li>\n<li>若前一节点长度大于等于254字节，那么previous_entry_length长度为5字节，其中第一字节为0xFE，后四个字节为长度。<br>encoding：记录了节点content属性所保存的数据类型以及长度；</li>\n</ul>\n<p><img src=\"http://ww1.sinaimg.cn/large/006tNc79ly1g4la4ar43zj31820o07hl.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<p>content：保存节点的值，可以是一个字节数组或者整数。</p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>redis基于之前介绍的数据结构，创建了一个对象系统，包括字符串对象、列表对象、哈希对象、集合对象以及有序集合对象这五类。</p>\n<pre><code>typedef struct redisObject {  \n    unsigned type:4;              // 类型\n    unsigned encoding:4;          // 编码\n    unsigned lru:REDIS_LRU_BITS;  // 对象最后一次被访问的时间\n    int refcount;                 // 引用计数\n    void *ptr;                    // 指向实际值的指针\n} robj;\n</code></pre><p>type：对象的类型</p>\n<p><img src=\"http://ww3.sinaimg.cn/large/006tNc79ly1g4la53wfmjj30gy0cgwhk.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<p>redis会根据键对象的type属性进行类型检查，判断该键对象是否能执行指定的命令；如果可以则执行，否则拒绝执行并向客户端返回一个类型错误。</p>\n<p>若键能执行指定的指令，还会根据值对象的编码（encoding属性）方式，选择正确的命令实现代码执行命令。</p>\n<p>encoding：对象的编码，确定底层数据结构</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006tNc79ly1g4la5mfswxj317m0fs0zt.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<p>每个类型的对象都有多种不同编码：</p>\n<p><img src=\"http://ww4.sinaimg.cn/large/006tNc79ly1g4la64fp7dj316q0ks4dm.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<p>refcount：引用计数，用于内存回收和共享内存。</p>\n<ul>\n<li><p>内存回收：一个对象被多个程序使用时，引用计数会增加；程序不再使用时引用计数会减少，当减少到为0时，释放对象所占内存。</p>\n</li>\n<li><p>共享内存：redis服务器初始化时，会创建从0到9999共一万个字符串对象，当需要用到这些对象则共享对象而不是创建对象。</p>\n<ul>\n<li><p>字符串对象</p>\n<ul>\n<li><p>编码：int（整数）、raw（redisObject+SDS）或embstr（redisObject+embstr编码的SDS）</p>\n</li>\n<li><p>若是整数值，并且该整数值可以用long类型表示，则编码为int；若是字符串值，并且字符串长度大于32字节，那么将使用SDS保存字符串值，编码为raw；若是字符串值，并且字符串长度小于等于32字节，则编码为embstr。</p>\n</li>\n<li><p>注意：</p>\n<ul>\n<li>long double类型的浮点数是用字符串保存的，对其操作会先转化为浮点型进行操作再转化为字符串保存。</li>\n<li>对int型操作（如APPEND一个字符串），会把int转化为raw。<br>embstr字符串为只读，若要对其修改会先转化为raw。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>列表对象</p>\n<ul>\n<li><p>编码：ziplist（压缩列表）或linkedlist（双端链表）</p>\n</li>\n<li><p>当列表对象保存的字符串元素都小于64字节，并且元素数量小于512个时，使用ziplist；否则使用linkedlist，每个节点保存一个字符串对象。</p>\n</li>\n</ul>\n</li>\n<li><p>哈希对象</p>\n<ul>\n<li><p>编码：ziplist（压缩列表）或hashtable（字典）</p>\n</li>\n<li><p>哈希对象中保存的所有键值对的键和值的字符串长度都小于64字节，并且键值对数量小于512个，使用ziplist；否则使用hashtable，键和值都为字符串对象。</p>\n</li>\n</ul>\n</li>\n<li><p>集合对象</p>\n<ul>\n<li><p>编码：intset（整数集合）或hashtable（字典）</p>\n</li>\n<li><p>集合对象保存的所有元素都是整数值，并且数量不超过512个时，使用intset；否则使用hashtable，若使用hashtable，每个键都为一个字符串对象，值为NULL。</p>\n</li>\n</ul>\n</li>\n<li><p>有序集合对象</p>\n<ul>\n<li><p>编码：ziplist（压缩列表）或skiplist（zset）</p>\n</li>\n<li><p>有序结合保存的元素数量小于128个，并且元素成员长度小于64字节，使用ziplist，每个结合元素使用两个压缩列表节点保存，第一个保存成员，第二个保存分数，集合元素按分值从小到大排序；</p>\n</li>\n<li>否则使用skiplist编码，底层为zset结构，包含一个字典和一个跳跃表，其中跳跃表按分值进行排序，实现了范围查询；而字典创建了从成员到分数的映射，键为集合元素，值为分数；字典和跳跃表都使用指针指向成员和分数，因此不会</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"redis底层数据结构以及对象系统\"><a href=\"#redis底层数据结构以及对象系统\" class=\"headerlink\" title=\"redis底层数据结构以及对象系统\"></a>redis底层数据结构以及对象系统</h1><h2 id=\"底层数据结构\"><a href=\"#底层数据结构\" class=\"headerlink\" title=\"底层数据结构\"></a>底层数据结构</h2><h2 id=\"SDS（simple-dynamic-string，简单动态字符串）\"><a href=\"#SDS（simple-dynamic-string，简单动态字符串）\" class=\"headerlink\" title=\"SDS（simple dynamic string，简单动态字符串）\"></a>SDS（simple dynamic string，简单动态字符串）</h2><pre><code>/* 保存字符串对象的结构 */\nstruct sdshdr {\n    int len;       // buf 中已占用空间的长度\n    int free;      // buf 中剩余可用空间的长度\n    char buf[];    // 数据空间\n};\n</code></pre><h3 id=\"SDS空间预分配：\"><a href=\"#SDS空间预分配：\" class=\"headerlink\" title=\"SDS空间预分配：\"></a>SDS空间预分配：</h3><p>对SDS字符串进行扩展，如果free值大于扩展值则直接存储，否则重新分配空间：</p>\n<ul>\n<li>如果对SDS进行修改后字符串长度（len值）小于1MB，则额外分配len大小相同的空间（free值）；</li>\n<li>若SDS修改后len大于1MB，则额外分配1MB的空间（free值）。</li>\n</ul>\n<h3 id=\"SDS惰性空间释放：\"><a href=\"#SDS惰性空间释放：\" class=\"headerlink\" title=\"SDS惰性空间释放：\"></a>SDS惰性空间释放：</h3><p>对SDS字符串进行缩短操作，并不会重新分配内存回收缩短的字节，而是使用free属性将这些字节的数量记录起来。</p>\n<p>redis保存的是SDS中的buf的二进制数据。SDS的API都是二进制安全的。</p>\n<p><img src=\"http://ww3.sinaimg.cn/large/006tNc79ly1g4l9uj0wp9j30k305x0v2.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><p>双向链表</p>\n<pre><code>/* 双端链表节点 */\ntypedef struct listNode {\n    struct listNode *prev;      // 前置节点\n    struct listNode *next;      // 后置节点  \n    void *value;                // 节点的值\n} listNode;\n</code></pre><p><img src=\"http://ww3.sinaimg.cn/large/006tNc79ly1g4l9wbhheaj30j309042e.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h3><pre><code>/* 哈希表节点 */\ntypedef struct dictEntry {    \n    void *key;                // 键\n    union {                   // 值\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n    } v;\n    struct dictEntry *next;   // 指向下个哈希表节点，形成链表\n\n} dictEntry;\n\n/*  字典类型特定函数 */\ntypedef struct dictType {\n    unsigned int (*hashFunction)(const void *key); \n    // 计算哈希值的函数\n    void *(*keyDup)(void *privdata, const void *key);  \n    // 复制键的函数\n    void *(*valDup)(void *privdata, const void *obj);               \n    // 复制值的函数\n    int (*keyCompare)(void *privdata, const void *key1, const void *key2);   \n    // 对比键的函数\n    void (*keyDestructor)(void *privdata, void *key);   \n    // 销毁键的函数\n    void (*valDestructor)(void *privdata, void *obj);       \n    // 销毁值的函数\n} dictType;\n\n\n/* This is our hash table structure. Every dictionary has two of this as we\n* implement incremental rehashing, for the old to the new table. */\n/* 哈希表\n* 每个字典都使用两个哈希表，从而实现渐进式 rehash 。\n*/\ntypedef struct dictht {\n    dictEntry **table;      // 哈希表数组，用链表方式解决冲突问题\n    unsigned long size;     // 哈希表大小\n    unsigned long sizemask; // 哈希表大小掩码，用于计算索引值，总是等于 size - 1\n    unsigned long used;     // 该哈希表已有节点的数量\n} dictht;\n\n/* 字典 */\ntypedef struct dict {\n    dictType *type;      // 类型特定函数\n    void *privdata;      // 私有数据\n    dictht ht[2];        // 哈希表\n    int rehashidx;       // rehash 索引，当 rehash 不在进行时，值为 -1\n    int iterators;       // 目前正在运行的安全迭代器的数量\n} dict;\n</code></pre><p><img src=\"http://ww2.sinaimg.cn/large/006tNc79ly1g4l9xmgd3oj312e0mejwm.jpg\" srcset=\"/img/loading.gif\" alt><br>哈希算法：<br>    redis使用MurmurHash算法来计算键的哈希值。目前使用的是Murmurhash2。</p>\n<p>哈希冲突：<br>    使用链地址法解决键冲突，为了速度考虑，总是将新节点添加到链表的表头位置。如下，k2插在k1前面。</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/006tNc79ly1g4l9zhs22lj31000u010z.jpg\" srcset=\"/img/loading.gif\" alt><br>rehash：<br>    负载因子：load_factor = ht[0].used / ht[0].size</p>\n<p>哈希表的扩展：</p>\n<ul>\n<li>服务器没执行BGSAVE或BGREWRITEAOF命令，并且负载因子大于等于1.</li>\n<li>服务器正执行BGSAVE或BGREWRITEAOF命令，并且负载因子大于等于5.</li>\n<li><p>哈希表的收缩：当哈希表的负载因子小于0.1时，会自动收缩。</p>\n</li>\n<li><p>步骤：</p>\n<ul>\n<li>为字典的ht[1]分配空间，大小为：<ul>\n<li>若是扩展操作，则大小为第一个大于等于ht[0}.used*2的2^n;</li>\n<li>若是收缩操作，则大小为第一个大于等于ht[0].used的2^n.</li>\n</ul>\n</li>\n<li>将保存在ht[0]中的所有键值rehash到ht[1]中（重新计算哈希值和索引值);</li>\n<li>释放ht[0]中的所有键值对，将ht[1]设为ht[0]，并在ht[1]上创建一个空白的哈希表。</li>\n</ul>\n</li>\n</ul>\n<p>渐进式rehash：</p>\n<ul>\n<li><p>若是键值对数量太大，那么若一次性rehash可能会导致服务器在一段时间内停止服务。因此可以采用分多次渐进式地将ht[0]的键值对慢慢地rehash到ht[1]中。</p>\n</li>\n<li><p>步骤：</p>\n<ul>\n<li>为ht[1]分配空间，让字典同时拥有ht[0]和ht[1]两个哈希表；</li>\n<li>将rehashidx设为0，表示rehash正式开始；<ul>\n<li>在rehash期间，每次对字典进行添加、删除、查找或者更新操作时，除了执行指定操作外，还会顺带将ht[0]在rehashidx索引上的所有键值对rehash到ht[1]中，然后将rehashidx加1；</li>\n<li>当ht[0]中所有的键值对全部rehash到ht[1]后，将rehashidx设为-1，rehash完成。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>在rehash期间，对字典进行增删查找操作时需要在ht[0]和ht[1]上操作。如查找要现在ht[0]查找，查不到再到ht[1]查找；如增加键值对，一律在ht[1]中增加，这样保证ht[0]中的键值对数量只减少不增加。</p>\n<h3 id=\"跳跃表（zset）\"><a href=\"#跳跃表（zset）\" class=\"headerlink\" title=\"跳跃表（zset）\"></a>跳跃表（zset）</h3><p>在跳跃表中，节点是按分数从小到大排序的。各个节点保存的成员对象必须是唯一的，但不同节点的分数可以相同，分数相同的节点按照成员对象在字典序中的大小来排序。</p>\n<pre><code>/* ZSETs use a specialized version of Skiplists */\n/*  跳跃表节点 */\ntypedef struct zskiplistNode {\n    robj *obj;                         // 成员对象\n    double score;                      // 分值\n    struct zskiplistNode *backward;    // 后退指针\n    struct zskiplistLevel {            // 层\n        struct zskiplistNode *forward; // 前进指针\n        unsigned int span;             // 跨度\n    } level[];\n} zskiplistNode;\n\n/* 跳跃表 */\ntypedef struct zskiplist {\n    struct zskiplistNode *header, *tail; // 表头节点和表尾节点\n    unsigned long length;                // 表中节点的数量\n    int level;                           // 表中层数最大的节点的层数\n} zskiplist;\n</code></pre><p><img src=\"http://ww2.sinaimg.cn/large/006tNc79ly1g4la16rsynj31160fyafs.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<pre><code>/* 有序集合 */\ntypedef struct zset {\n    dict *dict; \n    // 字典，键为成员，值为分值， 用于支持 O(1) 复杂度的按成员取分值操作\n    zskiplist *zsl;\n    // 跳跃表，按分值排序成员，用于支持平均复杂度为 O(log N) 的按分值定位成员操作， 以及范围操作\n} zset;\n</code></pre><h3 id=\"整数集合（intset）\"><a href=\"#整数集合（intset）\" class=\"headerlink\" title=\"整数集合（intset）\"></a>整数集合（intset）</h3><pre><code>typedef struct intset {\n    uint32_t encoding;   // 编码方式\n    uint32_t length;     // 集合包含的元素数量\n    int8_t contents[];   // 保存元素的数组，从小到大排序，无重复\n} intset;\n</code></pre><p>升级：若要添加一个新元素到整数集合中，并且新元素类型比整数集合元素的类型长，则整数集合需要先升级，才能将新元素放进集合中。</p>\n<p>步骤：</p>\n<ul>\n<li>根据新元素的类型，扩展整数集合底层数组（contents）的空间大小，并为新元素分配空间；</li>\n<li>将底层数组现有的所有元素都转换成与新元素相同的类型，并有序地放到正确的位置上；</li>\n<li><p>将新元素添加到底层数组中。</p>\n<p>  因为引发升级的新元素的长度总是比整数集合现有的所有元素的长度都大，所以该元素要么就大于所有现有元素，要不就小于现有所有元素，因此新元素要不就放在最开头要不就放在最末尾。</p>\n<p>  不支持降级！</p>\n</li>\n</ul>\n<h3 id=\"压缩列表（ziplist）\"><a href=\"#压缩列表（ziplist）\" class=\"headerlink\" title=\"压缩列表（ziplist）\"></a>压缩列表（ziplist）</h3><p>压缩列表是由一系列特殊编码的连续内存块组成的顺序型数据结构。</p>\n<p>压缩列表组成：</p>\n<p><img src=\"http://ww4.sinaimg.cn/large/006tNc79ly1g4la3fjr3mj31800l8nbi.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<p>压缩节点构成：</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/006tNc79ly1g4la3q4w6zj30oc04q75l.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<p>previous_entry_length：记录了压缩列表中前一个节点的长度（1或5字节）：</p>\n<ul>\n<li>若前一节点长度小于254字节，那么previous_entry_length长度为1字节；</li>\n<li>若前一节点长度大于等于254字节，那么previous_entry_length长度为5字节，其中第一字节为0xFE，后四个字节为长度。<br>encoding：记录了节点content属性所保存的数据类型以及长度；</li>\n</ul>\n<p><img src=\"http://ww1.sinaimg.cn/large/006tNc79ly1g4la4ar43zj31820o07hl.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<p>content：保存节点的值，可以是一个字节数组或者整数。</p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>redis基于之前介绍的数据结构，创建了一个对象系统，包括字符串对象、列表对象、哈希对象、集合对象以及有序集合对象这五类。</p>\n<pre><code>typedef struct redisObject {  \n    unsigned type:4;              // 类型\n    unsigned encoding:4;          // 编码\n    unsigned lru:REDIS_LRU_BITS;  // 对象最后一次被访问的时间\n    int refcount;                 // 引用计数\n    void *ptr;                    // 指向实际值的指针\n} robj;\n</code></pre><p>type：对象的类型</p>\n<p><img src=\"http://ww3.sinaimg.cn/large/006tNc79ly1g4la53wfmjj30gy0cgwhk.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<p>redis会根据键对象的type属性进行类型检查，判断该键对象是否能执行指定的命令；如果可以则执行，否则拒绝执行并向客户端返回一个类型错误。</p>\n<p>若键能执行指定的指令，还会根据值对象的编码（encoding属性）方式，选择正确的命令实现代码执行命令。</p>\n<p>encoding：对象的编码，确定底层数据结构</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006tNc79ly1g4la5mfswxj317m0fs0zt.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<p>每个类型的对象都有多种不同编码：</p>\n<p><img src=\"http://ww4.sinaimg.cn/large/006tNc79ly1g4la64fp7dj316q0ks4dm.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<p>refcount：引用计数，用于内存回收和共享内存。</p>\n<ul>\n<li><p>内存回收：一个对象被多个程序使用时，引用计数会增加；程序不再使用时引用计数会减少，当减少到为0时，释放对象所占内存。</p>\n</li>\n<li><p>共享内存：redis服务器初始化时，会创建从0到9999共一万个字符串对象，当需要用到这些对象则共享对象而不是创建对象。</p>\n<ul>\n<li><p>字符串对象</p>\n<ul>\n<li><p>编码：int（整数）、raw（redisObject+SDS）或embstr（redisObject+embstr编码的SDS）</p>\n</li>\n<li><p>若是整数值，并且该整数值可以用long类型表示，则编码为int；若是字符串值，并且字符串长度大于32字节，那么将使用SDS保存字符串值，编码为raw；若是字符串值，并且字符串长度小于等于32字节，则编码为embstr。</p>\n</li>\n<li><p>注意：</p>\n<ul>\n<li>long double类型的浮点数是用字符串保存的，对其操作会先转化为浮点型进行操作再转化为字符串保存。</li>\n<li>对int型操作（如APPEND一个字符串），会把int转化为raw。<br>embstr字符串为只读，若要对其修改会先转化为raw。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>列表对象</p>\n<ul>\n<li><p>编码：ziplist（压缩列表）或linkedlist（双端链表）</p>\n</li>\n<li><p>当列表对象保存的字符串元素都小于64字节，并且元素数量小于512个时，使用ziplist；否则使用linkedlist，每个节点保存一个字符串对象。</p>\n</li>\n</ul>\n</li>\n<li><p>哈希对象</p>\n<ul>\n<li><p>编码：ziplist（压缩列表）或hashtable（字典）</p>\n</li>\n<li><p>哈希对象中保存的所有键值对的键和值的字符串长度都小于64字节，并且键值对数量小于512个，使用ziplist；否则使用hashtable，键和值都为字符串对象。</p>\n</li>\n</ul>\n</li>\n<li><p>集合对象</p>\n<ul>\n<li><p>编码：intset（整数集合）或hashtable（字典）</p>\n</li>\n<li><p>集合对象保存的所有元素都是整数值，并且数量不超过512个时，使用intset；否则使用hashtable，若使用hashtable，每个键都为一个字符串对象，值为NULL。</p>\n</li>\n</ul>\n</li>\n<li><p>有序集合对象</p>\n<ul>\n<li><p>编码：ziplist（压缩列表）或skiplist（zset）</p>\n</li>\n<li><p>有序结合保存的元素数量小于128个，并且元素成员长度小于64字节，使用ziplist，每个结合元素使用两个压缩列表节点保存，第一个保存成员，第二个保存分数，集合元素按分值从小到大排序；</p>\n</li>\n<li>否则使用skiplist编码，底层为zset结构，包含一个字典和一个跳跃表，其中跳跃表按分值进行排序，实现了范围查询；而字典创建了从成员到分数的映射，键为集合元素，值为分数；字典和跳跃表都使用指针指向成员和分数，因此不会</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck9m4gt7w000bupqefmt4729f","category_id":"ck9m4gt7z000gupqe7qmuj82i","_id":"ck9m4gt86000oupqe5sxx98cl"},{"post_id":"ck9m4gt7z000hupqejngo799l","category_id":"ck9m4gt7z000gupqe7qmuj82i","_id":"ck9m4gt87000uupqe2iz2vnpm"}],"PostTag":[{"post_id":"ck9m4gt7e0000upqe6lj6aplf","tag_id":"ck9m4gt7o0003upqe0ev5ucvj","_id":"ck9m4gt7x000cupqebcexl2j1"},{"post_id":"ck9m4gt7e0000upqe6lj6aplf","tag_id":"ck9m4gt7t0007upqetu3085n1","_id":"ck9m4gt7y000eupqe9i23238r"},{"post_id":"ck9m4gt7m0002upqe9jxy04ln","tag_id":"ck9m4gt7v000aupqe9pv4zkdf","_id":"ck9m4gt86000qupqevynxnb2f"},{"post_id":"ck9m4gt7m0002upqe9jxy04ln","tag_id":"ck9m4gt7y000fupqeezdro7zr","_id":"ck9m4gt87000supqej61joxq2"},{"post_id":"ck9m4gt7m0002upqe9jxy04ln","tag_id":"ck9m4gt82000jupqe1lgi5aq9","_id":"ck9m4gt88000wupqemg1vjaq0"},{"post_id":"ck9m4gt7q0004upqezgjrsfjn","tag_id":"ck9m4gt86000pupqek5sspq8r","_id":"ck9m4gt89000yupqei0bt2r1e"},{"post_id":"ck9m4gt7q0004upqezgjrsfjn","tag_id":"ck9m4gt88000vupqe3999vu30","_id":"ck9m4gt89000zupqepvblr7zm"},{"post_id":"ck9m4gt7s0005upqe26c63a1o","tag_id":"ck9m4gt88000xupqerso63olj","_id":"ck9m4gt8a0012upqeec6w529m"},{"post_id":"ck9m4gt7s0005upqe26c63a1o","tag_id":"ck9m4gt890010upqe9o8rs0p8","_id":"ck9m4gt8a0013upqer1fsu2di"},{"post_id":"ck9m4gt7t0006upqeyxxmh9y3","tag_id":"ck9m4gt7t0007upqetu3085n1","_id":"ck9m4gt8b0016upqe1eyot9ov"},{"post_id":"ck9m4gt7t0006upqeyxxmh9y3","tag_id":"ck9m4gt8a0014upqewsr9i3uz","_id":"ck9m4gt8c0017upqehe90wv0p"},{"post_id":"ck9m4gt7u0008upqenbvn1nlv","tag_id":"ck9m4gt7y000fupqeezdro7zr","_id":"ck9m4gt8c0019upqe5y7hzvhq"},{"post_id":"ck9m4gt7v0009upqethe6w40u","tag_id":"ck9m4gt8c0018upqedzfpa4nc","_id":"ck9m4gt8c001bupqe1vsz6127"},{"post_id":"ck9m4gt7w000bupqefmt4729f","tag_id":"ck9m4gt8c001aupqe8k2oumg5","_id":"ck9m4gt8d001eupqencog8g4u"},{"post_id":"ck9m4gt7w000bupqefmt4729f","tag_id":"ck9m4gt8d001cupqek9mbz7jd","_id":"ck9m4gt8d001fupqe5cod4oh4"},{"post_id":"ck9m4gt7y000dupqeqppml485","tag_id":"ck9m4gt8d001dupqeuqigktmr","_id":"ck9m4gt8e001jupqeofjgdc31"},{"post_id":"ck9m4gt7y000dupqeqppml485","tag_id":"ck9m4gt8d001gupqeik7l3on2","_id":"ck9m4gt8e001kupqez8rv9gs1"},{"post_id":"ck9m4gt7y000dupqeqppml485","tag_id":"ck9m4gt8d001hupqe2mbhpumx","_id":"ck9m4gt8e001mupqek30nqh2w"},{"post_id":"ck9m4gt7z000hupqejngo799l","tag_id":"ck9m4gt8d001iupqe0gmz962o","_id":"ck9m4gt8f001oupqefn0s05l4"},{"post_id":"ck9m4gt7z000hupqejngo799l","tag_id":"ck9m4gt8a0014upqewsr9i3uz","_id":"ck9m4gt8f001pupqejzqogcz0"},{"post_id":"ck9m4gt82000kupqe3hxnt6bi","tag_id":"ck9m4gt8d001cupqek9mbz7jd","_id":"ck9m4gt8f001tupqeez8nj2b7"},{"post_id":"ck9m4gt82000kupqe3hxnt6bi","tag_id":"ck9m4gt8c001aupqe8k2oumg5","_id":"ck9m4gt8g001uupqef26mbkoe"},{"post_id":"ck9m4gt82000kupqe3hxnt6bi","tag_id":"ck9m4gt8f001rupqe55hzrwr0","_id":"ck9m4gt8g001wupqe9y8psvg6"},{"post_id":"ck9m4gt84000mupqe39gu5ycs","tag_id":"ck9m4gt8f001supqesng6knnf","_id":"ck9m4gt8g001yupqe77f0eeb8"},{"post_id":"ck9m4gt84000mupqe39gu5ycs","tag_id":"ck9m4gt8g001vupqed7ee9ybm","_id":"ck9m4gt8g001zupqefgjimg05"},{"post_id":"ck9m4gt85000nupqep62tjr1a","tag_id":"ck9m4gt8c001aupqe8k2oumg5","_id":"ck9m4gt8h0022upqeu4j1fly3"},{"post_id":"ck9m4gt85000nupqep62tjr1a","tag_id":"ck9m4gt88000xupqerso63olj","_id":"ck9m4gt8h0023upqevp2ud6a5"},{"post_id":"ck9m4gt86000rupqejsuum9vr","tag_id":"ck9m4gt8h0021upqeobhgx2vb","_id":"ck9m4gt8i0026upqe96j89e3v"},{"post_id":"ck9m4gt86000rupqejsuum9vr","tag_id":"ck9m4gt8h0024upqetsawtmvg","_id":"ck9m4gt8i0027upqe8qb86myn"},{"post_id":"ck9m4gt87000tupqeady8hfwv","tag_id":"ck9m4gt8c001aupqe8k2oumg5","_id":"ck9m4gt8j002aupqep4x6u5z0"},{"post_id":"ck9m4gt87000tupqeady8hfwv","tag_id":"ck9m4gt88000xupqerso63olj","_id":"ck9m4gt8j002bupqesg6cka2j"},{"post_id":"ck9m4gt87000tupqeady8hfwv","tag_id":"ck9m4gt8i0029upqevkqy5c5f","_id":"ck9m4gt8j002cupqejm8nvosg"},{"post_id":"ck9m4gt8m002dupqe2tnk3rls","tag_id":"ck9m4gt8n002eupqe1bdmfg4t","_id":"ck9m4gt8o002fupqeruhp1vjl"}],"Tag":[{"name":"JSON","_id":"ck9m4gt7o0003upqe0ev5ucvj"},{"name":"SpringBoot","_id":"ck9m4gt7t0007upqetu3085n1"},{"name":"JVM","_id":"ck9m4gt7v000aupqe9pv4zkdf"},{"name":"JAVA","_id":"ck9m4gt7y000fupqeezdro7zr"},{"name":"后端","_id":"ck9m4gt82000jupqe1lgi5aq9"},{"name":"SQL","_id":"ck9m4gt86000pupqek5sspq8r"},{"name":"数据库","_id":"ck9m4gt88000vupqe3999vu30"},{"name":"MAC系统","_id":"ck9m4gt88000xupqerso63olj"},{"name":"软件","_id":"ck9m4gt890010upqe9o8rs0p8"},{"name":"Vue","_id":"ck9m4gt8a0014upqewsr9i3uz"},{"name":"单元测试","_id":"ck9m4gt8c0018upqedzfpa4nc"},{"name":"运维","_id":"ck9m4gt8c001aupqe8k2oumg5"},{"name":"Tomcat","_id":"ck9m4gt8d001cupqek9mbz7jd"},{"name":"SpringMVC","_id":"ck9m4gt8d001dupqeuqigktmr"},{"name":"AOP","_id":"ck9m4gt8d001gupqeik7l3on2"},{"name":"日志处理","_id":"ck9m4gt8d001hupqe2mbhpumx"},{"name":"前端","_id":"ck9m4gt8d001iupqe0gmz962o"},{"name":"云服务器","_id":"ck9m4gt8f001rupqe55hzrwr0"},{"name":"TOMCAT","_id":"ck9m4gt8f001supqesng6knnf"},{"name":"SHELL","_id":"ck9m4gt8g001vupqed7ee9ybm"},{"name":"ORACLE","_id":"ck9m4gt8h0021upqeobhgx2vb"},{"name":"存储过程","_id":"ck9m4gt8h0024upqetsawtmvg"},{"name":"脚本","_id":"ck9m4gt8i0029upqevkqy5c5f"},{"name":"Redis","_id":"ck9m4gt8n002eupqe1bdmfg4t"}]}}